angular.module("oinio.core", ["oinio.settings", "ionic-datepicker"]).config(["$sceDelegateProvider", "$sceProvider", function ($sceDelegateProvider, $sceProvider) {
    $sceDelegateProvider.resourceUrlWhitelist(["self", new RegExp("(https?:\\/\\/(.+?\\.)?(salesforce|force)\\.com(\\/[A-Za-z0-9\\-\\._~:\\/\\?#\\[\\]@!$&'\\(\\)\\*\\+,;\\=]*)?)")])
}]), angular.module("oinio.core.components", ["oinio.core"]), function (angular) {
    "use strict";
    angular.module("oinio.core.error", []).constant("HTTP_DEFAULT_ERROR_MSG", "An error has occured. Please contact customer support for assistance.").constant("HTTP_NETWORK_ERROR_MSG", "Unable to communicate with the server. Make sure you are connected to the internet and try again.").constant("SCRIPT_ERROR_MSG", "An error has occured and the details have been logged. Please contact customer support for assistance.").constant("LOGGING_URL", "An error has occured and the details have been logged. Please contact customer support for assistance.").constant("EXCEPTION_SEVERITY", {
        IGNORABLE: "ignorable",
        NOTEWORTHY: "noteworthy",
        RECOVERABLE: "recoverable",
        NON_RECOVERABLE: "non-recoverable"
    }).constant("PROCESS_CODE", {SYNC_ENGINE: "100"}).constant("STATUS_CODE", {
        SMART_QUERY_FAILED: "997",
        RECORD_NULL: "998",
        OTHER: "999"
    }).config(["$httpProvider", "$provide", function ($httpProvider, $provide) {
        $httpProvider.interceptors.push(["$q", "$rootScope", "$injector", "HTTP_DEFAULT_ERROR_MSG", "HTTP_NETWORK_ERROR_MSG", function ($q, $rootScope, $injector, HTTP_DEFAULT_ERROR_MSG, HTTP_NETWORK_ERROR_MSG) {
            return $rootScope.$on("$stateChangeSuccess", function (event, toState, toParams, fromState, fromParams) {
                fromState.name && $injector.get("LocalCacheService").set("previousRoutingState", {
                    stateName: fromState.name,
                    params: fromParams
                })
            }), {
                requestError: function (rejection) {
                    var message = rejection.headers("status-text") || HTTP_DEFAULT_ERROR_MSG;
                    return 0 === rejection.status && (message = HTTP_NETWORK_ERROR_MSG), $rootScope.$broadcast("error", message), $q.reject(rejection)
                }, responseError: function (response) {
                    var message = response.headers("status-text") || HTTP_DEFAULT_ERROR_MSG;
                    return 0 === response.status && (message = HTTP_NETWORK_ERROR_MSG), $rootScope.$broadcast("error", message), $q.reject(response)
                }
            }
        }]), $provide.decorator("$exceptionHandler", ["$delegate", "$injector", "APP_SETTINGS", "EXCEPTION_SEVERITY", function ($delegate, $injector, APP_SETTINGS, EXCEPTION_SEVERITY) {
            var logError = function (exception, cause) {
                var SCRIPT_ERROR_MSG = $injector.get("SCRIPT_ERROR_MSG");
                $injector.get("$rootScope").$broadcast("error", SCRIPT_ERROR_MSG);
                var data = {type: "angular", url: window.location.href, localTime: Date.now()};
                cause && (data.cause = cause), exception && (exception.severity && (data.severity = exception.severity), exception.code && (data.code = exception.code), exception.message && (data.message = exception.message), exception.stacktrace && (data.stacktrace = exception.stacktrace), exception.rawException && (data.rawException = exception.rawException), exception.localTime && (data.localTime = exception.localTime), exception.name && (data.name = exception.name), exception.stack && (data.stack = exception.stack), exception.column && (data.column = exception.column), exception.line && (data.line = exception.line), exception.sourceURL && (data.sourceURL = exception.sourceURL)), $delegate(data)
            }, redirectRoute = function () {
                $injector.get("MetaService").getMetaValueEnhance("initialized").then(function (appInitialized) {
                    if (appInitialized) {
                        var $state = $injector.get("$state"), currentStateName = $state.current.name,
                            previousState = $injector.get("LocalCacheService").get("previousRoutingState"),
                            invalidBackStates = ["app.synchronize", "app.password", "app.switch-user", "app.forgot-password", "app.new-password", "app.change-password", "synchronize", "password", "login", "switch-user", "forgot-password", "new-password"];
                        currentStateName ? "app.synchronize" !== currentStateName && "synchronize" !== currentStateName || (previousState && invalidBackStates.indexOf(previousState.stateName) === -1 ? $injector.get("$window").history.back() : $state.go($injector.get("APP_SETTINGS").START_VIEW)) : $state.go($injector.get("APP_SETTINGS").START_VIEW)
                    } else $injector.get("SalesforceLoginService").logout()
                }, function (error) {
                    throw error
                })
            };
            return function (exception, cause) {
                logError(exception, cause);
                var IonicLoadingService = $injector.get("IonicLoadingService"),
                    $ionicPopup = $injector.get("$ionicPopup"), $window = $injector.get("$window"),
                    UtilService = $injector.get("UtilService"),
                    okLabel = UtilService.translate("mobile_global_btn_ok", "cl.global.btn_ok");
                okLabel = "cl.global.btn_ok" === okLabel ? "OK" : okLabel;
                var retryLabel = UtilService.translate("mobile_global_btn_retry", "cl.global.btn_retry");
                retryLabel = "cl.global.btn_retry" === retryLabel ? "RETRY" : retryLabel;
                var cancelLabel = UtilService.translate("mobile_global_btn_cancel", "cl.global.btn_cancel");
                cancelLabel = "cl.global.btn_cancel" === cancelLabel ? "CANCEL" : cancelLabel;
                var error = exception.rawException;
                if (error && error.responseJSON && error.responseJSON.length) {
                    var errorCode = error.responseJSON[0].errorCode;
                    if ("INVALID_SESSION_ID" === errorCode) {
                        IonicLoadingService.hide();
                        var alertPopup = $ionicPopup.alert({
                            title: "ERROR: " + exception.code,
                            template: exception.message,
                            okText: okLabel
                        });
                        return void alertPopup.then(function (res) {
                            $injector.get("SalesforceLoginService").logout()
                        })
                    }
                }
                if (exception.severity) switch (exception.severity) {
                    case EXCEPTION_SEVERITY.IGNORABLE:
                        break;
                    case EXCEPTION_SEVERITY.NOTEWORTHY:
                        $window.plugins.toast.showWithOptions({
                            message: exception.message,
                            duration: 2500,
                            position: "bottom",
                            styling: {
                                opacity: 1,
                                backgroundColor: "#54698d",
                                textColor: "#FFFFFF",
                                textSize: 13,
                                cornerRadius: 4,
                                horizontalPadding: 24,
                                verticalPadding: 12
                            }
                        });
                        break;
                    case EXCEPTION_SEVERITY.RECOVERABLE:
                        IonicLoadingService.hide();
                        var confirmPopup = $ionicPopup.confirm({
                            title: "ERROR: " + exception.code,
                            template: exception.message,
                            okText: retryLabel,
                            cancelText: cancelLabel
                        });
                        confirmPopup.then(function (res) {
                            if (res) if ("function" == typeof exception.retry) {
                                var retryResult = null;
                                if (exception.retryContext || exception.retryParam) {
                                    var retryArgs = Array.isArray(exception.retryParam) ? exception.retryParam : [exception.retryParam];
                                    retryResult = exception.retry.apply(exception.retryContext, retryArgs)
                                } else retryResult = exception.retry();
                                void 0 !== exception.retryDeferred && "function" == typeof retryResult.then && retryResult.then(function (success) {
                                    exception.retryDeferred.resolve(success)
                                }, function (error) {
                                    exception.retryDeferred.reject(error)
                                }, function (notify) {
                                    exception.retryDeferred.notify(notify)
                                })
                            } else redirectRoute(); else "function" == typeof exception.cancel ? exception.cancel() : redirectRoute()
                        });
                        break;
                    case EXCEPTION_SEVERITY.NON_RECOVERABLE:
                        IonicLoadingService.hide();
                        var alertPopup2 = $ionicPopup.alert({
                            title: "ERROR: " + exception.code,
                            template: exception.message,
                            okText: okLabel
                        });
                        alertPopup2.then(function (res) {
                            redirectRoute()
                        })
                }
            }
        }])
    }]).factory("Exception", ["$exceptionHandler", "EXCEPTION_SEVERITY", "PROCESS_CODE", "STATUS_CODE", "Logger", function ($exceptionHandler, EXCEPTION_SEVERITY, PROCESS_CODE, STATUS_CODE, Logger) {
        var _classCallCheck = function (instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
        }, _possibleConstructorReturn = function (self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call
        }, _inherits = function (subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass)
        }, CommonError = function (_Error) {
            function CommonError(severity, code, message, stacktrace, rawException, retry, cancel, retryContext, retryParam, retryDeferred) {
                _classCallCheck(this, CommonError);
                var _this = _possibleConstructorReturn(this, (CommonError.__proto__ || Object.getPrototypeOf(CommonError)).call(this, message));
                return _this.severity = severity, _this.code = code, _this.message = message, _this.stacktrace = stacktrace, _this.rawException = rawException, _this.retry = retry, _this.cancel = cancel, _this.retryContext = retryContext, _this.retryParam = retryParam, _this.retryDeferred = retryDeferred, _this.localTime = Date.now(), _this.handle = function (processCode) {
                    if (processCode = processCode || PROCESS_CODE.SYNC_ENGINE, this.code && 3 === (this.code + "").length ? this.code = processCode + this.code : this.code && "" !== this.code || (this.code = processCode + STATUS_CODE.OTHER), this.severity === EXCEPTION_SEVERITY.IGNORABLE || this.severity === EXCEPTION_SEVERITY.NOTEWORTHY) $exceptionHandler(this); else if (this.severity === EXCEPTION_SEVERITY.RECOVERABLE || this.severity === EXCEPTION_SEVERITY.NON_RECOVERABLE) throw this
                }, _this.message && "" !== _this.message || !rawException || (_this.message = Logger.getErrorMessage(rawException)), _this
            }

            return _inherits(CommonError, _Error), CommonError
        }(Error);
        return CommonError
    }])
}(angular), function (angular) {
    "use strict";
    angular.module("oinio.core.logger", []).config(["$provide", function ($provide) {
        $provide.decorator("$log", ["$delegate", "Logger", function ($delegate, Logger) {
            Logger.enabled = !0;
            var methods = {
                debug: function () {
                    Logger.enabled && Logger.debug.apply(null, arguments)
                }, error: function () {
                    Logger.enabled && Logger.error.apply(null, arguments)
                }, log: function () {
                    Logger.enabled && Logger.log.apply(null, arguments)
                }, info: function () {
                    Logger.enabled && Logger.info.apply(null, arguments)
                }, warn: function () {
                    Logger.enabled && Logger.warn.apply(null, arguments)
                }
            };
            return methods
        }])
    }])
}(angular), angular.module("oinio.core.modal", ["oinio.core"]), angular.module("oinio.core.detail", ["oinio.core", "oinio.core.pageLayoutRenderer"]), angular.module("oinio.core.object-home", ["oinio.core"]), angular.module("oinio.core.pageLayoutRenderer", []), function () {
    "use strict";
    angular.module("oinio.core").filter("addressFormatter", ["LocalesService", function (LocalesService) {
        return function (addressToFormat) {
            if (!addressToFormat) return addressToFormat;
            var addressPattern = LocalesService.getAddressFormat();
            if (!addressPattern) return addressToFormat;
            var addressItem, separator, startOfSeparator, endOfSeparator, addressToFormatJSON,
                addressItems = addressPattern.split("/"), formattedAddress = "";
            if ("string" == typeof addressToFormat) addressToFormatJSON = JSON.parse(addressToFormat); else {
                if ("object" != typeof addressToFormat) return addressToFormat;
                addressToFormatJSON = addressToFormat
            }
            for (var i = 0; i < addressItems.length; i++) addressItem = addressItems[i], addressItem && (addressItem.indexOf("<") >= 0 ? (startOfSeparator = addressItem.indexOf("<"), endOfSeparator = addressItem.indexOf(">"), separator = addressItem.slice(startOfSeparator + 1, endOfSeparator), formattedAddress += separator) : void 0 !== addressToFormatJSON[addressItem] && null !== addressToFormatJSON[addressItem] && (formattedAddress += addressToFormatJSON[addressItem]));
            return formattedAddress
        }
    }])
}(), function () {
    "use strict";
    angular.module("oinio.core").filter("currencyByIsoCodeFormatter", ["$filter", "LocalesService", function ($filter, LocalesService) {
        return function (valueToFormat, currencyIsoCode) {
            return currencyIsoCode = currencyIsoCode || LocalesService.getCurrencyIsoCode(), currencyIsoCode + " " + $filter("numberFormatter")(valueToFormat)
        }
    }])
}(), function () {
    "use strict";
    angular.module("oinio.core").filter("currencyFormatter", ["$filter", "LocalesService", function ($filter, LocalesService) {
        return function (valueToFormat) {
            return LocalesService.getCurrencySymbolBefore() ? LocalesService.getCurrencySymbol() + " " + $filter("numberFormatter")(valueToFormat) : $filter("numberFormatter")(valueToFormat) + " " + LocalesService.getCurrencySymbol()
        }
    }])
}(), function () {
    "use strict";
    angular.module("oinio.core").filter("dateFormatter", ["$filter", "LocalesService", function ($filter, LocalesService) {
        return function (dateToFormat) {
            return $filter("date")(dateToFormat, LocalesService.getDateFormat())
        }
    }])
}(), function () {
    "use strict";
    angular.module("oinio.core").filter("dateTimeFormatter", ["$filter", "LocalesService", function ($filter, LocalesService) {
        return function (dateTimeToFormat) {
            return $filter("date")(dateTimeToFormat, LocalesService.getDateTimeFormat())
        }
    }])
}(), function (angular, _) {
    "use strict";
    angular.module("oinio.core").filter("fieldLabel", ["$filter", function ($filter) {
        return function (field) {
            var result;
            if (field.fieldTranslateKey) {
                var fieldTranslateLabel = $filter("translate")(field.fieldTranslateKey);
                if (_.endsWith(fieldTranslateLabel, " ID") && (fieldTranslateLabel = fieldTranslateLabel.substring(0, fieldTranslateLabel.length - 2).trim()), result = fieldTranslateLabel, field.refer2FieldTranslateKey) {
                    var referenceToFieldLabel = $filter("translate")(field.refer2FieldTranslateKey);
                    if (referenceToFieldLabel) {
                        var reg = new RegExp(fieldTranslateLabel, "g");
                        referenceToFieldLabel = referenceToFieldLabel.replace(reg, ""), result += " " + referenceToFieldLabel
                    }
                }
            }
            return result
        }
    }])
}(angular, _), function () {
    "use strict";
    angular.module("oinio.core").filter("numberFormatter", ["$filter", "$locale", "LocalesService", function ($filter, $locale, LocalesService) {
        return function (numberToFormat) {
            return "." !== $locale.NUMBER_FORMATS.DECIMAL_SEP && (numberToFormat = numberToFormat ? numberToFormat.toString().trim().replace($locale.NUMBER_FORMATS.DECIMAL_SEP, ".") : ""), $filter("number")(numberToFormat, LocalesService.getDecimalPlaces())
        }
    }])
}(), function () {
    "use strict";
    angular.module("oinio.core").filter("timeFormatter", ["$filter", "LocalesService", function ($filter, LocalesService) {
        return function (timeToFormat) {
            return $filter("date")(timeToFormat, LocalesService.getTimeFormat())
        }
    }])
}(), angular.module("oinio.core.pageLayoutRenderer").service("customScrollDelegateService", ["$ionicScrollDelegate", function ($ionicScrollDelegate) {
    var custom = {
        $getByHandle: function (name) {
            var instances = $ionicScrollDelegate.$getByHandle(name)._instances;
            return instances.filter(function (element) {
                return element.$$delegateHandle == name
            })[0]
        }
    };
    return custom
}]), angular.module("oinio.core.pageLayoutRenderer").service("localizeService", ["$http", "$filter", function ($http, $filter) {
    this.getFormattedString = function (value, type, params) {
        var scale;
        if (!value) return "";
        params && params.scale || (scale = 2);
        var formatted;
        switch (type) {
            case"date":
                formatted = $filter("dateFormatter")(value);
                break;
            case"datetime":
                formatted = $filter("dateTimeFormatter")(value);
                break;
            case"percent":
                formatted = $filter("numberFormatter")(value) + " %";
                break;
            case"currency":
                formatted = $filter("currencyByIsoCodeFormatter")(value);
                break;
            case"int":
                formatted = $filter("number")(value, "0");
                break;
            case"double":
                formatted = $filter("numberFormatter")(value);
                break;
            case"address":
                formatted = $filter("addressFormatter")(value);
                break;
            case"boolean":
                formatted = value ? "yes" : "no";
                break;
            default:
                formatted = value
        }
        return formatted
    }, this.getObjectURL = function (sobject, relationshipName) {
        return sobject[relationshipName] ? "{objectType: '" + sobject[relationshipName].type + "', sid: " + sobject[relationshipName]._soupEntryId + "}" : ""
    }, this.getReferenceLabel = function (sobject, relationshipName, objectType) {
        var referencedField;
        if (!sobject[relationshipName]) return "";
        switch (objectType) {
            case"Task":
            case"Event":
            case"Attachment":
            case"Case":
                referencedField = "Subject";
                break;
            default:
                referencedField = "Name"
        }
        return sobject[relationshipName][referencedField]
    }, this.getPicklistLabel = function (sobject, picklist, values) {
        var label = "", selectedValue = sobject[picklist];
        if (selectedValue) for (var i = 0; i < values.length; i++) if (values[i].value === selectedValue) {
            label = values[i].label;
            break
        }
        return label
    }, this.getMultiPicklistLabel = function (sobject, picklist, values) {
        var sMulitPicklistLabels = "", sSelectedValues = sobject[picklist];
        if (sSelectedValues) {
            for (var aSelectedValues = sSelectedValues.split(";"), aMulitPicklistLabels = [], i = 0; i < values.length; i++) if (aSelectedValues.indexOf(values[i].value) !== -1) {
                var entry = values[i].label;
                aMulitPicklistLabels.push(entry)
            }
            return aMulitPicklistLabels.toString().replace(/,/g, ", ")
        }
        return sMulitPicklistLabels
    }
}]), function (angular) {
    "use strict";
    angular.module("oinio.core.pageLayoutRenderer").service("PageLayoutService", ["$q", "$log", "SalesforceDataService", "DescribeService", "LocalDataService", function ($q, $log, SalesforceDataService, DescribeService, LocalDataService) {
        this.generatePageLayout = function (objectType, sid, isEdit) {
            var deferred = $q.defer();
            return LocalDataService.getSObject(objectType, sid).then(function (sobject) {
                this.processPageLayoutGeneration(objectType, sobject, isEdit).then(function (pageLayoutResult) {
                    deferred.resolve({layout: pageLayoutResult.layout, sobject: pageLayoutResult.sobject})
                }, function (error) {
                    deferred.reject(error)
                })
            }.bind(this), function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, this.generatePageLayoutForSObject = function (sobject, isEdit) {
            var deferred = $q.defer();
            return this.processPageLayoutGeneration(sobject.attributes.type, sobject, isEdit).then(function (pageLayoutResult) {
                deferred.resolve({layout: pageLayoutResult.layout, sobject: pageLayoutResult.sobject})
            }, function (error) {
                deferred.reject()
            }), deferred.promise
        }, this.generatePageLayoutForNew = function (objectType, recordType) {
            var deferred = $q.defer();
            return LocalDataService.createSObject(objectType, recordType).then(function (sobject) {
                this.processPageLayoutGeneration(objectType, sobject, !0).then(function (pageLayoutResult) {
                    deferred.resolve({layout: pageLayoutResult.layout, sobject: pageLayoutResult.sobject})
                }, function (error) {
                    deferred.reject(error)
                })
            }.bind(this), function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, this.processPageLayoutGeneration = function (objectType, sobject, isEdit) {
            var deferred = $q.defer(), recordTypeId = sobject.RecordTypeId;
            return DescribeService.getDescribeLayout(objectType, recordTypeId).then(function (describe) {
                $log.debug("start generating layout for" + objectType + " and RecordType: " + recordTypeId);
                var res;
                res = isEdit ? describe.layoutResult.editLayoutSections : describe.layoutResult.detailLayoutSections;
                for (var i = res.length - 1; i > -1; i--) {
                    for (var section = res[i], rowsDeleted = 0, j = section.layoutRows.length - 1; j > -1; j--) {
                        for (var layoutRow = section.layoutRows[j], itemsDeleted = 0, k = layoutRow.layoutItems.length - 1; k > -1; k--) {
                            var layoutItem = layoutRow.layoutItems[k];
                            if ("EmptySpace" !== layoutItem.type) {
                                for (var l = layoutItem.layoutComponents.length - 1; l > -1; l--) {
                                    var layoutComponent = layoutItem.layoutComponents[l];
                                    "EmptySpace" !== layoutComponent.type && "Separator" !== layoutComponent.type && (sobject.hasOwnProperty(layoutComponent.value) ? layoutComponent = null : (layoutItem.type = "EmptySpace", layoutItem.placeholder = !0, delete layoutItem.required, delete layoutItem.editableForNew, delete layoutItem.editableForUpdate, itemsDeleted++))
                                }
                                layoutItem = null
                            }
                        }
                        layoutRow.numItems === itemsDeleted && (section.layoutRows.splice(j, 1), rowsDeleted++), layoutRow = null
                    }
                    rowsDeleted === section.rows && res.splice(i, 1), section = null, rowsDeleted = null
                }
                deferred.resolve({layout: res, sobject: sobject})
            }, function (err) {
                $log.debug("merge sobject with pagelayout error in PageLayoutService " + JSON.stringify(err)), deferred.reject(err)
            }), deferred.promise
        }
    }])
}(angular), angular.module("oinio.core.pageLayoutRenderer").component("pageLayoutRenderer", {
    templateUrl: "app/core/pagelayout/pagelayoutrenderer.component.html",
    bindings: {
        rendermode: "<",
        showHeader: "<",
        collapseSections: "<",
        sobject: "<",
        pageLayout: "<",
        readOnlyFields: "<"
    },
    controller: function () {
        this.$onInit = function () {
        }
    },
    restrict: "E",
    transclude: "true",
    controllerAs: "$ctrl"
}), function (angular) {
    "use strict";
    angular.module("oinio.core").service("ConfigurationService", ["APP_SETTINGS", "$q", "$http", "$filter", "LocalCacheService", "DescribeService", "LocalDataService", "SMARTSTORE_COMMON_SETTING", function (APP_SETTINGS, $q, $http, $filter, LocalCacheService, DescribeService, LocalDataService, SMARTSTORE_COMMON_SETTING) {
        function buildSoupSettings(data) {
            var soupSettings = [];
            return angular.forEach(data, function (objectType) {
                var soupName = objectType.targetSoup ? objectType.targetSoup : objectType.name, indexSpec = [];
                angular.forEach(objectType.indexSpec, function (field) {
                    indexSpec.push({path: field.path, type: field.type})
                });
                var soup = {
                    name: soupName,
                    objectTypeName: objectType.name,
                    indexSpec: indexSpec,
                    externalStorage: objectType.externalStorage
                };
                soupSettings.push(soup)
            }), soupSettings
        }

        var service = this, _configuredLayoutableObjectTypes = [], _configuredObjectTypes = [];
        service.globalSoupSettings = function () {
            var deferred = $q.defer();
            return $http.get(APP_SETTINGS.GLOBAL_SOUP_CONFIGURATION_FILE).then(function (globalSoups) {
                var soupSettings = buildSoupSettings(globalSoups.data);
                deferred.resolve(soupSettings)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.frameworkSoupSettings = function () {
            var deferred = $q.defer();
            return $http.get(APP_SETTINGS.FRAMEWORK_SOUP_CONFIGURATION_FILE).then(function (frameworkSoups) {
                var soupSettings = buildSoupSettings(frameworkSoups.data);
                deferred.resolve(soupSettings)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.objectTypesToSynchronize = function () {
            var deferred = $q.defer(), objectTypes = [];
            return LocalDataService.queryConfigurationAndObjects().then(function (configuration) {
                var i = 0, parseConfiguration = function () {
                    if (void 0 === configuration.objects) return void deferred.resolve(objectTypes);
                    if (i < configuration.objects.length) {
                        var configObj = configuration.objects[i];
                        service.parseObjectTypeFromMobileConfiguration(configObj).then(function (objectType) {
                            objectTypes.push(objectType), i++, parseConfiguration()
                        }, function (error) {
                            deferred.reject(error)
                        })
                    } else deferred.resolve(objectTypes)
                };
                parseConfiguration()
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.getConfiguredObjectTypes = function (layoutable) {
            var deferred = $q.defer();
            return 0 === _configuredObjectTypes.length ? DescribeService.getDescribeSObjects(!1).then(function (describeSObjects) {
                for (var layoutableObjectTypes = [], objectTypes = [], i = 0; i < describeSObjects.length; i++) {
                    var describeSObject = describeSObjects[i];
                    objectTypes.push(describeSObject.objectType), describeSObject.describe.layoutable && layoutableObjectTypes.push(describeSObject.objectType)
                }
                _configuredLayoutableObjectTypes = layoutableObjectTypes, _configuredObjectTypes = objectTypes, layoutable ? deferred.resolve(_configuredLayoutableObjectTypes) : deferred.resolve(_configuredObjectTypes)
            }, function (error) {
                deferred.reject([])
            }) : layoutable ? deferred.resolve(_configuredLayoutableObjectTypes) : deferred.resolve(_configuredObjectTypes), deferred.promise
        }, service.parseObjectTypeFromMobileConfiguration = function (configObj) {
            var deferred = $q.defer();
            return DescribeService.getDescribeSObject(configObj.Name).then(function (describeResult) {
                var indexSpec = [{path: "Id", type: "string"}],
                    skipConfigurationObjects = ["MobileVizArt__Mobile_Configuration__c", "MobileVizArt__Mobile_Object__c", "User", "Group"],
                    syncedFields = configObj.MobileVizArt__Fields__c.replace(new RegExp(/\s/g), "").split(","),
                    fields = [];
                angular.forEach(describeResult.fields, function (fieldItem) {
                    if (syncedFields.indexOf(fieldItem.name) !== -1 || skipConfigurationObjects.indexOf(configObj.Name) !== -1) if (fields.push(fieldItem.name), "reference" === fieldItem.type) {
                        var referenceIndex = {path: fieldItem.name, type: "string"}, referenceSidIndex = {
                            path: fieldItem.name + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_EXTENSION_SUFFIX,
                            type: "integer"
                        }, referenceTypeIndex = {
                            path: fieldItem.name + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_TYPE_SUFFIX,
                            type: "string"
                        };
                        indexSpec.push(referenceIndex), indexSpec.push(referenceSidIndex), indexSpec.push(referenceTypeIndex)
                    } else {
                        var fieldSearchableByDefault = ["Name", "Subject", "IsDeleted", "IsConverted"];
                        if (fieldSearchableByDefault.indexOf(fieldItem.name) !== -1) {
                            var fieldSearchIndex = {path: fieldItem.name, type: "string"};
                            indexSpec.push(fieldSearchIndex)
                        }
                    }
                }), void 0 !== configObj.MobileVizArt__Search_Fields__c && null != configObj.MobileVizArt__Search_Fields__c && angular.forEach(configObj.MobileVizArt__Search_Fields__c.replace(new RegExp(/\s/g), "").split(","), function (searchField) {
                    indexSpec.push({path: searchField, type: "string"})
                }), "Attachment" === configObj.Name ? (indexSpec.push({
                    path: "_bodySynced",
                    type: "string"
                }), indexSpec.push({
                    path: "_bodySyncOnDemand",
                    type: "string"
                })) : "ContentVersion" === configObj.Name && (indexSpec.push({
                    path: "IsLatest",
                    type: "string"
                }), indexSpec.push({path: "VersionNumber", type: "string"}), indexSpec.push({
                    path: "_versionDataSynced",
                    type: "string"
                }), indexSpec.push({path: "_versionDataSyncOnDemand", type: "string"}));
                var objectType = {
                    name: configObj.Name,
                    label: describeResult.label,
                    fields: fields,
                    filterCriteria: configObj.MobileVizArt__Filter_Criteria__c,
                    lookupModStamp: configObj.MobileVizArt__Lookup_Mod_Stamp__c,
                    indexSpec: indexSpec,
                    level: configObj.MobileVizArt__Level__c,
                    _soupEntryId: configObj._soupEntryId,
                    needCleanUp: !configObj.MobileVizArt__Skip_Cleanup__c
                };
                deferred.resolve(objectType)
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, service.mobileConfigurationToSynchronize = function () {
            var deferred = $q.defer();
            return $http.get(APP_SETTINGS.MOBILE_CONFIGURATION_FILE).then(function (objectTypesConfig) {
                var objectTypes = objectTypesConfig.data, index = 0, loadEachObject = function (records) {
                    if (records && records.length !== index) {
                        var objectType = records[index];
                        index++, DescribeService.loadDescribeSObject(objectType.name).then(function (describeResult) {
                            var fields = [];
                            angular.forEach(describeResult.fields, function (fieldItem) {
                                fields.push(fieldItem.name)
                            }), objectType.fields = fields, loadEachObject(records)
                        }, function (error) {
                            deferred.reject(error)
                        })
                    } else deferred.resolve(records)
                };
                loadEachObject(objectTypes)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.getBusinessObjectTypeByName = function (objectName) {
            var deferred = $q.defer(), objectTypes = LocalCacheService.get("_businessObjectTypes");
            return objectTypes ? deferred.resolve(_.findWhere(objectTypes, {name: objectName})) : service.objectTypesToSynchronize().then(function (objectTypes) {
                LocalCacheService.set("_businessObjectTypes", objectTypes), deferred.resolve(_.findWhere(objectTypes, {name: objectName}))
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.objectTypeSoupSettings = function () {
            var deferred = $q.defer();
            return service.objectTypesToSynchronize().then(function (objectTypes) {
                var soupSettings = buildSoupSettings(objectTypes);
                deferred.resolve(soupSettings)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }
    }])
}(angular), function (angular) {
    "use strict";
    angular.module("oinio.core").service("ConnectionMonitor", ["$rootScope", "$cordovaNetwork", "$log", function ($rootScope, $cordovaNetwork, $log) {
        this.isOnline = function () {
            return ionic.Platform.isWebView() ? $cordovaNetwork.isOnline() : navigator.onLine
        }, this.isOffline = function () {
            return ionic.Platform.isWebView() ? !$cordovaNetwork.isOnline() : !navigator.onLine
        }, this.startWatching = function () {
            ionic.Platform.isWebView() ? ($rootScope.$on("$cordovaNetwork:online", function (event, networkState) {
                $log.debug(">>>> went online")
            }), $rootScope.$on("$cordovaNetwork:offline", function (event, networkState) {
                $log.debug(">>>> went offline")
            })) : (window.addEventListener("online", function (e) {
                $log.debug(">>>> went online")
            }), window.addEventListener("offline", function (e) {
                $log.debug(">>>> went offline")
            }))
        }
    }])
}(angular), function (angular, _) {
    "use strict";
    angular.module("oinio.core").service("DescribeService", ["$q", "ForceClientService", "MetaService", "$log", "$http", "$cordovaFile", "SMARTSTORE_COMMON_SETTING", "UtilService", "$timeout", "LocalCacheService", "Exception", function ($q, ForceClientService, MetaService, $log, $http, $cordovaFile, SMARTSTORE_COMMON_SETTING, UtilService, $timeout, LocalCacheService, Exception) {
        function getFieldsInfo(layoutResult, fieldName) {
            var layoutRows = _.reduceRight(layoutResult.editLayoutSections, function (a, b) {
                return a.concat(b.layoutRows)
            }, []), layoutItems = _.reduceRight(layoutRows, function (a, b) {
                return a.concat(b.layoutItems)
            }, []), layoutComponents = _.reduceRight(layoutItems, function (a, b) {
                return a.concat(b.layoutComponents)
            }, []), details = _.reduceRight(layoutComponents, function (a, b) {
                return a.concat(b.details)
            }, []);
            return fieldName ? _.findWhere(details, {name: fieldName}) : details
        }

        var describeSObjectsCache, describeTabsCache, keyPrefixMapCache, objectNameMapCache, service = this,
            skipSyncDescribeLayoutObjects = ["ContentDocument", "ContentVersion", "ContentDocumentLink"];
        service.getDescribeSObject = function (objectType, clearCache) {
            var deferred = $q.defer();
            return service.getDescribeSObjects(clearCache).then(function (describeSObjects) {
                var describeSObject = _.findWhere(describeSObjects, {objectType: objectType});
                describeSObject ? deferred.resolve(describeSObject.describe) : deferred.reject("Error: DescribeSObject for " + objectType + " doesn't exist.")
            }, function (error) {
                deferred.reject("Error in DescribeService - getDescribeSObject(): " + error)
            }), deferred.promise
        }, service.getDescribeSObjects = function (clearCache) {
            var deferred = $q.defer(),
                querySpec = navigator.smartstore.buildAllQuerySpec("objectType", null, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
            return describeSObjectsCache && describeSObjectsCache.length > 0 && !clearCache ? deferred.resolve(describeSObjectsCache) : navigator.smartstore.querySoup("_describeSObject", querySpec, function (cursor) {
                describeSObjectsCache = cursor.currentPageOrderedEntries, deferred.resolve(describeSObjectsCache)
            }, function (error) {
                deferred.reject("Error in DescribeService - getDescribeSObjects(): " + error)
            }), deferred.promise
        }, service.loadDescribeSObject = function (objectType, notCheckModified) {
            var deferred = $q.defer(), forceClient = ForceClientService.getForceClient(), describeSObjectResult = [];
            return MetaService.getObjectMetaByType(objectType).then(function (objMeta) {
                var lastCheckDescribeDate = null;
                objMeta && objMeta.lastCheckDescribeDate && (lastCheckDescribeDate = objMeta.lastCheckDescribeDate);
                var headerParam = {};
                forceClient.describeWithHeader(objectType, function (describeResult) {
                    if (describeResult) {
                        var newCheckDate = arguments[2].getResponseHeader("Date"),
                            lastModifiedDate = arguments[2].getResponseHeader("Last-Modified");
                        describeSObjectResult.push({
                            objectType: objectType,
                            describe: describeResult
                        }), navigator.smartstore.upsertSoupEntriesWithExternalId(!1, "_describeSObject", describeSObjectResult, "objectType", function () {
                            MetaService.updateLastCheckDescribeDate(objectType, newCheckDate).then(function () {
                                var updateLanguage = !0;
                                if (objectType.indexOf("__c") > -1 && !notCheckModified && lastModifiedDate && lastCheckDescribeDate) {
                                    var lastModified = new Date(lastModifiedDate),
                                        lastCheck = new Date(lastCheckDescribeDate);
                                    lastModified <= lastCheck && (updateLanguage = !1)
                                }
                                updateLanguage ? updateI18NData(describeResult).then(function () {
                                    deferred.resolve(describeResult)
                                }, function (error) {
                                    deferred.reject(error)
                                }) : deferred.resolve(describeResult)
                            }, function (error) {
                                deferred.reject(error)
                            })
                        }, function (error) {
                            deferred.reject(error)
                        })
                    } else {
                        var querySpec = navigator.smartstore.buildExactQuerySpec("objectType", objectType);
                        navigator.smartstore.querySoup("_describeSObject", querySpec, function (cursor) {
                            var describes = cursor.currentPageOrderedEntries;
                            describes && describes.length > 0 && null != describes[0] && null != describes[0].describe ? deferred.resolve(describes[0].describe) : deferred.reject(">>>> getDescribeSObject failed")
                        }, function (error) {
                            deferred.reject(error)
                        })
                    }
                }, function (error) {
                    $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject(error)
                }, headerParam)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.loadDescribeSObjects = function (objectTypes, notCheckModified) {
            var deferred = $q.defer(), describeSObjectResults = [], loadEachObject = function (objectTypes) {
                console.log('current object type:::', objectTypes);
                console.log('current time:::', new Date());
                objectTypes && 0 !== objectTypes.length ? service.loadDescribeSObject(objectTypes.pop(), notCheckModified).then(function (describeResult) {
                    console.log('current result:::', describeResult);
                    describeSObjectResults.push(describeResult), loadEachObject(objectTypes)
                }, function (error) {
                    deferred.reject(error)
                }) : deferred.resolve(describeSObjectResults)
            };
            return loadEachObject(objectTypes), deferred.promise
        }, service.loadDescribeLayout = function (objectType, recordTypeInfos) {
            var deferred = $q.defer(), promises = [], forceClient = ForceClientService.getForceClient(),
                describeLayoutResult = {objectType: objectType, describeLayouts: []};
            return recordTypeInfos && 0 === recordTypeInfos.length && recordTypeInfos.push({
                available: !0,
                defaultRecordTypeMapping: !0,
                master: !0,
                name: "Master",
                recordTypeId: "012000000000000AAA"
            }), angular.forEach(recordTypeInfos, function (recordTypeInfo) {
                var promise = forceClient.describeLayout(objectType, recordTypeInfo.recordTypeId, function (layoutResult) {
                    describeLayoutResult.describeLayouts.push({
                        defaultRecordTypeMapping: recordTypeInfo.defaultRecordTypeMapping,
                        master: recordTypeInfo.master,
                        name: recordTypeInfo.name,
                        recordTypeId: recordTypeInfo.recordTypeId,
                        layoutResult: layoutResult
                    })
                });
                promises.push(promise)
            }), $q.all(promises).then(function () {
                navigator.smartstore.upsertSoupEntriesWithExternalId(!1, "_describeLayout", [describeLayoutResult], "objectType", function () {
                    deferred.resolve(describeLayoutResult)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject(error)
            }), deferred.promise
        }, service.loadDescribeLayouts = function (describeSObjectResult) {
            var deferred = $q.defer(), promises = [];
            return angular.forEach(describeSObjectResult, function (describeSObject) {
                if (skipSyncDescribeLayoutObjects.indexOf(describeSObject.name) === -1 && describeSObject.customSetting === !1) {
                    if (describeSObject.layoutable === !1) return void $log.debug(">>>> " + describeSObject.name + " is not layoutable");
                    promises.push(service.loadDescribeLayout(describeSObject.name, describeSObject.recordTypeInfos))
                }
            }), $q.all(promises).then(function (result) {
                deferred.resolve(result)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.getDescribeLayout = function (objectType, recordTypeId) {
            var deferred = $q.defer(), querySpec = navigator.smartstore.buildExactQuerySpec("objectType", objectType);
            return navigator.smartstore.querySoup("_describeLayout", querySpec, function (cursor) {
                for (var i = 0; i < cursor.currentPageOrderedEntries.length; i++) for (var describeLayoutResult = cursor.currentPageOrderedEntries[i], j = 0; j < describeLayoutResult.describeLayouts.length; j++) {
                    var describeLayout = describeLayoutResult.describeLayouts[j];
                    if (describeLayout.recordTypeId === recordTypeId || null == recordTypeId && describeLayout.master === !0) {
                        deferred.resolve(describeLayout);
                        break
                    }
                }
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.getSObjectWritableFields = function (objectType) {
            var deferred = $q.defer(), writableFields = [];
            return service.getDescribeSObject(objectType).then(function (describeResult) {
                angular.forEach(describeResult.fields, function (fieldItem) {
                    (fieldItem.createable || fieldItem.updateable) && writableFields.push(fieldItem.name)
                }), deferred.resolve(writableFields)
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        };
        var updateI18NData = function (describeResult) {
            var deferred = $q.defer(), currentUser = LocalCacheService.get("currentUser"),
                languageLocaleKey = currentUser.LanguageLocaleKey, i18nDir = "i18n",
                i18nFilePath = i18nDir + "/locale-objects-" + languageLocaleKey + ".json",
                objectType = describeResult.name,
                objectI18NData = {label: describeResult.label, labelPlural: describeResult.labelPlural};
            return angular.forEach(describeResult.fields, function (fieldItem) {
                objectI18NData[fieldItem.name] = fieldItem.label
            }), loadI18NData(i18nFilePath).then(function (i18nFileContent) {
                i18nFileContent[objectType] = objectI18NData, checkAndCreateDir(cordova.file.dataDirectory, i18nDir).then(function () {
                    $cordovaFile.writeFile(cordova.file.dataDirectory, i18nFilePath, JSON.stringify(i18nFileContent), !0).then(function (success) {
                        deferred.resolve(success)
                    }, function (error) {
                        deferred.reject(error)
                    })
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, checkAndCreateDir = function (fileSystem, dirName) {
            var deferred = $q.defer();
            return $cordovaFile.checkDir(fileSystem, dirName).then(function (success) {
                deferred.resolve()
            }, function (err) {
                $cordovaFile.createDir(fileSystem, dirName).then(function () {
                    deferred.resolve()
                }, function (err) {
                    deferred.reject(err)
                })
            }), deferred.promise
        }, loadI18NData = function (i18nFilePath) {
            var deferred = $q.defer();
            return $cordovaFile.readAsText(cordova.file.dataDirectory, i18nFilePath).then(function (success) {
                deferred.resolve(JSON.parse(success))
            }, function (error) {
                deferred.resolve({})
            }), deferred.promise
        };
        service.getFieldsInfoFromLayout = function (filterInfo) {
            var deferred = $q.defer(),
                querySpec = navigator.smartstore.buildExactQuerySpec("objectType", filterInfo.objectName, 1);
            return navigator.smartstore.querySoup(!1, "_describeLayout", querySpec, function (cursor) {
                var fieldsInfo,
                    result = cursor && cursor.currentPageOrderedEntries && cursor.currentPageOrderedEntries.length ? cursor.currentPageOrderedEntries[0] : null;
                if (result) {
                    var describeLayoutItem;
                    filterInfo.recordTypeId ? describeLayoutItem = _.findWhere(result.describeLayouts, {recordTypeId: filterInfo.recordTypeId}) : (describeLayoutItem = _.findWhere(result.describeLayouts, {defaultRecordTypeMapping: !0}), filterInfo.recordTypeId = describeLayoutItem.recordTypeId), describeLayoutItem && (fieldsInfo = getFieldsInfo(describeLayoutItem.layoutResult, filterInfo.fieldName))
                }
                deferred.resolve(fieldsInfo)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.getTabIconPathInAsset = function (objectType) {
            var deferred = $q.defer(), iconRootPath = "lib/salesforce-lightning-design-system/assets/icons/";
            return service.getDescribeTabs().then(function (describeTabs) {
                var iconPath, tabInfo = _.findWhere(describeTabs, {sobjectName: objectType});
                if (tabInfo) {
                    var svgInfo = _.findWhere(tabInfo.icons, {contentType: "image/svg+xml"});
                    if (svgInfo) {
                        var svgUrl = svgInfo.url;
                        if (svgUrl) {
                            var needInfo = new RegExp("\\w+/\\w+.svg$").exec(svgUrl);
                            if (needInfo) {
                                var needInfoArr = ("" + needInfo).split("/");
                                iconPath = iconRootPath + needInfoArr[0] + "-sprite/svg/symbols.svg#" + needInfoArr[1].substring(0, needInfoArr[1].length - 4)
                            }
                        }
                    }
                }
                iconPath ? deferred.resolve({
                    path: iconPath,
                    srcType: "svg"
                }) : tabInfo ? deferred.resolve({
                    path: tabInfo.iconUrl,
                    srcType: "http"
                }) : deferred.reject("Failed to get tab icon path in lightning design system svg")
            }, function (error) {
                deferred.reject("Error in DescribeService - getTabIconPathInAsset(): " + error)
            }), deferred.promise
        };
        var alreadyLoadDescribeTabs = !1;
        service.getDescribeTabs = function (times) {
            var deferred = $q.defer();
            return alreadyLoadDescribeTabs ? describeTabsCache ? deferred.resolve(describeTabsCache) : $timeout(function () {
                describeTabsCache ? deferred.resolve(describeTabsCache) : (times = times ? times : 0, times < 10 ? service.getDescribeTabs(times + 1) : deferred.reject("Failed to load describe tabs info exceed the timeout."))
            }, 3e3) : (alreadyLoadDescribeTabs = !0, loadDescribeTabs().then(function (describeTabs) {
                describeTabsCache = describeTabs, deferred.resolve(describeTabsCache)
            }, function (error) {
                deferred.reject("Error in DescribeService - getDescribeTabs(): " + error)
            })), deferred.promise
        };
        var loadDescribeTabs = function () {
            var deferred = $q.defer();
            return UtilService.isDeviceOnline().then(function (online) {
                if (online === !0) {
                    var forceClient = ForceClientService.getForceClient();
                    forceClient.describeTabs(function (describeTabs) {
                        MetaService.setMetaValue("_describeTabs", describeTabs), deferred.resolve(describeTabs)
                    }, function (error) {
                        $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject("Failed to load describe tabs info from salesforce: " + error)
                    })
                } else {
                    var describeTabs = MetaService.getMetaValue("_describeTabs");
                    null !== describeTabs ? deferred.resolve(describeTabs) : deferred.reject("Failed to load describe tabs info from meta")
                }
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        service.getKeyPrefix = function (objectType) {
            var deferred = $q.defer();
            if (keyPrefixMapCache) deferred.resolve(keyPrefixMapCache[objectType]); else {
                var keyPrefixMap = {};
                service.getDescribeSObjects(!1).then(function (describeSObjects) {
                    for (var i = 0; i < describeSObjects.length; i++) {
                        var describe = describeSObjects[i].describe;
                        keyPrefixMap[describe.name] = describe.keyPrefix
                    }
                    keyPrefixMapCache = keyPrefixMap, deferred.resolve(keyPrefixMap[objectType])
                }, function (err) {
                    deferred.reject(err)
                })
            }
            return deferred.promise
        }, service.getObjectNameByKeyPrefix = function (keyPrefix) {
            keyPrefix = keyPrefix.substr(0, 3);
            var deferred = $q.defer();
            if (objectNameMapCache) deferred.resolve(objectNameMapCache[keyPrefix]); else {
                var objectNameMap = {};
                service.getDescribeSObjects(!1).then(function (describeSObjects) {
                    for (var i = 0; i < describeSObjects.length; i++) {
                        var describe = describeSObjects[i].describe;
                        objectNameMap[describe.keyPrefix] = describe.name
                    }
                    objectNameMapCache = objectNameMap, deferred.resolve(objectNameMap[keyPrefix])
                }, function (err) {
                    deferred.reject(err)
                })
            }
            return deferred.promise
        }
    }])
}(angular, _), function (angular, _) {
    "use strict";
    angular.module("oinio.core").service("FileService", ["$q", "$filter", "$cordovaFile", "$log", "APP_SETTINGS", "UtilService", "LocalCacheService", "LOG_SETTING", "$cordovaEmailComposer", "Logger", "$injector", "$timeout", function ($q, $filter, $cordovaFile, $log, APP_SETTINGS, UtilService, LocalCacheService, LOG_SETTING, $cordovaEmailComposer, Logger, $injector, $timeout) {
        function getFileName(contentDocument) {
            var fileName = contentDocument.Title;
            return !contentDocument.FileExtension || _.endsWith(fileName.toLowerCase(), "." + contentDocument.FileExtension.toLowerCase()) ? fileName : fileName + "." + contentDocument.FileExtension
        }

        function checkFileAndDir(path, entry) {
            var deferred = $q.defer(), result = {isFile: !1, isDir: !1};
            return _.endsWith(path, "/") || (path += "/"), $cordovaFile.checkFile(path, entry).then(function () {
                return result.isFile = !0, deferred.resolve(result)
            }, function () {
                return $cordovaFile.checkDir(path, entry).then(function () {
                    result.isDir = !0, deferred.resolve(result)
                })
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        }

        function listDir(path, filterCondition, getName) {
            var deferred = $q.defer();
            return window.resolveLocalFileSystemURL(path, function (fileSystem) {
                var reader = fileSystem.createReader();
                reader.readEntries(function (entries) {
                    var filterEntries = entries;
                    "F" === filterCondition ? filterEntries = _.filter(entries, {isFile: !0}) : "D" === filterCondition && (filterEntries = _.filter(entries, {isDirectory: !0})), getName ? deferred.resolve(_.pluck(filterEntries, "name")) : deferred.resolve(filterEntries)
                }, function (err) {
                    deferred.reject(err)
                })
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }

        function removeFolders(path, folderNames, currentIndex, deferred) {
            if (currentIndex = void 0 === currentIndex ? 0 : currentIndex, deferred = deferred || $q.defer(), !folderNames || folderNames.length <= currentIndex) deferred.resolve(!0); else {
                var currentFolderName = folderNames[currentIndex] + "";
                currentIndex++, $cordovaFile.removeRecursively(path, currentFolderName).then(function (success) {
                    removeFolders(path, folderNames, currentIndex, deferred)
                }, function (error) {
                    removeFolders(path, folderNames, currentIndex, deferred)
                })
            }
            return deferred.promise
        }

        function removeFiles(path, fileNames, currentIndex, deferred) {
            if (currentIndex = void 0 === currentIndex ? 0 : currentIndex, deferred = deferred || $q.defer(), !fileNames || fileNames.length <= currentIndex) deferred.resolve(!0); else {
                var currentFileName = fileNames[currentIndex] + "";
                currentIndex++, $cordovaFile.removeFile(path, currentFileName).then(function (success) {
                    removeFiles(path, fileNames, currentIndex, deferred)
                }, function (error) {
                    removeFiles(path, fileNames, currentIndex, deferred)
                })
            }
            return deferred.promise
        }

        function getAttachmentFolder() {
            var currentUser = LocalCacheService.get("currentUser"),
                attachmentFolderPath = service.getDataFileDirectory() + currentUser.Id + "/" + attachmentFolderName;
            return attachmentFolderPath
        }

        function checkAttachmentFolder() {
            var deferred = $q.defer();
            if (attachmentFolderIsChecked) deferred.resolve(!0); else {
                var currentUser = LocalCacheService.get("currentUser");
                checkAndCreateDir(service.getDataFileDirectory(), currentUser.Id + "/" + attachmentFolderName).then(function () {
                    attachmentFolderIsChecked = !0, deferred.resolve(!0)
                }, function (error) {
                    deferred.reject("FileService.checkAttachmentFolder error: " + JSON.stringify(error))
                })
            }
            return deferred.promise
        }

        function getFileFolder() {
            var currentUser = LocalCacheService.get("currentUser"),
                fileFolderPath = service.getDataFileDirectory() + currentUser.Id + "/" + fileFolderName;
            return fileFolderPath
        }

        function checkFileFolder() {
            var deferred = $q.defer();
            if (fileFolderIsChecked) deferred.resolve(!0); else {
                var currentUser = LocalCacheService.get("currentUser");
                checkAndCreateDir(service.getDataFileDirectory(), currentUser.Id + "/" + fileFolderName).then(function () {
                    fileFolderIsChecked = !0, deferred.resolve(!0)
                }, function (error) {
                    deferred.reject("FileService.checkFileFolder error: " + JSON.stringify(error))
                })
            }
            return deferred.promise
        }

        function getLogFolder() {
            var currentUser = LocalCacheService.get("currentUser"),
                logFolderPath = service.getDataFileDirectory() + currentUser.Id + "/" + logFolderName;
            return logFolderPath
        }

        function checkLogFolder() {
            var deferred = $q.defer();
            if (logFolderIsChecked) deferred.resolve(!0); else {
                var currentUser = LocalCacheService.get("currentUser");
                checkAndCreateDir(service.getDataFileDirectory(), currentUser.Id + "/" + logFolderName).then(function () {
                    logFolderIsChecked = !0, deferred.resolve(!0)
                }, function (error) {
                    deferred.reject("FileService.checkLogFolder error: " + JSON.stringify(error))
                })
            }
            return deferred.promise
        }

        function readFile(filePath, fileName, returnType) {
            var deferred = $q.defer();
            return returnType = returnType || "base64", "base64" === returnType ? $cordovaFile.readAsDataURL(filePath, fileName).then(function (result) {
                deferred.resolve(result)
            }, function (error) {
                deferred.reject("FileService.readFile error: " + JSON.stringify(error))
            }) : "arrayBuffer" === returnType ? $cordovaFile.readAsArrayBuffer(filePath, fileName).then(function (result) {
                deferred.resolve(result)
            }, function (error) {
                deferred.reject("FileService.readFile error: " + JSON.stringify(error))
            }) : "text" === returnType ? $cordovaFile.readAsText(filePath, fileName).then(function (result) {
                deferred.resolve(result)
            }, function (error) {
                deferred.reject("FileService.readFile error: " + JSON.stringify(error))
            }) : "binaryString" === returnType ? $cordovaFile.readAsBinaryString(filePath, fileName).then(function (result) {
                deferred.resolve(result)
            }, function (error) {
                deferred.reject("FileService.readFile error: " + JSON.stringify(error))
            }) : deferred.reject("FileService.readFile error: unknown return type"), deferred.promise
        }

        function checkAndCreateDir(fileSystem, dirName) {
            var deferred = $q.defer();
            _.endsWith(fileSystem, "/") || (fileSystem += "/");
            var dirlist = dirName.split("/");
            return $cordovaFile.checkDir(fileSystem, dirlist[0]).then(function (success) {
                subCheckAndCreateDir(fileSystem, dirlist).then(function () {
                    deferred.resolve(!0)
                }, function (subErrExisted) {
                    deferred.reject(subErrExisted)
                })
            }, function (err) {
                $cordovaFile.createDir(fileSystem, dirlist[0]).then(function () {
                    subCheckAndCreateDir(fileSystem, dirlist).then(function () {
                        deferred.resolve(!0)
                    }, function (subErrNotExisted) {
                        deferred.reject(subErrNotExisted)
                    })
                }, function (err) {
                    deferred.reject(err)
                })
            }), deferred.promise
        }

        function subCheckAndCreateDir(fileSystem, dirlist) {
            var deferred = $q.defer();
            if (dirlist && dirlist.length > 1) {
                var tempPath = fileSystem + dirlist[0] + "/";
                dirlist = dirlist.splice(1, dirlist.length), checkAndCreateDir(tempPath, dirlist.join("/")).then(function () {
                    deferred.resolve(!0)
                }, function (err) {
                    deferred.reject(err)
                })
            } else deferred.resolve(!0);
            return deferred.promise
        }

        function arrayBuffer2Base64(arrayBuffer) {
            for (var a, b, c, d, chunk, base64 = "", encodings = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bytes = new Uint8Array(arrayBuffer), byteLength = bytes.byteLength, byteRemainder = byteLength % 3, mainLength = byteLength - byteRemainder, i = 0; i < mainLength; i += 3) chunk = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2], a = (16515072 & chunk) >> 18, b = (258048 & chunk) >> 12, c = (4032 & chunk) >> 6, d = 63 & chunk, base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
            return 1 == byteRemainder ? (chunk = bytes[mainLength], a = (252 & chunk) >> 2, b = (3 & chunk) << 4, base64 += encodings[a] + encodings[b] + "==") : 2 == byteRemainder && (chunk = bytes[mainLength] << 8 | bytes[mainLength + 1], a = (64512 & chunk) >> 10, b = (1008 & chunk) >> 4, c = (15 & chunk) << 2, base64 += encodings[a] + encodings[b] + encodings[c] + "="), base64
        }

        function base64toBlob(base64Data, contentType) {
            contentType = contentType || "";
            for (var sliceSize = 1024, byteCharacters = atob(base64Data), bytesLength = byteCharacters.length, slicesCount = Math.ceil(bytesLength / sliceSize), byteArrays = new Array(slicesCount), sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
                for (var begin = sliceIndex * sliceSize, end = Math.min(begin + sliceSize, bytesLength), bytes = new Array(end - begin), offset = begin, i = 0; offset < end; ++i, ++offset) bytes[i] = byteCharacters[offset].charCodeAt(0);
                byteArrays[sliceIndex] = new Uint8Array(bytes)
            }
            return new Blob(byteArrays, {type: contentType})
        }

        function writeLogData(deferred) {
            if (deferred = deferred || $q.defer(), !logFolderIsChecked) return deferred.resolve(), deferred.promise;
            var logFileFolder = getLogFolder() + "/";
            return checkLogFolder().then(function () {
                return !currentWritingLogFileName || $cordovaFile.checkFile(logFileFolder, currentWritingLogFileName).then(function (fileEntry) {
                    return getMetadataFromFileEntry(fileEntry).then(function (file) {
                        return file.size > logFileSize
                    }, function (error) {
                        return !0
                    })
                }, function (error) {
                    return !0
                })
            }).then(function (newFile) {
                if (newFile) {
                    currentWritingLogFileName = logFileNamePrefix + $filter("date")(new Date, logFileNameTimeFormat) + logFileNameSuffix;
                    var logHeaderData = Logger.logToFile.headerInfo;
                    return $cordovaFile.writeFile(logFileFolder, currentWritingLogFileName, logHeaderData, !0).then(function (success) {
                    })
                }
            }).then(function () {
                for (var largeLogData = tmpLogDataQueue.length > 0 ? tmpLogDataQueue.shift() : ""; tmpLogDataQueue.length > 0 && largeLogData.length < logFileWritingBatchSize;) largeLogData += tmpLogDataQueue.shift();
                return $cordovaFile.writeExistingFile(logFileFolder, currentWritingLogFileName, largeLogData)
            }).then(function () {
                tmpLogDataQueue.length >= logFileSecondWritingMinSize ? writeLogData(deferred) : deferred.resolve()
            })["catch"](function (error) {
                $log.debug("Write log data error: " + JSON.stringify(error)), deferred.reject(error)
            }), deferred.promise
        }

        var service = this,
            dataFileRootDirectory = ($injector.get("Exception"), $injector.get("EXCEPTION_SEVERITY"), $injector.get("PROCESS_CODE"), $injector.get("STATUS_CODE"), null),
            attachmentFolderName = "Attachment", attachmentFolderIsChecked = !1, fileFolderName = "File",
            fileFolderIsChecked = !1, logFolderName = "Log", logFolderIsChecked = !1, logFileNamePrefix = "logfile-",
            logFileNameTimeFormat = "yyyy-MM-dd-HH-mm-ss", logFileNameSuffix = ".log", currentWritingLogFileName = null,
            tmpLogDataQueue = [], writingLogTimerRunning = !1,
            logFileSize = LOG_SETTING.LOG_FILE_SIZE ? 1024 * LOG_SETTING.LOG_FILE_SIZE : 5242880,
            logFileWritingBatchSize = LOG_SETTING.LOG_FILE_WRITING_BATCH_SIZE ? 1024 * LOG_SETTING.LOG_FILE_WRITING_BATCH_SIZE : 10240,
            logFileSecondWritingMinSize = 10;
        service.initializeUserFolders = function () {
            var deferred = $q.defer();
            return checkAttachmentFolder().then(function () {
                checkFileFolder().then(function () {
                    service.initializeLogFolder().then(function () {
                        deferred.resolve(!0)
                    }, function (error) {
                        deferred.reject("check and create Log folder failed error:" + error)
                    })
                }, function (error) {
                    deferred.reject("check and create File folder failed error:" + error)
                })
            }, function (error) {
                deferred.reject("check and create Attachment folder failed error:" + error)
            }), deferred.promise
        }, service.saveAttachmentBody = function (attachment, relatedObjectType, body) {
            var deferred = $q.defer(), saveAttachmentBody = function () {
                if ("object" == typeof body) if (relatedObjectType && relatedObjectType.MobileVizArt__Attachments_Encrypted__c) {
                    var attachmentBody = {AttachmentSid: attachment._soupEntryId, Body: arrayBuffer2Base64(body)};
                    navigator.smartstore.upsertSoupEntriesWithExternalId("AttachmentBody", [attachmentBody], "AttachmentSid", function () {
                        deferred.resolve(!0)
                    }, function (err) {
                        deferred.reject("FileService.saveAttachmentBody into soup error: " + JSON.stringify(err))
                    })
                } else checkAttachmentFolder().then(function () {
                    service.removeAttachmentBySids([attachment._soupEntryId]).then(function () {
                        checkAndCreateDir(getAttachmentFolder(), attachment._soupEntryId + "").then(function () {
                            $cordovaFile.writeFile(getAttachmentFolder() + "/" + attachment._soupEntryId, attachment.Name, body, !0).then(function (success) {
                                deferred.resolve(!0)
                            }, function (error) {
                                deferred.reject("FileService.saveAttachmentBody into file system error: " + JSON.stringify(error))
                            })
                        }, function (error) {
                            deferred.reject("FileService.saveAttachmentBody check _soupEntryId folder error: " + JSON.stringify(error))
                        })
                    }, function (error) {
                        deferred.reject("FileService.saveAttachmentBody removeAttachmentBySids error: " + JSON.stringify(error))
                    })
                }, function (error) {
                    deferred.reject("FileService.saveAttachmentBody checkAttachmentFolder error: " + JSON.stringify(error))
                }); else if ("string" == typeof body) if (body.indexOf(";base64,") !== -1 && (body = body.substr(body.indexOf(";base64,") + 8, body.length)), relatedObjectType && relatedObjectType.MobileVizArt__Attachments_Encrypted__c) {
                    var attachmentBody = {AttachmentSid: attachment._soupEntryId, Body: body};
                    navigator.smartstore.upsertSoupEntriesWithExternalId("AttachmentBody", [attachmentBody], "AttachmentSid", function () {
                        deferred.resolve(!0)
                    }, function (err) {
                        deferred.reject("FileService.saveAttachmentBody into soup error: " + JSON.stringify(err))
                    })
                } else checkAttachmentFolder().then(function () {
                    service.removeAttachmentBySids([attachment._soupEntryId]).then(function () {
                        checkAndCreateDir(getAttachmentFolder(), attachment._soupEntryId + "").then(function () {
                            $cordovaFile.writeFile(getAttachmentFolder() + "/" + attachment._soupEntryId, attachment.Name, base64toBlob(body), !0).then(function (success) {
                                deferred.resolve(!0)
                            }, function (error) {
                                deferred.reject("FileService.saveAttachmentBody into file system error: " + JSON.stringify(error))
                            })
                        }, function (error) {
                            deferred.reject("FileService.saveAttachmentBody check _soupEntryId folder error: " + JSON.stringify(error))
                        })
                    }, function (error) {
                        deferred.reject("FileService.saveAttachmentBody removeAttachmentBySids error: " + JSON.stringify(error))
                    })
                }, function (error) {
                    deferred.reject("FileService.saveAttachmentBody checkAttachmentFolder error: " + JSON.stringify(error))
                })
            };
            return attachment.Name ? saveAttachmentBody() : navigator.smartstore.retrieveSoupEntries("Attachment", [attachment._soupEntryId], function (entries) {
                entries && 1 === entries.length ? (attachment = entries[0], saveAttachmentBody()) : deferred.reject("FileService.saveAttachmentBody not found the Attachment record.")
            }, function (error) {
                deferred.reject("FileService.saveAttachmentBody found the Attachment record error: " + JSON.stringify(error))
            }), deferred.promise
        }, service.getAttachmentBody = function (attachment, relatedObjectType) {
            var deferred = $q.defer(), getAttachmentBody = function () {
                if (relatedObjectType && relatedObjectType.MobileVizArt__Attachments_Encrypted__c) {
                    var sql = "select {AttachmentBody:_soup} from {AttachmentBody} where {AttachmentBody:AttachmentSid} = '" + attachment._soupEntryId + "'",
                        querySpec = navigator.smartstore.buildSmartQuerySpec(sql, 1);
                    navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                        if (cursor && cursor.currentPageOrderedEntries && cursor.currentPageOrderedEntries.length) {
                            var result = cursor.currentPageOrderedEntries[0][0];
                            deferred.resolve(result.Body)
                        } else deferred.reject("FileService.getAttachmentBody from soup error: not found in AttachmentBody soup.")
                    }, function (err) {
                        deferred.reject("FileService.getAttachmentBody from soup error: " + JSON.stringify(err))
                    })
                } else $cordovaFile.readAsDataURL(getAttachmentFolder() + "/" + attachment._soupEntryId, attachment.Name).then(function (result) {
                    var dataContent = result.substr(result.indexOf(";base64,") + 8, result.length);
                    deferred.resolve(dataContent)
                }, function (err) {
                    deferred.reject("FileService.getAttachmentBody from local file system error: " + JSON.stringify(err))
                })
            };
            return attachment.Name ? getAttachmentBody() : navigator.smartstore.retrieveSoupEntries("Attachment", [attachment._soupEntryId], function (entries) {
                entries && 1 === entries.length ? (attachment = entries[0], getAttachmentBody()) : deferred.reject("FileService.getAttachmentBody not found the Attachment record.")
            }, function (error) {
                deferred.reject("FileService.getAttachmentBody found the Attachment record error: " + JSON.stringify(error))
            }), deferred.promise
        }, service.saveFileData = function (contentDocument, fileData) {
            var deferred = $q.defer(), saveFileData = function () {
                var binaryData = fileData;
                "string" == typeof fileData && (fileData.indexOf(";base64,") !== -1 && (fileData = fileData.substr(fileData.indexOf(";base64,") + 8, fileData.length)), binaryData = base64toBlob(fileData)), checkFileFolder().then(function () {
                    service.removeFileBySids([contentDocument._soupEntryId]).then(function () {
                        checkAndCreateDir(getFileFolder(), contentDocument._soupEntryId + "").then(function () {
                            $cordovaFile.writeFile(getFileFolder() + "/" + contentDocument._soupEntryId, getFileName(contentDocument), binaryData, !0).then(function (success) {
                                deferred.resolve(!0)
                            }, function (error) {
                                deferred.reject("FileService.saveFileData into file system error: " + JSON.stringify(error))
                            })
                        }, function (error) {
                            deferred.reject("FileService.saveFileData check _soupEntryId folder error: " + JSON.stringify(error))
                        })
                    }, function (error) {
                        deferred.reject("FileService.saveFileData removeFileBySids error: " + JSON.stringify(error))
                    })
                }, function (error) {
                    deferred.reject("FileService.saveFileData checkFileFolder error: " + JSON.stringify(error))
                })
            };
            return contentDocument.Title ? saveFileData() : navigator.smartstore.retrieveSoupEntries("ContentDocument", [contentDocument._soupEntryId], function (entries) {
                entries && 1 === entries.length ? (contentDocument = entries[0], saveFileData()) : deferred.reject("FileService.saveFileData not found the ContentDocument record.")
            }, function (error) {
                deferred.reject("FileService.saveFileData found the ContentDocument record error: " + JSON.stringify(error))
            }), deferred.promise
        }, service.getFileData = function (contentDocument, returnType, base64WithHeader) {
            var deferred = $q.defer(), getFileData = function () {
                returnType = returnType || "base64", readFile(getFileFolder() + "/" + contentDocument._soupEntryId, getFileName(contentDocument), returnType).then(function (result) {
                    "base64" !== returnType || base64WithHeader || (result = result.substr(result.indexOf(";base64,") + 8, result.length)), deferred.resolve(result)
                }, function (err) {
                    deferred.reject("FileService.getFileData from local file system error: " + JSON.stringify(err))
                })
            };
            return contentDocument.Title ? getFileData() : navigator.smartstore.retrieveSoupEntries("ContentDocument", [contentDocument._soupEntryId], function (entries) {
                entries && 1 === entries.length ? (contentDocument = entries[0], getFileData()) : deferred.reject("FileService.getFileData not found the ContentDocument record.")
            }, function (error) {
                deferred.reject("FileService.getFileData found the ContentDocument record error: " + JSON.stringify(error))
            }), deferred.promise
        }, service.getFilePath = function (contentDocumentSid) {
            var deferred = $q.defer();
            return navigator.smartstore.retrieveSoupEntries("ContentDocument", [contentDocumentSid], function (entries) {
                if (entries && 1 === entries.length) {
                    var contentDocument = entries[0];
                    deferred.resolve(getFileFolder() + "/" + contentDocument._soupEntryId + "/" + getFileName(contentDocument))
                } else deferred.reject("FileService.getFilePath not found the ContentDocument record.")
            }, function (error) {
                deferred.reject("FileService.getFilePath found the ContentDocument record error: " + JSON.stringify(error))
            }), deferred.promise
        }, service.getFileSize = function (filePath, fileName) {
            return $q(function (resolve, reject) {
                window.resolveLocalFileSystemURL(filePath, function (fileSystem) {
                    fileSystem.getFile(fileName + "", {create: !1}, function (fileEntry) {
                        fileEntry.getMetadata(function (metadata) {
                            resolve(metadata.size)
                        }, function (error) {
                            reject(error)
                        })
                    }, function (error) {
                        reject(error)
                    })
                }, function (error) {
                    reject(error)
                })
            })
        }, service.getDataFileDirectory = function () {
            return dataFileRootDirectory ? dataFileRootDirectory : dataFileRootDirectory = UtilService.isAndroidOS() ? cordova.file.externalDataDirectory ? cordova.file.externalDataDirectory : cordova.file.dataDirectory : cordova.file.documentsDirectory
        }, service.clearUserFolder = function () {
            var deferred = $q.defer(), currentUser = LocalCacheService.get("currentUser");
            return currentUser ? $cordovaFile.removeRecursively(service.getDataFileDirectory(), currentUser.Id + "").then(function (success) {
                deferred.resolve(!0)
            }, function (error) {
                deferred.reject("FileService.clearUserFolder error: " + JSON.stringify(error))
            }) : deferred.resolve(!0), deferred.promise
        }, service.getAllAttachmentFolderNames = function () {
            var deferred = $q.defer();
            return listDir(getAttachmentFolder(), "D", !0).then(function (folderNames) {
                deferred.resolve(folderNames)
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, service.removeAttachmentBySids = function (attachmentSids) {
            var deferred = $q.defer();
            return removeFolders(getAttachmentFolder(), attachmentSids).then(function () {
                deferred.resolve(!0)
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, service.removeFileBySids = function (contentDocumentSids) {
            var deferred = $q.defer();
            return removeFolders(getFileFolder(), contentDocumentSids).then(function () {
                deferred.resolve(!0)
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, service.changeAttachmentFileName = function (attachmentSid, oldAttachmentName, newAttachmentName) {
            var deferred = $q.defer(), filePath = getAttachmentFolder() + "/" + attachmentSid;
            return $cordovaFile.moveFile(filePath, oldAttachmentName, filePath, newAttachmentName).then(function (success) {
                deferred.resolve(!0)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.changeFileName = function (oldContentDocument, newContentDocument) {
            var deferred = $q.defer(), filePath = getFileFolder() + "/" + oldContentDocument._soupEntryId;
            return $cordovaFile.moveFile(filePath, getFileName(oldContentDocument), filePath, getFileName(newContentDocument)).then(function (success) {
                deferred.resolve(!0)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.zip = function (targetPath, targetEntry, zipPath, zipFileName) {
            var deferred = $q.defer();
            _.endsWith(targetPath, "/") || (targetPath += "/"), _.endsWith(zipPath, "/") || (zipPath += "/");
            var addFileAndDirToZip = function (path, entry, parentDir, zip) {
                var innerDeferred = $q.defer();
                return parentDir = parentDir || "", checkFileAndDir(path, entry).then(function (checkResult) {
                    zip = zip || new JSZip, checkResult.isFile === !0 ? readFile(path, entry, "arrayBuffer").then(function (data) {
                        zip.file(parentDir + "/" + entry, data), innerDeferred.resolve(zip)
                    })["catch"](function (error) {
                        innerDeferred.reject(error)
                    }) : checkResult.isDir === !0 ? listDir(path + entry, null, !0).then(function (subEntries) {
                        var subPromises = [];
                        for (var subEntry in subEntries) subPromises.push(addFileAndDirToZip(path + entry + "/", subEntries[subEntry], parentDir + "/" + entry, zip));
                        $q.all(subPromises).then(function () {
                            innerDeferred.resolve(zip)
                        })["catch"](function (error) {
                            innerDeferred.reject(error)
                        })
                    }) : innerDeferred.reject("Unknown result: " + JSON.stringify(checkResult))
                })["catch"](function (error) {
                    innerDeferred.reject(error)
                }), innerDeferred.promise
            };
            return addFileAndDirToZip(targetPath, targetEntry).then(function (zip) {
                return zip.generateAsync({compression: "DEFLATE", compressionOptions: {level: 9}, type: "blob"})
            }).then(function (blob) {
                return $cordovaFile.writeFile(zipPath, zipFileName, blob, !0)
            }).then(function () {
                deferred.resolve()
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.initializeLogFolder = function () {
            var deferred = $q.defer(), currentUser = LocalCacheService.get("currentUser");
            return currentUser ? (logFolderIsChecked = !1, Logger.enabled ? checkLogFolder().then(function () {
                return cleanLogFolderAndCacheLatest()
            }).then(function () {
                deferred.resolve(!0)
            })["catch"](function (error) {
                deferred.reject(error)
            }) : removeFolders(service.getDataFileDirectory() + currentUser.Id, [logFolderName]).then(function () {
                deferred.resolve(!0)
            }, function (error) {
                deferred.reject(error)
            })) : deferred.reject("InitializeLogFolder error: currentUser is null."), deferred.promise
        };
        var cleanLogFolderAndCacheLatest = function () {
            var deferred = $q.defer(), logFileFolder = getLogFolder() + "/", expiredLogFileNames = [],
                logFileExpiredTime = LOG_SETTING.LOG_FILE_EXPIRED_TIME || 36,
                expiredTime = new Date((new Date).getTime() - 60 * logFileExpiredTime * 60 * 1e3),
                latestFileModifiedTime = null, isExpiredFile = function (fileEntry) {
                    var isExpiredFileDeferred = $q.defer(), fileName = fileEntry.name;
                    return fileName && _.startsWith(fileName, logFileNamePrefix) && _.endsWith(fileName, logFileNameSuffix) ? getMetadataFromFileEntry(fileEntry).then(function (file) {
                        (!latestFileModifiedTime || latestFileModifiedTime < file.modificationTime) && (currentWritingLogFileName = fileName), latestFileModifiedTime = file.modificationTime, file.modificationTime < expiredTime ? (expiredLogFileNames.push(fileName), isExpiredFileDeferred.resolve()) : isExpiredFileDeferred.resolve()
                    }, function (error) {
                        isExpiredFileDeferred.reject(error)
                    }) : isExpiredFileDeferred.resolve(), isExpiredFileDeferred.promise
                };
            return listDir(logFileFolder, "F").then(function (fileEntries) {
                for (var promises = [], i = 0; i < fileEntries.length; i++) promises.push(isExpiredFile(fileEntries[i]));
                return $q.all(promises)
            }).then(function () {
                return removeFiles(logFileFolder, expiredLogFileNames)
            }).then(function () {
                deferred.resolve()
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        service.writeLogDataByBuffer = function (logData) {
            logData && tmpLogDataQueue.push(logData), writingLogTimerRunning || (writingLogTimerRunning = !0, $timeout(function () {
                writeLogData().then(function (success) {
                    writingLogTimerRunning = !1, tmpLogDataQueue.length > 0 && service.writeLogDataByBuffer();
                }, function (error) {
                    writingLogTimerRunning = !1, tmpLogDataQueue.length > 0 && service.writeLogDataByBuffer()
                })
            }, LOG_SETTING.LOG_FILE_WRITING_INTERVAL_TIME))
        };
        var getMetadataFromFileEntry = function (fileEntry) {
            var deferred = $q.defer();
            return fileEntry.getMetadata(function (file) {
                deferred.resolve(file)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        service.sendLogFileByEmail = function () {
            var deferred = $q.defer(), currentUser = LocalCacheService.get("currentUser");
            if (logFolderIsChecked && currentUser) {
                var zipFileName = currentUser.Username + "-log-" + $filter("date")(new Date, logFileNameTimeFormat) + ".zip",
                    userFileFolder = service.getDataFileDirectory() + currentUser.Id + "/";
                return service.zip(userFileFolder, logFolderName, userFileFolder, zipFileName).then(function () {
                    return $cordovaEmailComposer.isAvailable().then(function () {
                        var email = {
                            to: LOG_SETTING.SEND_LOG_FILE_EMAIL_TO,
                            subject: LOG_SETTING.SEND_LOG_FILE_EMAIL_SUBJECT,
                            body: LOG_SETTING.SEND_LOG_FILE_EMAIL_BODY,
                            attachments: userFileFolder + zipFileName
                        };
                        return $cordovaEmailComposer.open(email).then(null, function () {
                            deferred.resolve()
                        })
                    }, function () {
                        deferred.reject({message: "Send log failed, maybe you haven't setting one email account at least in your device."})
                    })
                })["catch"](function (error) {
                    deferred.reject(error)
                })["finally"](function () {
                    return removeFiles(userFileFolder, [zipFileName])
                }), deferred.promise
            }
        }, service.sendLogFileToSalesforce = function () {
            var deferred = $q.defer(), currentUser = LocalCacheService.get("currentUser");
            if (logFolderIsChecked && currentUser) {
                var zipFileName = currentUser.Username + "-log-" + $filter("date")(new Date, logFileNameTimeFormat) + ".zip",
                    userFileFolder = service.getDataFileDirectory() + currentUser.Id + "/",
                    logFileFolder = getLogFolder() + "/",
                    SalesforceDataService = $injector.get("SalesforceDataService");
                service.zip(userFileFolder, logFolderName, userFileFolder, zipFileName).then(function () {
                    return readFile(userFileFolder, zipFileName)
                }).then(function (base64Data) {
                    return base64Data.substr(base64Data.indexOf(";base64,") + 8, base64Data.length)
                }).then(function (contentData) {
                    var networkId = LocalCacheService.get("userInfo").networkId;
                    return SalesforceDataService.createContentVersion(null, contentData, zipFileName, zipFileName, "log file", networkId)
                }).then(function (contentVersionResp) {
                    return SalesforceDataService.fetchFileIdByContentVersionId(contentVersionResp.id)
                }).then(function (fileId) {
                    return LOG_SETTING.LOG_FILE_UPLOAD_ROUTING ? SalesforceDataService.addFileShareMemberByRouting(fileId, "V") : SalesforceDataService.addFileShareMemberByGroupName(fileId, "C", LOG_SETTING.DEFAULT_LOG_FOLDER)
                }).then(function () {
                    return listDir(logFileFolder, "F", !0)
                }).then(function (logFileNames) {
                    return removeFiles(logFileFolder, logFileNames)
                }).then(function () {
                    deferred.resolve()
                })["catch"](function (error) {
                    deferred.reject(error)
                })["finally"](function () {
                    return removeFiles(userFileFolder, [zipFileName])
                })
            }
            return deferred.promise
        }, service.checkLogFolderEmpty = function () {
            var deferred = $q.defer();
            return listDir(getLogFolder(), "F", !0).then(function (logFileNames) {
                logFileNames && logFileNames.length > 0 ? deferred.resolve(!0) : deferred.resolve(!1)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.rewriteI18NData = function (prefixFileName, i18nJsonData) {
            var deferred = $q.defer(), currentUser = LocalCacheService.get("currentUser"),
                languageLocaleKey = currentUser.LanguageLocaleKey, i18nDir = "i18n",
                i18nFilePath = i18nDir + "/" + prefixFileName + languageLocaleKey + ".json";
            return checkAndCreateDir(cordova.file.dataDirectory, i18nDir).then(function () {
                return $cordovaFile.writeFile(cordova.file.dataDirectory, i18nFilePath, JSON.stringify(i18nJsonData), !0)
            }).then(function (success) {
                deferred.resolve(!0)
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        }
    }])
}(angular, _), function (angular) {
    "use strict";
    angular.module("oinio.core").service("ForceClientService", function () {
        var forceClient, service = this;
        service.setForceClient = function (instance) {
            forceClient = instance
        }, service.getForceClient = function () {
            return forceClient
        }
    })
}(angular), function (angular) {
    "use strict";
    angular.module("oinio.core").service("LightningOutService", ["$q", "$http", "ForceClientService", "angularLoad", "ConnectionMonitor", "SalesforceLoginService", function ($q, $http, ForceClientService, angularLoad, ConnectionMonitor, SalesforceLoginService) {
        var service = this;
        service.createComponent = function (appName, componentName, attributes, domLocator) {
            var deferred = $q.defer();
            return ConnectionMonitor.isOnline() ? (SalesforceLoginService.webLogin().then(function () {
                var lightningEndPointURI = ForceClientService.getForceClient().instanceUrl.split(".")[0] + ".lightning.force.com",
                    sessionToken = ForceClientService.getForceClient().sessionId;
                if (void 0 !== window.$Lightning) _createComponent($Lightning, appName, componentName, attributes, domLocator, lightningEndPointURI, sessionToken, function (cmp) {
                    deferred.resolve(cmp)
                }, function (err) {
                    deferred.reject(err)
                }); else {
                    var lightningOutScriptUrl = ForceClientService.getForceClient().instanceUrl + "/lightning/lightning.out.js";
                    angularLoad.loadScript(lightningOutScriptUrl).then(function () {
                        _createComponent($Lightning, appName, componentName, attributes, domLocator, lightningEndPointURI, sessionToken, function (cmp) {
                            deferred.resolve(cmp)
                        }, function (err) {
                            deferred.reject(err)
                        })
                    })["catch"](function () {
                        deferred.reject("failed to load lightning.out.js from " + lightningOutScriptUrl)
                    })
                }
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise) : (deferred.reject("Cannot connect to the internet, Lightning Component only works for when device is online."), deferred.promise)
        };
        var _createComponent = function ($Lightning, appName, componentName, attributes, domLocator, lightningEndPointURI, sessionToken, success, error) {
            try {
                $Lightning.use(appName, function () {
                    $Lightning.createComponent(componentName, attributes, domLocator, function (cmp) {
                        success && success(cmp)
                    })
                }, lightningEndPointURI, sessionToken)
            } catch (err) {
                error && error("failed to create component: " + JSON.stringify(err))
            }
        }
    }])
}(angular), function (angular) {
    "use strict";
    angular.module("oinio.core").service("LocalCacheService", function () {
        var service = this;
        service.data = {description: "This object is cache! Don't delete this description!"}, service.set = function (key, value) {
            void 0 === key || (void 0 === value ? service.data[key] = {} : service.data[key] = value)
        }, service.get = function (key) {
            if (void 0 !== key) return service.data[key]
        }, service.del = function (key) {
            return "description" !== key && void 0 !== key && void delete service.data[key]
        }, service.empty = function () {
            service.data = {description: "This object is cache! don't delete this description!!!"}
        }, service.all = function () {
            return service.data
        }
    })
}(angular), function (angular, _) {
    "use strict";
    angular.module("oinio.core").service("LocalDataService", ["$q", "$http", "$filter", "$log", "SMARTSTORE_COMMON_SETTING", "APP_SETTINGS", "LocalCacheService", "PicklistService", "DescribeService", "ConnectionMonitor", "FileService", "MetaService", "UtilService", "$injector", function ($q, $http, $filter, $log, SMARTSTORE_COMMON_SETTING, APP_SETTINGS, LocalCacheService, PicklistService, DescribeService, ConnectionMonitor, FileService, MetaService, UtilService, $injector) {
        function additionDoneForFile(records) {
            return $q(function (resolve, reject) {
                var upsertContentDocument = function (index) {
                    if (index >= records.length) resolve(); else {
                        var contentVersion = records[index],
                            contentDocumentSid = contentVersion["ContentDocumentId" + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_EXTENSION_SUFFIX];
                        contentDocumentSid ? navigator.smartstore.retrieveSoupEntries("ContentDocument", [contentDocumentSid], function (entries) {
                            if (entries && 1 === entries.length) {
                                var contentDocument = entries[0];
                                overwriteExistPropertyValue(contentDocument, contentVersion), navigator.smartstore.upsertSoupEntries("ContentDocument", [contentDocument], function () {
                                    upsertContentDocument(index + 1)
                                }, function (error) {
                                    reject(error)
                                })
                            } else reject("LocalDataService.additionDoneForFile error: can not get correct ContentDocument of _soupEntryId " + contentDocumentSid)
                        }, function (error) {
                            reject(error)
                        }) : service.createSObject("ContentDocument").then(function (contentDocument) {
                            overwriteExistPropertyValue(contentDocument, contentVersion), navigator.smartstore.upsertSoupEntries("ContentDocument", [contentDocument], function (insertedContentDocument) {
                                contentVersion["ContentDocumentId" + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_EXTENSION_SUFFIX] = insertedContentDocument[0]._soupEntryId, navigator.smartstore.upsertSoupEntries("ContentVersion", [contentVersion], function () {
                                    upsertContentDocument(index + 1)
                                }, function (error) {
                                    reject(error)
                                })
                            }, function (error) {
                                reject(error)
                            })
                        }, function (error) {
                            reject(error)
                        })
                    }
                };
                upsertContentDocument(0)
            })
        }

        function overwriteExistPropertyValue(object, source, skipProperties) {
            skipProperties = skipProperties || ["Id", "_soupEntryId", "IsDeleted"];
            for (var fieldsInSource = _.keys(source), fields = _.keys(object), i = 0; i < fields.length; i++) {
                var fieldName = fields[i];
                fieldsInSource.indexOf(fieldName) !== -1 && skipProperties.indexOf(fieldName) === -1 && (object[fieldName] = source[fieldName])
            }
        }

        function readLookupConfig() {
            var deferred = $q.defer();
            return $http.get("app/common/configuration/lookupfilter.json").success(function (response) {
                _lookupconfig = response.objects, deferred.resolve(_lookupconfig)
            }).error(function (error, status) {
                deferred.reject("Error in function readLookupConfig(): " + JSON.stringify({
                    message: error,
                    status: status
                }))
            }), deferred.promise
        }

        function getLookupConfig(objectType) {
            for (var tempLookupConfig = [], i = 0; i < _lookupconfig.length; i++) if (_lookupconfig[i].Name == objectType) for (var j = 0; j < _lookupconfig[i].lookupfilter.length; j++) tempLookupConfig.push(_lookupconfig[i].lookupfilter[j]);
            return tempLookupConfig
        }

        var _user, _configurationObjects, service = this, Exception = $injector.get("Exception"),
            EXCEPTION_SEVERITY = $injector.get("EXCEPTION_SEVERITY"),
            fieldInformationsCache = ($injector.get("PROCESS_CODE"), $injector.get("STATUS_CODE"), {}),
            skipCreateSObjects = ["ContentDocument"], skipUpdateSObjects = [], skipDeleteSObjects = ["ContentVersion"],
            _getCurrentUser = function () {
                return $q(function (resolve, reject) {
                    if (_user) resolve(_user); else {
                        var currentUser = LocalCacheService.get("currentUser");
                        service.getEntryByExactMatch("User", "Id", currentUser.Id).then(function (user) {
                            _user = user, resolve(_user)
                        }, reject)
                    }
                })
            }, _getRecordTypeByDeveloperName = function (objectName, recordTypeDeveloperName) {
                return $q(function (resolve, reject) {
                    if (objectName) {
                        var smartstoreSmartQueryHandler = function (objectName, queryPath, queryByValue) {
                            var deferred = $q.defer(), sql = "select {RecordType:_soup} from {RecordType}";
                            sql += " where {RecordType:SobjectType} = '" + objectName + "' and {RecordType:" + queryPath + "} = '" + queryByValue + "'";
                            var querySpec = navigator.smartstore.buildSmartQuerySpec(sql, 1);
                            return navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                                var result = null;
                                cursor && cursor.currentPageOrderedEntries && cursor.currentPageOrderedEntries.length && (result = cursor.currentPageOrderedEntries[0][0]), deferred.resolve(result)
                            }, function (err) {
                                deferred.reject("LocalDataService._getRecordTypeByDeveloperName query record type error: " + JSON.stringify(err))
                            }), deferred.promise
                        };
                        recordTypeDeveloperName ? smartstoreSmartQueryHandler(objectName, "DeveloperName", recordTypeDeveloperName).then(resolve, reject) : DescribeService.getDescribeSObject(objectName).then(function (objectDescribeResult) {
                            if (objectDescribeResult && objectDescribeResult.recordTypeInfos && objectDescribeResult.recordTypeInfos.length) {
                                var defaultRecordTypeId = _.findWhere(objectDescribeResult.recordTypeInfos, {defaultRecordTypeMapping: !0}).recordTypeId;
                                smartstoreSmartQueryHandler(objectName, "Id", defaultRecordTypeId).then(resolve, reject)
                            } else resolve(null)
                        }, function (err) {
                            err && resolve(null)
                        })
                    } else reject("LocalDataService._getRecordTypeByDeveloperName Error: missing parameters.")
                })
            };
        service.createSObject = function (objectType, recordType) {
            return $q(function (resolve, reject) {
                if (!objectType) return reject("Invalid parameters: objectType is missing.");
                var newSObjectRecord = {};
                _getCurrentUser().then(function (currentUser) {
                    currentUser ? _getRecordTypeByDeveloperName(objectType, recordType).then(function (recordTypeEntry) {
                        var recordTypeDeveloperName = "";
                        recordTypeEntry && (recordTypeDeveloperName = recordTypeEntry.DeveloperName), __resolveObjectFieldDefaultValue(objectType, recordTypeDeveloperName, newSObjectRecord).then(function (resolvedObject) {
                            resolvedObject.IsDeleted = !1;
                            var userInfo = {
                                Id: currentUser.Id,
                                Name: currentUser.Name,
                                _soupEntryId: currentUser._soupEntryId
                            };
                            resolvedObject.OwnerId = currentUser.Id, resolvedObject.OwnerId_sid = currentUser._soupEntryId, resolvedObject.OwnerId_type = "User", resolvedObject.Owner = userInfo, resolvedObject.LastModifiedById = currentUser.Id, resolvedObject.LastModifiedById_sid = currentUser._soupEntryId, resolvedObject.LastModifiedById_type = "User", resolvedObject.LastModifiedBy = userInfo, resolvedObject.CreatedById = currentUser.Id, resolvedObject.CreatedById_sid = currentUser._soupEntryId, resolvedObject.CreatedById_type = "User", resolvedObject.CreatedBy = userInfo, resolvedObject.attributes = {type: objectType}, recordTypeEntry && (resolvedObject.RecordTypeId = recordTypeEntry.Id, resolvedObject["RecordTypeId" + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_EXTENSION_SUFFIX] = recordTypeEntry._soupEntryId, resolvedObject["RecordTypeId" + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_TYPE_SUFFIX] = "RecordType", resolvedObject.RecordType = {
                                Id: recordTypeEntry.Id,
                                _soupEntryId: recordTypeEntry._soupEntryId,
                                Name: recordTypeEntry.Name,
                                DeveloperName: recordTypeDeveloperName
                            }), resolve(resolvedObject)
                        }, reject)
                    }, reject) : reject("Failed to load current user Information.")
                }, reject)
            })
        }, service.getSObject = function (objectType, _soupEntryId) {
            var deferred = $q.defer();
            return objectType && _soupEntryId ? service.getEntryByExactMatch(objectType, "_soupEntryId", _soupEntryId).then(function (localEntry) {
                localEntry ? _mountSObjectReferenceEntities(objectType, null, [localEntry]).then(function (mountedEntries) {
                    deferred.resolve(mountedEntries[0])
                }, function (err) {
                    deferred.reject(err)
                }) : deferred.reject("No record with entry id: " + _soupEntryId + " found in soup: " + objectType)
            }, function (err) {
                deferred.reject(err)
            }) : deferred.reject("Invalid parameters, missing objectType or _soupEntryId"), deferred.promise
        }, service.getSObjects = function (objectType, sids) {
            var deferred = $q.defer(), results = [], getNextSObject = function (index) {
                index >= sids.length ? deferred.resolve(results) : service.getSObject(objectType, sids[index]).then(function (result) {
                    results.push(result), getNextSObject(++index)
                }, function (error) {
                    deferred.reject(error)
                })
            };
            return getNextSObject(0), deferred.promise
        }, service.saveSObjects = function (objectType, sobjects) {
            return $q(function (resolve, reject) {
                objectType && null !== sobjects ? 0 === sobjects.length ? resolve([]) : skipCreateSObjects.indexOf(objectType) !== -1 ? resolve("LocalDataService.saveSObjects Error: This SObject can not be allowed to create.") : _filterUnconfiguredFieldValues(objectType, sobjects).then(function (filteredSobjects) {
                    service.handleCRUDAction(objectType, filteredSobjects, SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_INSERT).then(function (insertedRecords) {
                        var result = [];
                        angular.forEach(insertedRecords, function (insertedRecord) {
                            result.push({_soupEntryId: insertedRecord._soupEntryId, errors: [], success: !0})
                        }), "ContentVersion" === objectType ? additionDoneForFile(insertedRecords).then(function () {
                            resolve(result)
                        }, reject) : resolve(result)
                    }, reject)
                }, reject) : reject("LocalDataService.saveSObjects Error: Invalid parameters.")
            })
        }, service.updateSObjects = function (objectType, sobjects) {
            return $q(function (resolve, reject) {
                objectType && null !== sobjects ? 0 === sobjects.length ? resolve([]) : skipUpdateSObjects.indexOf(objectType) !== -1 ? resolve("LocalDataService.updateSObjects Error: This SObject can not be allowed to update.") : _filterUnconfiguredFieldValues(objectType, sobjects).then(function (filteredSobjects) {
                    var soupEntryIdRrecordMap = {}, involvedSoupEntryIds = [];
                    angular.forEach(filteredSobjects, function (filteredRecord) {
                        var soupEntryId = filteredRecord._soupEntryId;
                        soupEntryId && (soupEntryIdRrecordMap[soupEntryId] = filteredRecord, involvedSoupEntryIds.indexOf(soupEntryId) === -1 && involvedSoupEntryIds.push(soupEntryId))
                    }), navigator.smartstore.retrieveSoupEntries(objectType, involvedSoupEntryIds, function (entries) {
                        var records2update = [];
                        entries && entries.length && angular.forEach(entries, function (entry) {
                            var updateRecord = _.extend(entry, soupEntryIdRrecordMap[entry._soupEntryId]);
                            records2update.push(updateRecord)
                        }), service.handleCRUDAction(objectType, records2update, SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_UPDATE).then(function (updatedRecords) {
                            var result = [];
                            angular.forEach(updatedRecords, function (updatedRecord) {
                                result.push({_soupEntryId: updatedRecord._soupEntryId, errors: [], success: !0})
                            }), resolve(result)
                        }, reject)
                    }, reject)
                }, reject) : reject("LocalDataService.updateSObjects Error: Invalid parameters.")
            })
        }, service.deleteSObjects = function (objectType, sobjects) {
            return $q(function (resolve, reject) {
                if (objectType && null !== sobjects) if (0 === sobjects.length) resolve([]); else if (skipDeleteSObjects.indexOf(objectType) !== -1) resolve("LocalDataService.deleteSObjects Error: This SObject can not be allowed to delete."); else {
                    var entryIds = [];
                    angular.forEach(sobjects, function (record) {
                        entryIds.push(record._soupEntryId)
                    }), navigator.smartstore.retrieveSoupEntries(objectType, entryIds, function (entries) {
                        service.handleCRUDAction(objectType, entries, SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_DELETE).then(function (deletedRecords) {
                            var result = [];
                            angular.forEach(deletedRecords, function (deletedRecord) {
                                result.push({_soupEntryId: deletedRecord._soupEntryId, errors: [], success: !0})
                            }), resolve(result)
                        }, reject)
                    }, reject)
                } else reject("LocalDataService.deleteSObjects Error: Invalid parameters.")
            })
        }, service.createFile = function (param) {
            var deferred = $q.defer(), _suffix = SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_EXTENSION_SUFFIX,
                fileName = param.fileName || "", fileNameInSalesforce = param.fileNameInSalesforce || fileName,
                fileDescription = param.fileDescription || "", fileData = param.fileData,
                targetObjectType = param.targetObjectType, targetId = param.targetId,
                targetSoupEntryId = param.targetSoupEntryId, userInfo = LocalCacheService.get("userInfo");
            return service.createSObject("ContentVersion").then(function (contentVersion) {
                contentVersion.Title = fileNameInSalesforce, contentVersion.PathOnClient = fileName, contentVersion.Description = fileDescription, contentVersion.VersionNumber = "1", contentVersion.NetworkId = userInfo.networkId, service.saveSObjects("ContentVersion", [contentVersion]).then(function (result) {
                    navigator.smartstore.retrieveSoupEntries("ContentVersion", [result[0]._soupEntryId], function (entries) {
                        var insertedContentVersion = entries[0];
                        FileService.saveFileData({_soupEntryId: insertedContentVersion["ContentDocumentId" + _suffix]}, fileData).then(function () {
                            targetObjectType && targetSoupEntryId || targetId ? service.createSObject("ContentDocumentLink").then(function (contentDocumentLink) {
                                contentDocumentLink["ContentDocumentId" + _suffix] = insertedContentVersion["ContentDocumentId" + _suffix], contentDocumentLink.LinkedEntityId = targetId, contentDocumentLink["LinkedEntityId" + _suffix] = targetSoupEntryId, contentDocumentLink["LinkedEntityId" + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_TYPE_SUFFIX] = targetObjectType, contentDocumentLink.ShareType = "V", contentDocumentLink.Visibility = "AllUsers", service.saveSObjects("ContentDocumentLink", [contentDocumentLink]).then(function () {
                                    deferred.resolve(insertedContentVersion["ContentDocumentId" + _suffix])
                                }, function (error) {
                                    deferred.reject("LocalDataService.createFile error: " + JSON.stringify(error))
                                })
                            }, function (error) {
                                deferred.reject(error)
                            }) : deferred.resolve(insertedContentVersion["ContentDocumentId" + _suffix])
                        }, function (error) {
                            deferred.reject("LocalDataService.createFile error: " + JSON.stringify(error))
                        })
                    }, function (error) {
                        deferred.reject("LocalDataService.createFile error: " + JSON.stringify(error))
                    })
                }, function (error) {
                    deferred.reject("LocalDataService.createFile error: " + JSON.stringify(error))
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.updateFileWithNewVersion = function (param) {
            var deferred = $q.defer(), _suffix = SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_EXTENSION_SUFFIX,
                fileName = param.fileName || "", fileNameInSalesforce = param.fileNameInSalesforce || fileName,
                fileDescription = param.fileDescription || "", fileData = param.fileData,
                contentDocumentSid = param.contentDocumentSid,
                updateContentDocumentAndFile = function (contentVersion) {
                    navigator.smartstore.retrieveSoupEntries("ContentDocument", [contentDocumentSid], function (entries) {
                        var contentDocument = entries[0];
                        overwriteExistPropertyValue(contentDocument, contentVersion), navigator.smartstore.upsertSoupEntries("ContentDocument", [contentDocument], function () {
                            FileService.saveFileData(contentDocument, fileData).then(function () {
                                deferred.resolve(!0)
                            }, function (error) {
                                deferred.reject("LocalDataService.updateFileWithNewVersion error: " + JSON.stringify(error))
                            })
                        }, function (error) {
                            deferred.reject("LocalDataService.updateFileWithNewVersion error: " + JSON.stringify(error))
                        })
                    }, function (error) {
                        deferred.reject("LocalDataService.updateFileWithNewVersion error: " + JSON.stringify(error))
                    })
                },
                querySpec = navigator.smartstore.buildExactQuerySpec("ContentDocumentId" + _suffix, contentDocumentSid, 1, "descending", "VersionNumber");
            return navigator.smartstore.querySoup("ContentVersion", querySpec, function (cursor) {
                if (cursor && cursor.currentPageOrderedEntries && 1 === cursor.currentPageOrderedEntries.length) {
                    var latestContentVersion = cursor.currentPageOrderedEntries[0];
                    latestContentVersion.Id ? service.createSObject("ContentVersion").then(function (contentVersion) {
                        contentVersion.Title = fileNameInSalesforce, contentVersion.PathOnClient = fileName, contentVersion.Description = fileDescription, contentVersion.VersionNumber = parseInt(latestContentVersion.VersionNumber) + 1 + "", contentVersion.ContentDocumentId = latestContentVersion.ContentDocumentId, contentVersion["ContentDocumentId" + _suffix] = contentDocumentSid, service.saveSObjects("ContentVersion", [contentVersion]).then(function (result) {
                            updateContentDocumentAndFile(contentVersion)
                        }, function (error) {
                            deferred.reject("LocalDataService.updateFileWithNewVersion error: " + JSON.stringify(error))
                        })
                    }, function (error) {
                        deferred.reject(error)
                    }) : (latestContentVersion.Title = fileNameInSalesforce, latestContentVersion.PathOnClient = fileName, latestContentVersion.Description = fileDescription, navigator.smartstore.upsertSoupEntries("ContentVersion", [latestContentVersion], function () {
                        updateContentDocumentAndFile(latestContentVersion)
                    }, function (error) {
                        deferred.reject("LocalDataService.updateFileWithNewVersion error: " + JSON.stringify(error))
                    }))
                } else deferred.reject("LocalDataService.updateFileWithNewVersion error: not found the latest contentVersion record.")
            }), deferred.promise
        }, service.deleteFile = function (contentDocumentSid) {
            var deferred = $q.defer(), _suffix = SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_EXTENSION_SUFFIX;
            return service.deleteSObjects("ContentDocument", [{_soupEntryId: contentDocumentSid}]).then(function () {
                var querySpec = navigator.smartstore.buildExactQuerySpec("ContentDocumentId" + _suffix, contentDocumentSid, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
                navigator.smartstore.querySoup("ContentVersion", querySpec, function (cursor) {
                    var contentVersionIds = _.pluck(cursor.currentPageOrderedEntries, "_soupEntryId");
                    navigator.smartstore.removeFromSoup("ContentVersion", contentVersionIds, function () {
                        navigator.smartstore.querySoup("ContentDocumentLink", querySpec, function (cursor2) {
                            var contentDocumentLinkIds = _.pluck(cursor2.currentPageOrderedEntries, "_soupEntryId");
                            navigator.smartstore.removeFromSoup("ContentDocumentLink", contentDocumentLinkIds, function () {
                                FileService.removeFileBySids([contentDocumentSid]).then(function () {
                                    deferred.resolve(!0)
                                }, function (error) {
                                    deferred.reject("LocalDataService.deleteFile error: " + JSON.stringify(error))
                                })
                            })
                        })
                    })
                })
            }, function (error) {
                deferred.reject("LocalDataService.deleteFile error: " + JSON.stringify(error))
            }), deferred.promise
        }, service.createAttachment = function (param) {
            var deferred = $q.defer(), fileName = param.fileName || "", description = param.description,
                body = param.body, contentType = param.contentType, parentObjectType = param.parentObjectType,
                parentId = param.parentId, parentSoupEntryId = param.parentSoupEntryId;
            return service.createSObject("Attachment").then(function (attachment) {
                attachment.Name = fileName, attachment.Description = description, attachment.ContentType = contentType, attachment["ParentId" + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_TYPE_SUFFIX] = parentObjectType, attachment.ParentId = parentId, attachment["ParentId" + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_EXTENSION_SUFFIX] = parentSoupEntryId, service.saveSObjects("Attachment", [attachment]).then(function (result) {
                    navigator.smartstore.retrieveSoupEntries("Attachment", [result[0]._soupEntryId], function (entries) {
                        var insertedAttachment = entries[0];
                        service.queryConfiguredObjectByName(parentObjectType).then(function (relatedObjectType) {
                            FileService.saveAttachmentBody(insertedAttachment, relatedObjectType, body).then(function () {
                                deferred.resolve(insertedAttachment._soupEntryId)
                            }, function (error) {
                                deferred.reject("LocalDataService.createAttachment error: " + JSON.stringify(error))
                            })
                        }, function (error) {
                            deferred.reject("LocalDataService.createAttachment error: " + JSON.stringify(error))
                        })
                    }, function (error) {
                        deferred.reject("LocalDataService.createAttachment error: " + JSON.stringify(error))
                    })
                }, function (error) {
                    deferred.reject("LocalDataService.createAttachment error: " + JSON.stringify(error))
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.deleteAttachment = function (attachmentSid) {
            var deferred = $q.defer();
            return navigator.smartstore.retrieveSoupEntries("Attachment", [attachmentSid], function (entries) {
                if (entries.length > 0) {
                    var attachment = entries[0];
                    service.deleteSObjects("Attachment", [attachment]).then(function () {
                        service.queryConfiguredObjectByName(attachment.ParentId_type).then(function (parentObjectType) {
                            parentObjectType.MobileVizArt__Attachments_Encrypted__c ? service.getAllRecordsSidBySoup("AttachmentBody", "{AttachmentBody:AttachmentSid} = " + attachmentSid).then(function (attachmentBodySidArray) {
                                navigator.smartstore.removeFromSoup("AttachmentBody", attachmentBodySidArray, function () {
                                    deferred.resolve(!0)
                                }, function (error) {
                                    deferred.reject("LocalDataService.deleteAttachment error: " + JSON.stringify(error))
                                })
                            }, function (error) {
                                deferred.reject("LocalDataService.deleteAttachment error: " + JSON.stringify(error))
                            }) : FileService.removeAttachmentBySids([attachmentSid]).then(function () {
                                deferred.resolve(!0)
                            }, function (error) {
                                deferred.reject("LocalDataService.deleteAttachment error: " + JSON.stringify(error))
                            })
                        }, function (error) {
                            deferred.reject("LocalDataService.deleteAttachment error: " + JSON.stringify(error))
                        })
                    }, function (error) {
                        deferred.reject("LocalDataService.deleteAttachment error: " + JSON.stringify(error))
                    })
                } else deferred.resolve(!0)
            }), deferred.promise
        }, service.handleCRUDAction = function (objectType, records, action, isLocalAction) {
            return $q(function (resolve, reject) {
                var actions = [SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_INSERT, SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_UPDATE, SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_DELETE];
                if (objectType && records && records.length && action && actions.indexOf(action) !== -1) {
                    if (action === SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_DELETE) {
                        var records2remove = [], records2updateIsDeleted = [];
                        angular.forEach(records, function (record) {
                            record.Id ? (record.IsDeleted = !0, records2updateIsDeleted.push(record)) : records2remove.push(record._soupEntryId)
                        }), navigator.smartstore.removeFromSoup(objectType, records2remove, function () {
                            navigator.smartstore.upsertSoupEntries(objectType, records2updateIsDeleted, function (upsertedRecords) {
                                isLocalAction ? resolve(upsertedRecords) : _handleQueueAction(objectType, records, action).then(function (handledResult) {
                                    resolve(upsertedRecords)
                                }, reject)
                            }, reject)
                        }, reject)
                    } else navigator.smartstore.upsertSoupEntries(objectType, records, function (upsertedRecords) {
                        isLocalAction ? resolve(upsertedRecords) : _handleQueueAction(objectType, upsertedRecords, action).then(function (handledResult) {
                            resolve(upsertedRecords)
                        }, reject)
                    }, reject)
                } else reject("LocalDataService.handleCRUDAction Error: Invalid parameters.")
            })
        }, service.globalSearch = function (objectType, searchTerm, limitSize, orderBy, direction, filterConfig) {
            return $q(function (resolve, reject) {
                orderBy && !direction && (direction = "ASC"), objectType ? _getObjectConfiguredFields(objectType).then(function (configuredFields) {
                    var sql = "SELECT {" + objectType + ":_soup} FROM {" + objectType + "}", whereSql = " WHERE 1=1 ";
                    configuredFields.configuredFields && configuredFields.configuredFields.indexOf("IsDeleted") !== -1 && (whereSql += "AND {" + objectType + ":IsDeleted} = 0"), "Lead" === objectType && (whereSql += " AND {" + objectType + ":IsConverted} = 0");
                    var searchableFields = configuredFields ? configuredFields.searchableFields : [];
                    if (searchableFields.length && searchTerm && searchTerm.length) {
                        whereSql += " AND (";
                        for (var i = 0; i < searchableFields.length; i++) {
                            var searchableField = searchableFields[i].trim();
                            searchableField && (whereSql += " {" + objectType + ":" + searchableField + "} like '%" + searchTerm + "%' OR ")
                        }
                        whereSql = whereSql.substring(0, whereSql.length - 3), whereSql += ")"
                    }
                    filterConfig && (whereSql += filterConfig), sql += whereSql, orderBy && searchableFields.indexOf(orderBy) !== -1 && (sql += " ORDER BY {" + objectType + ":" + orderBy + "} " + direction), limitSize && (sql += " LIMIT " + limitSize);
                    var querySpec = navigator.smartstore.buildSmartQuerySpec(sql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
                    navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                        var queryResult = [];
                        if (cursor && cursor.currentPageOrderedEntries && cursor.currentPageOrderedEntries.length && angular.forEach(cursor.currentPageOrderedEntries, function (item) {
                            queryResult.push(item[0])
                        }), queryResult.length) {
                            var contentListFields = configuredFields ? configuredFields.listFields : [],
                                referenceFields = [], refer2EntityFieldNames2Load = {};
                            angular.forEach(contentListFields, function (contentListField) {
                                if (contentListField.indexOf(".") > -1 && 2 === contentListField.split(".").length) {
                                    var referenceField = contentListField.split(".")[0].trim();
                                    _.endsWith(referenceField, "__r") ? referenceField = referenceField.substring(0, referenceField.length - 1) + "c" : referenceField += "Id", referenceFields.indexOf(referenceField) === -1 && referenceFields.push(referenceField), refer2EntityFieldNames2Load[referenceField] || (refer2EntityFieldNames2Load[referenceField] = []), refer2EntityFieldNames2Load[referenceField].push(contentListField.split(".")[1].trim())
                                }
                            }), _mountSObjectReferenceEntities(objectType, referenceFields, queryResult, refer2EntityFieldNames2Load).then(function (mountedEntries) {
                                service.getFieldInformations(objectType).then(function (fields) {
                                    var referenceFieldName2referenceObjectNameMap = {};
                                    angular.forEach(fields, function (field) {
                                        "reference" === field.type && field.referenceTo.length && (referenceFieldName2referenceObjectNameMap[field.name] = field.referenceTo[0])
                                    }), angular.forEach(mountedEntries, function (mountedEntry) {
                                        mountedEntry._listFields = [], angular.forEach(contentListFields, function (contentListField) {
                                            contentListField = contentListField.trim();
                                            var listFieldEntity = {};
                                            if (contentListField.indexOf(".") > -1 && 2 === contentListField.split(".").length) {
                                                var referenceFieldEntityName = contentListField.split(".")[0].trim(),
                                                    referenceField = contentListField.split(".")[1].trim(),
                                                    referenceFieldName = contentListField.split(".")[0].trim();
                                                _.endsWith(referenceFieldEntityName, "__r") ? (referenceFieldEntityName = referenceFieldEntityName.substring(0, referenceFieldEntityName.length - 1) + "c", referenceFieldName = angular.copy(referenceFieldEntityName)) : referenceFieldName += "Id", mountedEntry[referenceFieldEntityName] && (listFieldEntity.value = mountedEntry[referenceFieldEntityName][referenceField], listFieldEntity.fieldTranslateKey = objectType + "." + referenceFieldName, listFieldEntity.refer2FieldTranslateKey = referenceFieldName2referenceObjectNameMap[referenceFieldName] + "." + referenceField)
                                            } else listFieldEntity.value = mountedEntry[contentListField], listFieldEntity.fieldTranslateKey = objectType + "." + contentListField;
                                            mountedEntry._listFields.push(listFieldEntity)
                                        })
                                    }), resolve(mountedEntries)
                                }, reject)
                            }, reject)
                        } else resolve([])
                    }, function (err) {
                        reject(err)
                    })
                }, reject) : reject("LocalDataService.globalSearch error: object type is required.")
            })
        };
        var _getObjectConfiguredFields = function (objectName) {
            return $q(function (resolve, reject) {
                if (objectName) {
                    var result = {searchableFields: [], listFields: [], configuredFields: []};
                    _resolveObjectNameOrSubjectField(objectName).then(function (nameOrSubject) {
                        result.searchableFields = nameOrSubject ? [nameOrSubject] : [], service.queryConfiguredObjectByName(objectName).then(function (objectConfiguration) {
                            objectConfiguration && (objectConfiguration.MobileVizArt__Fields__c && objectConfiguration.MobileVizArt__Fields__c.trim().length && angular.forEach(objectConfiguration.MobileVizArt__Fields__c.split(","), function (configuredFieldName) {
                                configuredFieldName = configuredFieldName.trim(), result.configuredFields.indexOf(configuredFieldName) === -1 && result.configuredFields.push(configuredFieldName)
                            }), objectConfiguration.MobileVizArt__Search_Fields__c && objectConfiguration.MobileVizArt__Search_Fields__c.trim().length && angular.forEach(objectConfiguration.MobileVizArt__Search_Fields__c.split(","), function (searchableFieldName) {
                                searchableFieldName = searchableFieldName.trim(), result.searchableFields.indexOf(searchableFieldName) === -1 && result.searchableFields.push(searchableFieldName)
                            }), objectConfiguration.MobileVizArt__List_Content_Fields__c && objectConfiguration.MobileVizArt__List_Content_Fields__c.trim().length && angular.forEach(objectConfiguration.MobileVizArt__List_Content_Fields__c.split(","), function (listFieldName) {
                                listFieldName = listFieldName.trim(), result.listFields.indexOf(listFieldName) === -1 && result.listFields.push(listFieldName)
                            })), resolve(result)
                        }, reject)
                    }, reject)
                } else reject("LocalDataService._getObjectSearchableFields error: missing parameter.")
            })
        }, _resolveObjectNameOrSubjectField = function (objectName) {
            return $q(function (resolve, reject) {
                objectName ? DescribeService.getDescribeSObject(objectName).then(function (describeResult) {
                    var returnFieldName = null;
                    if (describeResult && describeResult.fields) for (var i = 0; i < describeResult.fields.length; i++) {
                        if ("Name" === describeResult.fields[i].name) {
                            returnFieldName = describeResult.fields[i].name;
                            break
                        }
                        if ("Subject" === describeResult.fields[i].name) {
                            returnFieldName = describeResult.fields[i].name;
                            break
                        }
                    }
                    resolve(returnFieldName)
                }, reject) : reject("LocalDataService._resolveObjectNameOrSubjectField error: missing parameter.")
            })
        }, _initQueueMessage = function (targetObjectName, soupEntryId, sfdcId) {
            return {
                objectName: targetObjectName,
                recordSoupEntryId: soupEntryId,
                sfdcId: sfdcId,
                state: null,
                action: null,
                error: null
            }
        }, _handleQueueAction = function (objectType, records, action) {
            return $q(function (resolve, reject) {
                var actions = [SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_INSERT, SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_UPDATE, SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_DELETE];
                if (objectType && action && actions.indexOf(action) !== -1 && records && records.length) {
                    var messages = [], recordSoupEntryIds2remove = [];
                    angular.forEach(records, function (record) {
                        var message = _initQueueMessage(objectType, record._soupEntryId, record.Id);
                        message.action = action, action !== SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_DELETE || record.Id ? messages.push(message) : recordSoupEntryIds2remove.push(record._soupEntryId)
                    }), _removeExistingQueueMessagesForDeletedRecords(objectType, recordSoupEntryIds2remove).then(function (isOk) {
                        isOk === !0 ? _saveQueueMessages(messages).then(function () {
                            resolve(!0)
                        }, reject) : reject("Failed to remove local deleted queue messages.")
                    }, reject)
                } else reject("LocalDataService._handleQueueAction Error: Invalid parameters.")
            })
        }, _saveQueueMessages = function (messages) {
            return $q(function (resolve, reject) {
                var queueSoup = SMARTSTORE_COMMON_SETTING.SOUP_NAME_QUEUE, objectNames = [], recordSoupEntryIds = [];
                angular.forEach(messages, function (message) {
                    objectNames.indexOf("'" + message.objectName + "'") === -1 && objectNames.push("'" + message.objectName + "'"), recordSoupEntryIds.indexOf(message.recordSoupEntryId) === -1 && recordSoupEntryIds.push(message.recordSoupEntryId)
                });
                var smartSql = "select {" + queueSoup + ":_soup} from {" + queueSoup + "} ";
                smartSql += "where {" + queueSoup + ":objectName} in (" + objectNames.join(",") + ") ", smartSql += "and {" + queueSoup + ":recordSoupEntryId} in (" + recordSoupEntryIds.join(",") + ") ";
                var querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
                navigator.smartstore.runSmartQuery(!1, querySpec, function (cursor) {
                    var currentPageEntries = _.flatten(cursor.currentPageOrderedEntries), upsertedMessages = [],
                        extraQueueIds2Remove = [];
                    angular.forEach(messages, function (message) {
                        var filterCondition = {
                            objectName: message.objectName + "",
                            recordSoupEntryId: message.recordSoupEntryId
                        }, queue2save = message, originalQueues = _.where(currentPageEntries, filterCondition);
                        if (originalQueues && originalQueues.length) {
                            var localQueue = originalQueues[0];
                            localQueue.state = null, localQueue.error = null;
                            for (var i = 1; i < originalQueues.length; i++) extraQueueIds2Remove.push(originalQueues[i]._soupEntryId);
                            message.sfdcId ? localQueue.action = message.action : localQueue.action = SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_INSERT, queue2save = localQueue
                        }
                        upsertedMessages.push(queue2save)
                    }), navigator.smartstore.removeFromSoup(queueSoup, extraQueueIds2Remove, function () {
                        navigator.smartstore.upsertSoupEntries(queueSoup, upsertedMessages, function (upsertedMessages) {
                            resolve(upsertedMessages)
                        }, function (error) {
                            reject(error)
                        })
                    }, reject)
                }, reject)
            })
        }, _filterUnconfiguredFieldValues = function (objectType, sobjects) {
            return $q(function (resolve, reject) {
                objectType && sobjects && sobjects.length ? service.getFieldInformations(objectType).then(function (fields) {
                    var sobjectConfiguredFields = ["_soupEntryId", "_soupLastModifiedDate", "attributes"];
                    fields && fields.length && angular.forEach(fields, function (field) {
                        var fieldName = field.name, fieldType = field.type;
                        if (sobjectConfiguredFields.push(fieldName), "reference" === fieldType) {
                            var sidFieldName = fieldName + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_EXTENSION_SUFFIX;
                            sobjectConfiguredFields.push(sidFieldName);
                            var typeFieldName = fieldName + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_TYPE_SUFFIX;
                            sobjectConfiguredFields.push(typeFieldName)
                        }
                    }), angular.forEach(sobjects, function (record) {
                        for (var k in record) record.hasOwnProperty(k) && sobjectConfiguredFields.indexOf(k) === -1 && delete record[k]
                    }), resolve(sobjects)
                }, reject) : reject("Error: Invalid parameters.")
            })
        }, __resolveObjectFieldDefaultValue = function (objectType, recordType, newSObjectRecord) {
            return $q(function (resolve, reject) {
                return objectType && newSObjectRecord ? void service.getFieldInformations(objectType).then(function (fields) {
                    var resolveFieldDefaultValuePromises = [];
                    angular.forEach(fields, function (field) {
                        var resolveFieldDefaultValuePromise = _resolveFieldDefaultValue(objectType, recordType, field).then(function (fieldDefaultValue) {
                            newSObjectRecord[field.name] = fieldDefaultValue
                        }, function (err) {
                        });
                        resolveFieldDefaultValuePromises.push(resolveFieldDefaultValuePromise)
                    }), $q.all(resolveFieldDefaultValuePromises).then(function () {
                        resolve(newSObjectRecord)
                    }, reject)
                }, reject) : reject("__resolveObjectFieldDefaultValue: Invalid parameters.")
            })
        }, _resolveFieldDefaultValue = function (objectType, recordType, field) {
            return $q(function (resolve, reject) {
                if (!objectType || !field) return reject("_resolveFieldDefaultValue: Invalid parameters.");
                var resolvePicklistValue, fieldName = field.name, fieldType = field.type, fieldDefaultValue = null,
                    numberRegex = /^\d+\.?\d*$/, stringRegex = /^(\'[^\']+\'|\"[^\"]+\")$/;
                switch (fieldType) {
                    case"string":
                    case"email":
                    case"phone":
                    case"textarea":
                    case"url":
                        stringRegex.test(field.defaultValueFormula) && (fieldDefaultValue = field.defaultValueFormula.substring(1, field.defaultValueFormula.length - 1));
                        break;
                    case"double":
                    case"currency":
                    case"percent":
                        !_.endsWith(fieldName, "__s") && numberRegex.test(field.defaultValueFormula) && (fieldDefaultValue = new Number(field.defaultValueFormula));
                        break;
                    case"picklist":
                    case"multipicklist":
                        if (recordType) {
                            var uniqueExternalDeveloperNameKey = PicklistService.getUniqueExternalKey(objectType, recordType, fieldName);
                            resolvePicklistValue = service.getEntryByExactMatch("_picklists", "uniqueExternalDeveloperNameKey", uniqueExternalDeveloperNameKey).then(function (picklistEntry) {
                                picklistEntry && picklistEntry.picklistValues && picklistEntry.picklistValues.length && angular.forEach(picklistEntry.picklistValues, function (picklistValue) {
                                    picklistValue.active && picklistValue.defaultValue && (fieldDefaultValue = picklistValue.masterValue)
                                })
                            }, reject)
                        }
                        break;
                    case"boolean":
                        fieldDefaultValue = null !== field.defaultValue && field.defaultValue;
                        break;
                    case"date":
                    case"datetime":
                        var datetimeFields = ["CreatedDate", "LastModifiedDate", "SystemModstamp"];
                        datetimeFields.indexOf(fieldName) > -1 && (fieldDefaultValue = (new Date).toISOString())
                }
                resolvePicklistValue ? resolvePicklistValue.then(function () {
                    resolve(fieldDefaultValue)
                }, reject) : resolve(fieldDefaultValue)
            })
        };
        service.loadBusinessDescribeSObjects = function (skipReload) {
            var deferred = $q.defer(), handleError = function (error) {
                error && "function" == typeof error.handle ? (error.retry = service.loadBusinessDescribeSObjects, error.retryDeferred = deferred, error.handle()) : new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, error.message, error.stack, error, service.loadBusinessDescribeSObjects, null, null, null, deferred).handle(), deferred.reject(error)
            };
            return !skipReload && ConnectionMonitor.isOnline() ? service.queryConfigurationAndObjects().then(function (configuration) {
                if (void 0 === configuration.objects) return void deferred.resolve();
                console.log('obj :::', configuration.objects);
                var objNames = _.pluck(configuration.objects, "Name");
                console.log('objNames:::',objNames);
                DescribeService.loadDescribeSObjects(objNames).then(function () {
                    deferred.resolve()
                }, function (err) {
                    handleError(err)
                })
            }, function (err) {
                handleError(err)
            }) : ($log.debug(">>>> they have been already loaded in initialization or offline ... skip refresh describeSObject"), deferred.resolve()), deferred.promise
        }, service.getObjectStylesByName = function (objectsName) {
            return $q(function (resolve, reject) {
                var objectsStyle = [], _checkIfCacheExistForObject = function (obj) {
                    var objectCached = !0, objectFromCache = [];
                    return objectFromCache.style = LocalCacheService.get(obj.name + "Class"), objectFromCache.icon = LocalCacheService.get(obj.icon + "Icon"), "undefined" != typeof objectFromCache.style && "undefined" != typeof objectFromCache.icon || (objectCached = !1), objectCached
                }, _checkIfAllObjectsAreCached = function (objs) {
                    var allObjectsAreCached = !0;
                    return angular.forEach(objs, function (obj) {
                        allObjectsAreCached = 0 != _checkIfCacheExistForObject(obj) && allObjectsAreCached
                    }), allObjectsAreCached
                };
                0 == _checkIfAllObjectsAreCached(objectsName) ? service.queryConfigurationAndObjects().then(function (configuration) {
                    angular.forEach(configuration.objects, function (obj) {
                        if (objectsName.indexOf(obj.Name) !== -1 && 0 == _checkIfCacheExistForObject(obj)) {
                            var styledObj = service.applyCssStyleForObject(obj);
                            LocalCacheService.set(obj.Name + "Class", styledObj["class"]), LocalCacheService.set(obj.Name + "Icon", styledObj.icon), objectsStyle[obj.Name] = styledObj
                        }
                    }), resolve(objectsStyle)
                }, reject) : resolve(objectsStyle)
            })
        }, service.applyCssStyleForObject = function (obj) {
            var iconClassStandard = "slds-icon-standard-", iconClassCustom = "slds-icon-custom-",
                iconHrefStandard = "lib/salesforce-lightning-design-system/assets/icons/standard-sprite/svg/symbols.svg#",
                iconHrefCustom = "lib/salesforce-lightning-design-system/assets/icons/custom-sprite/svg/symbols.svg#",
                mobileStringConf = "MobileVizArt__Object_Style_Code__c", objectOut = [];
            return mobileStringConf in obj && obj[mobileStringConf].length > 0 ? (objectOut["class"] = iconClassStandard + obj[mobileStringConf], objectOut.icon = iconHrefStandard + obj[mobileStringConf]) : (objectOut["class"] = iconClassCustom + "custom57", objectOut.icon = iconHrefCustom + "custom57"), _constructStyleObjectFromArray(objectOut)
        };
        var _constructStyleObjectFromArray = function (obj) {
            return obj["class"] = obj["class"] || "", obj.icon = obj.icon || "", {"class": obj["class"], icon: obj.icon}
        };
        service.queryConfiguredObjectByName = function (objectName) {
            return $q(function (resolve, reject) {
                objectName ? _configurationObjects ? resolve(_.findWhere(_configurationObjects, {Name: objectName})) : service.queryConfigurationAndObjects().then(function (configuration) {
                    var objectConfiguration = null;
                    configuration && configuration.objects && configuration.objects.length && (_configurationObjects = configuration.objects, objectConfiguration = _.findWhere(configuration.objects, {Name: objectName})), resolve(objectConfiguration)
                }, reject) : reject(new Error("LocalDataService.queryConfiguredObjectByName error: missing parameter."))
            })
        }, service.getConfiguredObjects = function () {
            return $q(function (resolve, reject) {
                service.queryConfigurationAndObjects().then(function (configuration) {
                    var objectConfigurations = null;
                    configuration && configuration.objects && (objectConfigurations = configuration.objects), resolve(objectConfigurations)
                }, reject)
            })
        }, service.queryConfigurationAndObjects = function (profileId) {
            var currentUser, deferred = $q.defer(), configuration = {objects: []},
                querySpec = navigator.smartstore.buildAllQuerySpec("Name", null, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
            return navigator.smartstore.querySoup(!1, "_configuration", querySpec, function (cursor) {
                var currentPageEntries = cursor.currentPageOrderedEntries;
                if (APP_SETTINGS.LOCAL_CONFIGURATION === !0) configuration = currentPageEntries.length ? currentPageEntries[0] : null, configuration && configuration.objects && (configuration.objects = _.sortBy(configuration.objects, "MobileVizArt__Level__c")), _filterObjectTypesByPermissions(configuration.objects).then(function (filteredObjects) {
                    configuration.objects = filteredObjects, deferred.resolve(configuration)
                }, function (error) {
                    deferred.reject(error)
                }); else {
                    profileId || (currentUser = LocalCacheService.get("currentUser"), currentUser && (profileId = currentUser.ProfileId)), profileId.length > 15 && (profileId = profileId.substring(0, 15));
                    var matchConfigurations = $filter("filter")(currentPageEntries, {MobileVizArt__Profiles__c: profileId});
                    if (void 0 !== matchConfigurations && matchConfigurations.length > 0) {
                        configuration = matchConfigurations[0];
                        var querySpec = navigator.smartstore.buildExactQuerySpec("MobileVizArt__Mobile_Configuration__c", configuration.Id, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL, null, "MobileVizArt__Level__c");
                        navigator.smartstore.querySoup(!1, "_object", querySpec, function (cursor) {
                            var currentPageEntries = cursor.currentPageOrderedEntries;
                            _filterObjectTypesByPermissions(currentPageEntries).then(function (filteredObjects) {
                                configuration.objects = filteredObjects, deferred.resolve(configuration)
                            }, function (error) {
                                deferred.reject(error)
                            })
                        }, function (error) {
                            deferred.reject(error)
                        })
                    } else deferred.resolve(null)
                }
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        var _filterObjectTypesByPermissions = function (objectTypes) {
                var deferred = $q.defer(), mandatoryObjectsConfig = APP_SETTINGS.MANDATORY_OBJECTS, mandatoryObjects = [];
                return mandatoryObjectsConfig && (mandatoryObjects = mandatoryObjectsConfig.replace(new RegExp(/\s/g), "").split(",")), MetaService.getMetaValue("objectPermissions").then(function (objectPermissions) {
                    if (objectPermissions && objectTypes && objectTypes.length > 0) {
                        var filteredObjectTypes = [], filteredObjectNames = [];
                        angular.forEach(objectTypes, function (objType) {
                            var objPermission = objectPermissions[objType.Name];
                            objPermission && objPermission.PermissionsRead === !0 && (filteredObjectTypes.push(objType), filteredObjectNames.push(objType.Name))
                        });
                        var missMandatoryObjects = _.difference(mandatoryObjects, filteredObjectNames);
                        if (missMandatoryObjects && missMandatoryObjects.length > 0) {
                            var msg = "The app would exit immediately, please try login again after contacting to your system admin to get permission for the following objects in the org: " + missMandatoryObjects.join(",");
                            deferred.reject(new Exception(EXCEPTION_SEVERITY.NON_RECOVERABLE, "403", msg))
                        } else deferred.resolve(filteredObjectTypes)
                    } else deferred.resolve(objectTypes)
                }, function (error) {
                    deferred.reject(error)
                }), deferred.promise
            }, _removeExistingQueueMessagesForDeletedRecords = function (targetObjectName, _soupEntryIds) {
                var deferred = $q.defer(), queueSoup = SMARTSTORE_COMMON_SETTING.SOUP_NAME_QUEUE, deletedQueueEntryIds = [],
                    smartSql = "select {" + queueSoup + ":_soupEntryId} from {" + queueSoup + "} ";
                smartSql += "where {" + queueSoup + ":objectName} = '" + targetObjectName + "' ", smartSql += "and {" + queueSoup + ":recordSoupEntryId} in (" + _soupEntryIds.join(",") + ")";
                var querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
                return navigator.smartstore.runSmartQuery(!1, querySpec, function (cursor) {
                    var currentPageEntries = cursor.currentPageOrderedEntries;
                    angular.forEach(currentPageEntries, function (queueItem) {
                        deletedQueueEntryIds.push(queueItem[0])
                    }), deletedQueueEntryIds.length > 0 ? navigator.smartstore.removeFromSoup(queueSoup, deletedQueueEntryIds, function () {
                        deferred.resolve(!0)
                    }, function (err) {
                        deferred.reject(err)
                    }) : deferred.resolve(!0)
                }, function (err) {
                    deferred.reject(err)
                }), deferred.promise
            },
            _mountSObjectReferenceEntities = function (objectType, fieldNames, localEntries, refer2EntityFieldNames2Load) {
                var deferred = $q.defer(), localEntrySoupEntryIds = [], localEntrySoupEntryId2EntryMap = {},
                    refer2EntityFieldNames2LoadDefault = ["_soupEntryId", "Id", "Name"];
                return angular.forEach(localEntries, function (localEntry) {
                    localEntrySoupEntryIds.indexOf(localEntry._soupEntryId) === -1 && localEntrySoupEntryIds.push(localEntry._soupEntryId), localEntrySoupEntryId2EntryMap[localEntry._soupEntryId] = localEntry
                }), service.getFieldInformations(objectType).then(function (fields) {
                    var fieldReferToIndexMap = {}, index = 1, referenceToObjectNames = [],
                        referenceToSidFieldNames = [], referenceToObjectLoadedFieldNames = [], referenceFields = [];
                    angular.forEach(fields, function (field) {
                        "reference" === field.type && (null === fieldNames || fieldNames.length && fieldNames.indexOf(field.name) > -1) && referenceFields.push(field)
                    });
                    var resolveReferToObjectNames = function (field) {
                        if (field) {
                            var fieldName = field.name, referenceTo = field.referenceTo,
                                referenceToFieldName = fieldName + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_EXTENSION_SUFFIX;
                            service.resolveRefer2ExistingObjectNames(referenceTo).then(function (objNames) {
                                if (objNames && objNames.length) {
                                    fieldReferToIndexMap[fieldName] = {from: index}, fieldReferToIndexMap[fieldName].referenceToInfo = {};
                                    var fieldNames2load = refer2EntityFieldNames2LoadDefault,
                                        shouldLoadFields = void 0 === refer2EntityFieldNames2Load ? void 0 : refer2EntityFieldNames2Load[fieldName];
                                    shouldLoadFields && shouldLoadFields.length && (fieldNames2load = shouldLoadFields);
                                    for (var j = 0; j < objNames.length; j++) {
                                        var currentObjectFieldNames2load = angular.copy(fieldNames2load),
                                            referenceToObjectApiName = objNames[j];
                                        "Case" !== referenceToObjectApiName && "Task" !== referenceToObjectApiName && "Event" !== referenceToObjectApiName || (currentObjectFieldNames2load = ["_soupEntryId", "Id", "Subject"]), "RecordType" === referenceToObjectApiName && currentObjectFieldNames2load.push("DeveloperName"), fieldReferToIndexMap[fieldName].referenceToInfo[referenceToObjectApiName] = {
                                            from: index,
                                            fieldNames2load: currentObjectFieldNames2load
                                        }, referenceToObjectLoadedFieldNames.push(currentObjectFieldNames2load), referenceToObjectNames.push(objNames[j]), referenceToSidFieldNames.push(referenceToFieldName), index += currentObjectFieldNames2load.length
                                    }
                                    fieldReferToIndexMap[fieldName].to = index
                                }
                                if (referenceFields.length) resolveReferToObjectNames(referenceFields.pop()); else if (referenceToObjectNames.length) {
                                    var whereSql, querySql = "",
                                        selectSql = "select r.{" + objectType + ":_soupEntryId},", joinSql = "",
                                        fromSql = " from {" + objectType + "} as r";
                                    localEntrySoupEntryIds.length && (whereSql = " where r.{" + objectType + ":_soupEntryId} in (" + localEntrySoupEntryIds.join(",") + ") ");
                                    for (var k = 0; k < referenceToObjectNames.length; k++) {
                                        for (var objName = referenceToObjectNames[k], rname = "r" + k, _fieldNames2load = referenceToObjectLoadedFieldNames[k], m = 0; m < _fieldNames2load.length; m++) {
                                            var fieldName2load = _fieldNames2load[m];
                                            selectSql += " " + rname + ".{" + objName + ":" + fieldName2load + "},"
                                        }
                                        joinSql += " left outer join {" + objName + "} as " + rname, joinSql += " on r.{" + objectType + ":" + referenceToSidFieldNames[k] + "} = " + rname + ".{" + objName + ":_soupEntryId}"
                                    }
                                    querySql = selectSql.substring(0, selectSql.length - 1) + fromSql + joinSql, whereSql && (querySql += whereSql);
                                    var querySpec = navigator.smartstore.buildSmartQuerySpec(querySql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
                                    navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                                        cursor && cursor.currentPageOrderedEntries && cursor.currentPageOrderedEntries.length && angular.forEach(cursor.currentPageOrderedEntries, function (aggragateResult) {
                                            var entryId = aggragateResult[0],
                                                localEntry = localEntrySoupEntryId2EntryMap[entryId];
                                            for (var fieldName in fieldReferToIndexMap) if (fieldReferToIndexMap.hasOwnProperty(fieldName)) {
                                                var additionalValueKey = (fieldReferToIndexMap[fieldName].from, fieldReferToIndexMap[fieldName].to, angular.copy(fieldName));
                                                _.endsWith(additionalValueKey, "Id") ? additionalValueKey = additionalValueKey.substring(0, additionalValueKey.length - 2) : _.endsWith(additionalValueKey, "__c") && (additionalValueKey = additionalValueKey.substring(0, additionalValueKey.length - 1) + "r");
                                                var referenceToObjectName = localEntry[fieldName + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_TYPE_SUFFIX];
                                                if (referenceToObjectName && fieldReferToIndexMap[fieldName].referenceToInfo[referenceToObjectName]) {
                                                    for (var m = fieldReferToIndexMap[fieldName].referenceToInfo[referenceToObjectName].from, fieldNames2load = fieldReferToIndexMap[fieldName].referenceToInfo[referenceToObjectName].fieldNames2load, referToEntityFieldValues = aggragateResult.slice(m, m + fieldNames2load.length), referToEntity = {}, n = 0; n < fieldNames2load.length; n++) referToEntity[fieldNames2load[n]] = referToEntityFieldValues[n];
                                                    referToEntity.type = referenceToObjectName, localEntry[additionalValueKey] = referToEntity
                                                }
                                            }
                                        }), deferred.resolve(localEntries)
                                    }, function (err) {
                                        deferred.reject(err)
                                    })
                                } else deferred.resolve(localEntries)
                            }, function (error) {
                                deferred.reject(error)
                            })
                        } else referenceFields.length ? resolveReferToObjectNames(referenceFields.pop()) : deferred.resolve(localEntries)
                    };
                    resolveReferToObjectNames(referenceFields.pop())
                }, function (err) {
                    deferred.reject(err)
                }), deferred.promise
            };
        service.getConfiguredObjectNames = function () {
            return $q(function (resolve, reject) {
                var configuredObjects = ["RecordType"];
                service.queryConfigurationAndObjects().then(function (configuration) {
                    angular.forEach(configuration.objects, function (obj) {
                        configuredObjects.indexOf(obj.Name) === -1 && configuredObjects.push(obj.Name)
                    }), resolve(configuredObjects)
                }, reject)
            })
        }, service.resolveRefer2ExistingObjectNames = function (objNames) {
            return $q(function (resolve, reject) {
                var results = [];
                service.getConfiguredObjectNames().then(function (configuredObjectNames) {
                    configuredObjectNames && configuredObjectNames.length && angular.forEach(objNames, function (objName) {
                        configuredObjectNames.indexOf(objName) > -1 && results.indexOf(objName) === -1 && results.push(objName)
                    }), resolve(results)
                }, reject)
            })
        };
        var localSoups = {};
        service.isSoupExist = function (soupName) {
            return $q(function (resolve, reject) {
                soupName ? localSoups[soupName] ? resolve(localSoups[soupName]) : navigator.smartstore.soupExists(soupName, function (isSoupExists) {
                    localSoups[soupName] = isSoupExists, resolve(localSoups[soupName])
                }, reject) : reject("LocalDataService.isSoupExist Error: missing parameter.")
            })
        }, service.getEntryByExactMatch = function (objectType, path, matchKey) {
            var deferred = $q.defer(), querySpec = navigator.smartstore.buildExactQuerySpec(path, matchKey, 1);
            return navigator.smartstore.querySoup(objectType, querySpec, function (cursor) {
                var result = cursor && cursor.currentPageOrderedEntries && cursor.currentPageOrderedEntries.length ? cursor.currentPageOrderedEntries[0] : null;
                deferred.resolve(result)
            }, function (err) {
                deferred.resolve(null)
            }), deferred.promise
        };
        service.getReferenceRecordBySFId = function (id, referenceTo, notFilterReferenceTo) {
            return $q(function (resolve, reject) {
                if (id && referenceTo && 0 !== referenceTo.length) {
                    var i = 0, perProcess = function (objNames) {
                        service.getEntryByExactMatch(objNames[i], "Id", id).then(function (referenceToEntity) {
                            referenceToEntity ? resolve(referenceToEntity) : (i++, i < objNames.length ? perProcess(objNames) : reject())
                        }, reject)
                    };
                    notFilterReferenceTo ? perProcess(referenceTo) : service.resolveRefer2ExistingObjectNames(referenceTo).then(function (newReferenceTo) {
                        perProcess(newReferenceTo)
                    }, reject)
                } else reject()
            })
        }, service.getFieldInformations = function (objectType) {
            var deferred = $q.defer();
            return objectType ? fieldInformationsCache[objectType] ? deferred.resolve(fieldInformationsCache[objectType]) : service.queryConfigurationAndObjects().then(function (configuration) {
                var i = 0, parseConfiguration = function () {
                    if (void 0 === configuration.objects) return void deferred.resolve(null);
                    if (i < configuration.objects.length) {
                        var configObj = configuration.objects[i];
                        DescribeService.getDescribeSObject(configObj.Name).then(function (describeResult) {
                            var skipConfigurationObjects = ["MobileVizArt__Mobile_Configuration__c", "MobileVizArt__Mobile_Object__c"],
                                syncedFields = configObj.MobileVizArt__Fields__c.split(","), fields = [];
                            angular.forEach(describeResult.fields, function (fieldItem) {
                                syncedFields.indexOf(fieldItem.name) === -1 && skipConfigurationObjects.indexOf(configObj.Name) === -1 || fields.push(fieldItem)
                            }), fieldInformationsCache[configObj.Name] = fields, i++, parseConfiguration()
                        }, function (err) {
                            deferred.reject(err)
                        })
                    } else deferred.resolve(fieldInformationsCache[objectType])
                };
                parseConfiguration()
            }, function (err) {
                deferred.reject(err)
            }) : deferred.resolve(null), deferred.promise
        }, service.soqlFieldsForObjectType = function (objectType) {
            var deferred = $q.defer();
            return service.getFieldInformations(objectType).then(function (fields) {
                deferred.resolve(_.pluck(fields, "name"))
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.getRecordsSumBySoup = function (objectType, filterCriteria) {
            var deferred = $q.defer(), smartSql = "select count(*) from {" + objectType + "}";
            filterCriteria && (smartSql += " where " + filterCriteria);
            var querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql);
            return navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                cursor.currentPageOrderedEntries && 1 == cursor.currentPageOrderedEntries.length ? deferred.resolve(cursor.currentPageOrderedEntries[0][0]) : deferred.reject(0)
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, service.getAllRecordsSidBySoup = function (objectType, filterCriteria) {
            var deferred = $q.defer(), smartSql = "select {" + objectType + ":_soupEntryId} from {" + objectType + "}";
            filterCriteria && (smartSql += " where " + filterCriteria);
            var querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
            return navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                deferred.resolve(_.pluck(cursor.currentPageOrderedEntries, "0"))
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, service.getAllRecordsSFIdBySoup = function (objectType, filterCriteria) {
            var deferred = $q.defer(),
                smartSql = "select {" + objectType + ":Id} from {" + objectType + "} where {" + objectType + ":Id} is not null";
            filterCriteria && (smartSql += " and " + filterCriteria);
            var querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
            return navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                deferred.resolve(_.pluck(cursor.currentPageOrderedEntries, "0"))
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, service.getActiveRecordsSFIdBySoup = function (objectType, filterCriteria) {
            var queueSoup = SMARTSTORE_COMMON_SETTING.SOUP_NAME_QUEUE, deferred = $q.defer(),
                smartSql = "select {" + queueSoup + ":sfdcId} from {" + queueSoup + "} where {" + queueSoup + ":sfdcId} is not null and {" + queueSoup + ":objectName} = '" + objectType + "'";
            filterCriteria && (smartSql += " and " + filterCriteria);
            var querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
            return navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                deferred.resolve(_.pluck(cursor.currentPageOrderedEntries, "0"))
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, service.getActiveRecordsSidBySoup = function (objectType, filterCriteria) {
            var queueSoup = SMARTSTORE_COMMON_SETTING.SOUP_NAME_QUEUE, deferred = $q.defer(),
                smartSql = "select {" + queueSoup + ":recordSoupEntryId} from {" + queueSoup + "} where {" + queueSoup + ":objectName} = '" + objectType + "'";
            filterCriteria && (smartSql += " and " + filterCriteria);
            var querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
            return navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                deferred.resolve(_.pluck(cursor.currentPageOrderedEntries, "0"))
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, service.getNoIdRecordsSidBySoup = function (objectType, filterCriteria) {
            var deferred = $q.defer(),
                smartSql = "select {" + objectType + ":_soupEntryId} from {" + objectType + "} where {" + objectType + ":Id} is null";
            filterCriteria && (smartSql += " and " + filterCriteria);
            var querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
            return navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                deferred.resolve(_.pluck(cursor.currentPageOrderedEntries, "0"))
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, service.getRecordsSidBySFid = function (objectType, sfIds) {
            var deferred = $q.defer(),
                smartSql = "select {" + objectType + ":_soupEntryId} from {" + objectType + "} where {" + objectType + ":Id} in ('" + sfIds.join("','") + "')",
                querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
            return navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                deferred.resolve(_.pluck(cursor.currentPageOrderedEntries, "0"))
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, service.upsert = function (objectName, records, isLocalUpdate) {
            var deferred = $q.defer();
            return navigator.smartstore.upsertSoupEntries(objectName, records, function (upsertedRecords) {
                if (isLocalUpdate) deferred.resolve(upsertedRecords); else {
                    var messages = [];
                    _.each(upsertedRecords, function (upsertedRecord) {
                        var message = service.initQueueMessage(objectName, upsertedRecord._soupEntryId, upsertedRecord.Id),
                            originalRecord = _.findWhere(records, {_soupEntryId: upsertedRecord._soupEntryId});
                        originalRecord ? message.action = SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_UPDATE : message.action = SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_INSERT, messages.push(message)
                    }), service.saveQueueMessages(messages).then(function (result) {
                        deferred.resolve(upsertedRecords)
                    }, function (error) {
                        deferred.reject(error)
                    })
                }
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service["delete"] = function (objectName, records, isLocalDelete) {
            var deferred = $q.defer(), entryIds = [];
            return _.each(records, function (record) {
                entryIds.push(record._soupEntryId)
            }), navigator.smartstore.removeFromSoup(objectName, entryIds, function (success) {
                isLocalDelete ? deferred.resolve(success) : _removeExistingQueueMessagesForDeletedRecords(objectName, entryIds).then(function () {
                    var messages = [];
                    _.each(records, function (deletedRecord) {
                        if (deletedRecord.Id) {
                            var message = service.initQueueMessage(objectName, deletedRecord._soupEntryId, deletedRecord.Id);
                            message.action = SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_DELETE, messages.push(message)
                        }
                    }), messages.length ? service.saveQueueMessages(messages).then(function () {
                        deferred.resolve(!0)
                    }, function (error) {
                        deferred.reject(error)
                    }) : deferred.resolve(!0)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.initQueueMessage = function (targetObjectName, soupEntryId, sfdcId) {
            return {
                objectName: targetObjectName,
                recordSoupEntryId: soupEntryId,
                sfdcId: sfdcId,
                state: null,
                action: null,
                error: null
            }
        }, service.saveQueueMessages = function (messages) {
            var deferred = $q.defer(), queueSoup = SMARTSTORE_COMMON_SETTING.SOUP_NAME_QUEUE, objectNames = [],
                recordSoupEntryIds = [], actions = [];
            angular.forEach(messages, function (message) {
                objectNames.indexOf("'" + message.objectName + "'") === -1 && objectNames.push("'" + message.objectName + "'"), recordSoupEntryIds.indexOf(message.recordSoupEntryId) === -1 && recordSoupEntryIds.push(message.recordSoupEntryId), actions.indexOf("'" + message.action + "'") === -1 && actions.push("'" + message.action + "'")
            });
            var smartSql = "select {" + queueSoup + ":_soup} from {" + queueSoup + "} ";
            smartSql += "where {" + queueSoup + ":objectName} in (" + objectNames.join(",") + ") ", smartSql += "and {" + queueSoup + ":recordSoupEntryId} in (" + recordSoupEntryIds.join(",") + ") ", smartSql += "and {" + queueSoup + ":action} in (" + actions.join(",") + ")";
            var querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
            return navigator.smartstore.runSmartQuery(!1, querySpec, function (cursor) {
                var currentPageEntries = _.flatten(cursor.currentPageOrderedEntries), upsertedMessages = [];
                angular.forEach(messages, function (message) {
                    var filterCondition = {
                        objectName: message.objectName + "",
                        recordSoupEntryId: message.recordSoupEntryId,
                        action: message.action + ""
                    }, originalQueue = _.where(currentPageEntries, filterCondition);
                    originalQueue ? (originalQueue = originalQueue[0], originalQueue.state = null, originalQueue.error = null, upsertedMessages.push(originalQueue)) : upsertedMessages.push(message)
                }), navigator.smartstore.upsertSoupEntries(SMARTSTORE_COMMON_SETTING.SOUP_NAME_QUEUE, upsertedMessages, function (upsertedMessages) {
                    deferred.resolve(upsertedMessages)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, service.initTestData = function (initIndex, remoteExistSoupId, remoteSalesforceId, testIndex) {
            initIndex || (initIndex = [0]), testIndex || (testIndex = "");
            var promises = [];
            if (initIndex.indexOf(0) !== -1) {
                var promise = service.upsert("Account", [{Name: "LG Sync Up Single Added Account Test " + testIndex}]);
                promises.push(promise)
            } else if (initIndex.indexOf(1) !== -1) {
                var promise1 = service.upsert("Account", [{Name: "LG Sync Up Unity Added Account Test " + testIndex}]).then(function (upsertedRecord) {
                    var accEntryId = upsertedRecord[0]._soupEntryId;
                    service.upsert("Contact", [{
                        LastName: "LG Sync Up Unity Added Contact Test " + testIndex,
                        AccountId_sid: accEntryId
                    }, {
                        LastName: "LG Sync Up Second Unity Added Contact Test " + testIndex,
                        AccountId_sid: accEntryId
                    }])
                });
                promises.push(promise1)
            } else if (initIndex.indexOf(2) !== -1) {
                var promise2 = service.upsert("Account", [{Name: "LG Sync Up First Added Account Test " + testIndex}]).then(function (upsertedRecord) {
                    upsertedRecord[0].Name = "LG Sync Up First Updated Account Test " + testIndex, service.upsert("Account", upsertedRecord).then(function (newRecord) {
                        newRecord[0].Name = "LG Sync Up Second Updated Account Test " + testIndex, service.upsert("Account", newRecord)
                    })
                });
                promises.push(promise2)
            } else if (initIndex.indexOf(3) !== -1) {
                var promise3 = service.upsert("Account", [{Name: "LG Sync Up First Added Account Test " + testIndex}, {Id: "incorrectId"}]);
                promises.push(promise3)
            } else if (initIndex.indexOf(4) !== -1 && remoteExistSoupId && remoteSalesforceId) {
                var promise4 = service.upsert("Account", [{
                    Id: remoteSalesforceId,
                    _soupEntryId: remoteExistSoupId,
                    Name: "LG Sync Up Updated Remote Exist Account Test " + testIndex
                }]);
                promises.push(promise4)
            } else if (initIndex.indexOf(5) !== -1 && remoteExistSoupId && remoteSalesforceId) {
                var promise5 = service["delete"]("Account", [{
                    Id: remoteSalesforceId,
                    _soupEntryId: remoteExistSoupId
                }]);
                promises.push(promise5)
            } else if (initIndex.indexOf(6) !== -1 && remoteExistSoupId && remoteSalesforceId) {
                var promise6 = service.upsert("Account", [{
                    Id: remoteSalesforceId,
                    _soupEntryId: remoteExistSoupId,
                    Name: "LG Sync Up Updated Remote Exist Account Test " + testIndex
                }]).then(function () {
                    service["delete"]("Account", [{Id: remoteSalesforceId, _soupEntryId: remoteExistSoupId}])
                });
                promises.push(promise6)
            } else if (initIndex.indexOf(7) !== -1) {
                var promise7 = service.upsert("Account", [{Name: "LG Sync Up First Added Account Test " + testIndex}]).then(function (upsertedRecord) {
                    upsertedRecord[0].Name = "LG Sync Up First Updated Account Test " + testIndex, service.upsert("Account", upsertedRecord).then(function (newRecord) {
                        service["delete"]("Account", newRecord)
                    })
                });
                promises.push(promise7)
            }
            $q.all(promises).then(function () {
            })
        }, service.testSqlQuery = function (sql, size) {
            var querySpec = navigator.smartstore.buildSmartQuerySpec(sql, size);
            navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
            }, function (err) {
            })
        }, service.testCUDActions = function () {
            return $q(function (resolve, reject) {
                $q(function (innerResolve, innerReject) {
                    service.saveSObjects("Contact", [{
                        FirstName: "aaa",
                        LastName: "bbb",
                        Description: "Will be delete by field filter"
                    }, {
                        FirstName: "ccc",
                        LastName: "ddd",
                        Description: "Will be delete by field filter"
                    }]).then(function (result) {
                        var expectQueueMessage1 = _initQueueMessage("Contact", result[0]._soupEntryId, null);
                        expectQueueMessage1.action = SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_INSERT;
                        var expectQueueMessage2 = _initQueueMessage("Contact", result[1]._soupEntryId, null);
                        expectQueueMessage2.action = SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_INSERT;
                        var sql = "select {_queue:_soup} from {_queue}";
                        sql += " where {_queue:objectName} = 'Contact' and {_queue:recordSoupEntryId} in (" + result[0]._soupEntryId + ", " + result[1]._soupEntryId + ")";
                        var querySpec = navigator.smartstore.buildSmartQuerySpec(sql);
                        navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                            var queueMessages;
                            cursor && cursor.currentPageOrderedEntries && (queueMessages = cursor.currentPageOrderedEntries), innerResolve([result[0]._soupEntryId, result[1]._soupEntryId])
                        }, function (err) {
                            innerReject("verify queue message error: " + JSON.stringify(err))
                        })
                    }, function (err) {
                        innerReject("test testInsertAction error: " + JSON.stringify(err))
                    })
                })
            })
        };
        var _lookupconfig = [];
        service.getFilterConfigByObjectType = function (objectType) {
            var objectTypeLookupConfig, deferred = $q.defer();
            return _lookupconfig.length ? (objectTypeLookupConfig = getLookupConfig(objectType), deferred.resolve(objectTypeLookupConfig)) : readLookupConfig().then(function () {
                objectTypeLookupConfig = getLookupConfig(objectType), deferred.resolve(objectTypeLookupConfig)
            }), deferred.promise
        }
    }])
}(angular, _), function (angular, _) {
    "use strict";
    angular.module("oinio.core").service("LocalSyncService", ["$injector", "$q", "$log", "$http", "ConfigurationService", "ForceClientService", "LocalCacheService", "APP_SETTINGS", "MetaService", "LocalDataService", "DescribeService", "SMARTSTORE_COMMON_SETTING", "RecordTypeService", "PicklistService", "RestService", "ConnectionMonitor", "SalesforceDataService", "FileService", "SYNC_PAGE_SIZE", "UtilService", function ($injector, $q, $log, $http, ConfigurationService, ForceClientService, LocalCacheService, APP_SETTINGS, MetaService, LocalDataService, DescribeService, SMARTSTORE_COMMON_SETTING, RecordTypeService, PicklistService, RestService, ConnectionMonitor, SalesforceDataService, FileService, SYNC_PAGE_SIZE, UtilService) {
        function _localSyncSynchronizeObjectsPermissions(options) {
            return $q(function (resolve, reject) {
                var objectNames = [];
                if (options && options.objs && options.objs.length && angular.forEach(options.objs, function (localObj) {
                    if (localObj && (objectNames.push(localObj.Name), localObj.MobileVizArt__Lookup_Mod_Stamp__c && localObj.MobileVizArt__Lookup_Mod_Stamp__c.length)) for (var objLookupModStampArr = localObj.MobileVizArt__Lookup_Mod_Stamp__c.split(","), i = 0; i < objLookupModStampArr.length; i++) {
                        var lookupFieldName = objLookupModStampArr[i];
                        if (lookupFieldName.indexOf(".") > -1) for (var cascadeFields = lookupFieldName.split("."), j = 0; j < cascadeFields.length - 1; j++) {
                            var objName = cascadeFields[j];
                            _.endsWith(objName, "__r") && (objName = objName.substring(0, objName.length - 1) + "c"), objectNames.indexOf(objName) === -1 && objectNames.push(objName)
                        } else objectNames.indexOf(lookupFieldName) === -1 && objectNames.push(lookupFieldName)
                    }
                }), objectNames.length && options.userId && options.profileId) {
                    var postBody = {userId: options.userId, profileId: options.profileId, objectNames: objectNames};
                    RestService.getObjectPermissions(postBody).then(function (response) {
                        var objectPermissions = {}, objectHasReadPermissions = [];
                        response && "list_ObjectPermission" in response && response.list_ObjectPermission.length > 0 && angular.forEach(response.list_ObjectPermission, function (item) {
                            objectPermissions[item.SobjectType] = item, item.PermissionsRead === !0 && objectHasReadPermissions.indexOf(item.SobjectType) === -1 && objectHasReadPermissions.push(item.SobjectType)
                        }), MetaService.setMetaValue("objectPermissions", objectPermissions).then(function () {
                            resolve(objectHasReadPermissions)
                        }, reject)
                    }, reject)
                } else resolve([])
            })
        }

        function _updateObjectFilterCriteria(objects) {
            return $q(function (resolve, reject) {
                var objectSoupIds = [];
                objects && objects.length && angular.forEach(objects, function (obj) {
                    obj._soupEntryId && objectSoupIds.indexOf(obj._soupEntryId) === -1 && objectSoupIds.push(obj._soupEntryId)
                });
                var query = "select {_object:_soupEntryId}, {_object:_soup} from {_object} where {_object:_soupEntryId} in (" + objectSoupIds.join(",") + ") ",
                    querySpec = navigator.smartstore.buildSmartQuerySpec(query, 200);
                navigator.smartstore.runSmartQuery(querySpec, function (queryCursor) {
                    if (queryCursor && queryCursor.currentPageOrderedEntries && queryCursor.currentPageOrderedEntries.length > 0) {
                        var objects2upsert = [];
                        RestService.getFilterCriteria().then(function (filterCriteria) {
                            if ($log.debug(filterCriteria), filterCriteria && filterCriteria.filterCriterias && filterCriteria.filterCriterias.length) {
                                var _filterCriteriasMap = {};
                                angular.forEach(filterCriteria.filterCriterias, function (item) {
                                    item.objName && (_filterCriteriasMap[item.objName] = item.filterCriteria)
                                }), angular.forEach(queryCursor.currentPageOrderedEntries, function (item) {
                                    var localObj = item[1];
                                    _filterCriteriasMap[localObj.Name] && localObj.MobileVizArt__Filter_Criteria__c !== _filterCriteriasMap[localObj.Name] && (localObj.MobileVizArt__Filter_Criteria__c = _filterCriteriasMap[localObj.Name], localObj._soupEntryId = item[0], objects2upsert.push(localObj))
                                }), objects2upsert.length ? navigator.smartstore.upsertSoupEntries("_object", objects2upsert, function (result) {
                                    $log.debug("finished update object filter criteria."), resolve(!0)
                                }, function (err) {
                                    $log.debug("update object filter criteria error", err), reject(err)
                                }) : resolve(!0)
                            } else resolve(!0)
                        }, reject)
                    } else resolve(!0), $log.debug("No records returned by query: ", query)
                }, function (err) {
                    $log.debug("query local object with " + querySpec + " error", err), reject(err)
                })
            })
        }

        function _linkObjectsMulti(objectName, specifiedSoupEntryIds, references, updateAll) {
            function queryPaging(cursor) {
                function _closeCursor(cs, cb) {
                    navigator.smartstore.closeCursor(cs, function (result) {
                        cb(null)
                    }, function (err) {
                        cb(err)
                    })
                }

                if (cursor && cursor.currentPageOrderedEntries && cursor.currentPageOrderedEntries.length > 0) {
                    for (var referencedSFDCIdMap = {}, i = 0; i < cursor.currentPageOrderedEntries.length; i++) for (var __item = cursor.currentPageOrderedEntries[i], objectSoup = __item[1], j = 0; j < references.length; j++) {
                        var ref = references[j], refObjName = ref.referencedObject;
                        referencedSFDCIdMap[refObjName] || (referencedSFDCIdMap[refObjName] = []);
                        for (var k = 0; k < ref.fields.length; k++) {
                            var refId = objectSoup[ref.fields[k]];
                            refId && referencedSFDCIdMap[refObjName].indexOf(refId) === -1 && referencedSFDCIdMap[refObjName].push(refId)
                        }
                    }
                    var collectRefPromises = [];
                    for (var refObjNameINMap in referencedSFDCIdMap) referencedSFDCIdMap.hasOwnProperty(refObjNameINMap) && referencedSFDCIdMap[refObjNameINMap].length && !function (refObjNameINMap) {
                        collectRefPromises.push($q(function (resolve, reject) {
                            var joinSep = "', '",
                                innerQuery = " select {" + refObjNameINMap + ":_soupEntryId}, {" + refObjNameINMap + ":Id} from {" + refObjNameINMap + "} ";
                            innerQuery += " where {" + refObjNameINMap + ":Id} in ('" + referencedSFDCIdMap[refObjNameINMap].join(joinSep) + "') ", innerQuery += " order by {" + refObjNameINMap + ":_soupEntryId} asc";
                            var innerQuerySpec = navigator.smartstore.buildSmartQuerySpec(innerQuery, pageSize);
                            navigator.smartstore.runSmartQuery(innerQuerySpec, function (innerQueryCursor) {
                                innerQueryCursor && innerQueryCursor.currentPageOrderedEntries && innerQueryCursor.currentPageOrderedEntries.length > 0 && angular.forEach(innerQueryCursor.currentPageOrderedEntries, function (item) {
                                    sfdc2SoupIdMap[item[1]] = {_soupEntryId: item[0], objectName: refObjNameINMap}
                                }), _closeCursor(innerQueryCursor, function (err) {
                                    err ? reject(err) : resolve(sfdc2SoupIdMap)
                                })
                            }, reject)
                        }))
                    }(refObjNameINMap);
                    $q.all(collectRefPromises).then(function () {
                        for (var upsertObjects = [], i = 0; i < cursor.currentPageOrderedEntries.length; i++) {
                            var __item = cursor.currentPageOrderedEntries[i], objectSoup = __item[1];
                            objectSoup._soupEntryId = __item[0];
                            for (var j = 0; j < references.length; j++) {
                                var ref = references[j], refObjName = ref.referencedObject;
                                referencedSFDCIdMap[refObjName] || (referencedSFDCIdMap[refObjName] = []);
                                for (var k = 0; k < ref.fields.length; k++) {
                                    var fieldName = ref.fields[k], refSFDCId = objectSoup[fieldName],
                                        refSoupEntry = sfdc2SoupIdMap[refSFDCId];
                                    refSoupEntry && refSoupEntry.objectName == refObjName && (objectSoup[fieldName + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_EXTENSION_SUFFIX] = refSoupEntry._soupEntryId, objectSoup[fieldName + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_TYPE_SUFFIX] = refObjName)
                                }
                            }
                            upsertObjects.push(objectSoup)
                        }
                        deferred.notify({
                            total: cursor.totalEntries,
                            size: cursor.currentPageOrderedEntries.length,
                            objectName: objectName
                        }), upsertObjects.length ? navigator.smartstore.upsertSoupEntries(objectName, upsertObjects, function (result) {
                            if (cursor.currentPageIndex < cursor.totalPages - 1) {
                                cursor.currentPageIndex + 1;
                                navigator.smartstore.moveCursorToNextPage(cursor, queryPaging, function (err) {
                                    deferred.reject(err)
                                })
                            } else _closeCursor(cursor, function (err) {
                                err ? deferred.reject(err) : deferred.resolve(!0)
                            })
                        }, function (err) {
                            _closeCursor(cursor, function (err) {
                                err ? deferred.reject(err) : deferred.resolve(!0)
                            }), deferred.reject(err)
                        }) : deferred.resolve(!0)
                    }, function (error) {
                        deferred.reject(error)
                    })
                } else _closeCursor(cursor, function (err) {
                    err ? deferred.reject(err) : deferred.resolve(!0)
                })
            }

            var deferred = $q.defer(), pageSize = SYNC_PAGE_SIZE.REBUILD_REFERENCE, sfdc2SoupIdMap = {},
                whereString = " where ";
            if (!updateAll) for (var i = 0; i < references.length; i++) for (var j = 0; j < references[i].fields.length; j++) updateAll || (whereString += " ({" + objectName + ":" + references[i].fields[j] + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_EXTENSION_SUFFIX + "} is null) or");
            var query = "select {" + objectName + ":_soupEntryId}, {" + objectName + ":_soup} from {" + objectName + "} ";
            _.endsWith(whereString, "or") && (whereString = whereString.substring(0, whereString.length - 2)), specifiedSoupEntryIds && specifiedSoupEntryIds.length && (whereString += "where" === whereString.trim() ? " {" + objectName + ":_soupEntryId} in (" + specifiedSoupEntryIds.join(",") + ")" : " and {" + objectName + ":_soupEntryId} in (" + specifiedSoupEntryIds.join(",") + ")"), "where" !== whereString.trim() && (query += whereString), query += " order by {" + objectName + ":_soupEntryId} asc";
            var querySpec = navigator.smartstore.buildSmartQuerySpec(query, pageSize);
            return navigator.smartstore.runSmartQuery(querySpec, queryPaging, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }

        function queryQueuedRecords(sObjectName, queuedRecordIds) {
            var deferred = $q.defer(), perSize = 1e3, result = [], perQuery = function (arr) {
                var smartSql = "select {" + sObjectName + ":_soup} from {" + sObjectName + "} where {" + sObjectName + ":_soupEntryId} in (" + queuedRecordIds.splice(0, perSize).join(",") + ")",
                    querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
                navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                    result = result.concat(cursor.currentPageOrderedEntries), arr.length > 0 ? perQuery(arr) : deferred.resolve(_.pluck(result, "0"))
                }, function (error) {
                    deferred.reject(error)
                })
            };
            return perQuery(queuedRecordIds), deferred.promise
        }

        var service = this, Exception = $injector.get("Exception"),
            EXCEPTION_SEVERITY = $injector.get("EXCEPTION_SEVERITY"),
            isSyncingUp = ($injector.get("PROCESS_CODE"), $injector.get("STATUS_CODE"), !1),
            skipSyncDownObjects = ["Attachment", "Note", "Task", "Event", "ContentDocument", "ContentVersion", "ContentDocumentLink"],
            skipCleanUpObjects = ["Attachment", "Note", "Task", "Event", "ContentDocument", "ContentVersion", "ContentDocumentLink"];
        service.resetUpSyncFlag = function () {
            isSyncingUp = !1
        }, service.syncMobileConfiguration = function () {
            var deferred = $q.defer();
            return APP_SETTINGS.LOCAL_CONFIGURATION === !0 ? $http.get(APP_SETTINGS.LOCAL_CONFIGURATION_FILE).then(function (configurationContent) {
                var configurationData = configurationContent.data;
                if (configurationData.objects) for (var i = 0; i < configurationData.objects.length; i++) {
                    var configObj = configurationData.objects[i];
                    configObj.MobileVizArt__Fields__c && (configObj.MobileVizArt__Fields__c = configObj.MobileVizArt__Fields__c.replace(new RegExp(/\s/g), "")), configObj.MobileVizArt__Search_Fields__c && (configObj.MobileVizArt__Search_Fields__c = configObj.MobileVizArt__Search_Fields__c.replace(new RegExp(/\s/g), "")), configObj.MobileVizArt__List_Content_Fields__c && (configObj.MobileVizArt__List_Content_Fields__c = configObj.MobileVizArt__List_Content_Fields__c.replace(new RegExp(/\s/g), ""))
                }
                navigator.smartstore.upsertSoupEntriesWithExternalId("_configuration", [configurationData], "Name", function (upsertedRecords) {
                    service.syncConfiguredObjectsMeta().then(function (done) {
                        deferred.resolve(done)
                    }, function (err) {
                        deferred.reject(err)
                    })
                }, function (err) {
                    deferred.reject(err)
                })
            }, function (error) {
                deferred.reject(error)
            }) : service.prepareMobileConfigurationForSync().then(function (objectSyncWrapper) {
                var configurationObjectNames = [];
                angular.forEach(objectSyncWrapper.syncDownObjects.objectTypes, function (obj) {
                    configurationObjectNames.push(obj.name)
                }), MetaService.initializeMetaDataForObjectTypes(configurationObjectNames).then(function () {
                    service.startSync(objectSyncWrapper).then(function (objectSyncResult) {
                        service.syncConfiguredObjectsMeta(objectSyncWrapper).then(function (done) {
                            deferred.resolve(objectSyncResult)
                        }, function (err) {
                            deferred.reject(err)
                        })
                    }, function (err) {
                        deferred.reject(err)
                    })
                }, function (err) {
                    deferred.reject(err)
                })
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, service.syncConfiguredObjectsMeta = function (objectSyncWrapper) {
            var configuration, describeSObjectResults, deferred = $q.defer(),
                _currentUser = LocalCacheService.get("currentUser"), objectTypeNames = [];
            return LocalDataService.queryConfigurationAndObjects(_currentUser.ProfileId).then(function (config) {
                return configuration = config, _updateObjectFilterCriteria(configuration.objects)
            }).then(function () {
                for (var i = 0; i < configuration.objects.length; i++) objectTypeNames.push(configuration.objects[i].Name);
                return _localSyncSynchronizeObjectsPermissions({
                    objs: configuration.objects,
                    profileId: _currentUser.ProfileId,
                    userId: _currentUser.Id
                })
            }).then(function (objectHasReadPermissions) {
                var filteredObjectTypeNames = [];
                if (objectHasReadPermissions && objectHasReadPermissions.length) {
                    for (var i = 0; i < objectTypeNames.length; i++) {
                        var objectName = objectTypeNames[i];
                        objectHasReadPermissions.indexOf(objectName) > -1 && filteredObjectTypeNames.indexOf(objectName) === -1 && filteredObjectTypeNames.push(objectName)
                    }
                    return DescribeService.loadDescribeSObjects(filteredObjectTypeNames)
                }
                return $q.reject("no object permissions")
            }).then(function (describeResults) {
                describeSObjectResults = describeResults;
                for (var allRecordTypes = [], rt = 0; rt < configuration.objects.length; rt++) configuration.objects[rt].MobileVizArt__All_RecordTypes__c && configuration.objects[rt].MobileVizArt__All_RecordTypes__c === !0 && allRecordTypes.push(configuration.objects[rt].Name);
                return syncRecordTypes(describeSObjectResults, allRecordTypes)
            }).then(function () {
                return DescribeService.loadDescribeLayouts(describeSObjectResults)
            }).then(function (describeLayoutResults) {
                return PicklistService.loadAllPicklists(describeLayoutResults)
            }).then(function () {
                deferred.resolve(!0)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.syncForLanguageChange = function () {
            var objectPermissions, configuration, describeSObjectResults, deferred = $q.defer(),
                handleError = function (error) {
                    error && "function" == typeof error.handle ? (error.retry = service.syncForLanguageChange, error.deferred = deferred, error.handle()) : new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, error.message, error.stack, error, service.syncForLanguageChange, null, null, null, deferred).handle(), deferred.reject(error)
                };
            return MetaService.getMetaValue("objectPermissions").then(function (permissions) {
                objectPermissions = permissions;
                var _currentUser = LocalCacheService.get("currentUser");
                return LocalDataService.queryConfigurationAndObjects(_currentUser.ProfileId)
            }).then(function (config) {
                configuration = config;
                var filteredObjectTypeNames = [];
                for (var obj in objectPermissions) objectPermissions.hasOwnProperty(obj) && objectPermissions[obj].PermissionsRead === !0 && filteredObjectTypeNames.push(obj);
                return DescribeService.loadDescribeSObjects(filteredObjectTypeNames, !0)
            }).then(function (describeResults) {
                describeSObjectResults = describeResults;
                for (var allRecordTypes = [], rt = 0; rt < configuration.objects.length; rt++) configuration.objects[rt].MobileVizArt__All_RecordTypes__c && configuration.objects[rt].MobileVizArt__All_RecordTypes__c === !0 && allRecordTypes.push(configuration.objects[rt].Name);
                return syncRecordTypes(describeSObjectResults, allRecordTypes)
            }).then(function () {
                return DescribeService.loadDescribeLayouts(describeSObjectResults)
            }).then(function (describeLayoutResults) {
                return PicklistService.loadAllPicklists(describeLayoutResults)
            }).then(function (result) {
                if (APP_SETTINGS.ENABLE_ONLINE_TRANSLATION) return $injector.get("TranslationService").loadCustomLabels()
            }).then(function () {
                deferred.resolve(!0)
            }, function (err) {
                handleError(err)
            }), deferred.promise
        };
        var syncRecordTypes = function (describeSObjectResults, allRecordTypes) {
            for (var deferred = $q.defer(), promises = [], recordTypeIds = [], dummyRecordTypeSobjectTypes = [], i = 0; i < describeSObjectResults.length; i++) for (var describeSObjectResult = describeSObjectResults[i], j = 0; j < describeSObjectResult.recordTypeInfos.length; j++) {
                var recordTypeInfo = describeSObjectResult.recordTypeInfos[j];
                if ((recordTypeInfo.available === !0 || allRecordTypes && allRecordTypes.indexOf(describeSObjectResult.name) !== -1) && recordTypeIds.indexOf(recordTypeInfo.recordTypeId) === -1) {
                    var recordTypeId = recordTypeInfo.recordTypeId;
                    "012000000000000AAA" === recordTypeId && dummyRecordTypeSobjectTypes.indexOf(describeSObjectResult.name) === -1 ? dummyRecordTypeSobjectTypes.push(describeSObjectResult.name) : recordTypeIds.push(recordTypeId)
                }
            }
            return recordTypeIds.length > 0 && promises.push(RecordTypeService.syncDownAllRecordType(recordTypeIds)), dummyRecordTypeSobjectTypes.length > 0 && promises.push(RecordTypeService.storeDummyRecordType(dummyRecordTypeSobjectTypes)), $q.all(promises).then(function () {
                deferred.resolve(!0)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        service.syncBusinessSObjects = function (option) {
            var deferred = $q.defer(), handleError = function (error) {
                error && "function" == typeof error.handle ? (error.retry = service.syncBusinessSObjects, error.retryContext = service, error.retryParam = [option], error.retryDeferred = deferred, error.handle()) : new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, error.message, error.stack, error, service.syncBusinessSObjects, null, service, [option], deferred).handle(), deferred.reject(error)
            };
            return service.prepareBusinessObjectTypeForSync().then(function (objectSyncWrapper) {
                option && option.appInitialized === !1 && (objectSyncWrapper.syncUpObjects.objectTypes = [], objectSyncWrapper.cleanUpObjects.objectTypes = [], angular.forEach(objectSyncWrapper.syncDownObjects.objectTypes, function (objType) {
                    objType.queryAll = !1
                })), option && option.forceCleanup === !0 && (objectSyncWrapper.cleanUpObjects.forceCleanup = !0), service.startSync(objectSyncWrapper).then(function (result) {
                    deferred.resolve(result)
                }, function (error) {
                    handleError(error)
                }, function (process) {
                    deferred.notify(process)
                })
            }, function (error) {
                handleError(error)
            }), deferred.promise
        }, service.startSync = function (objectSyncWrapper) {
            var deferred = $q.defer();
            return $log.debug(">>>> start sync process beginning."), service.startSyncUpObjects(objectSyncWrapper).then(function (objectSyncResult) {
                $log.debug(">>>> sync up ended, start to sync down."), deferred.notify(objectSyncResult), service.startSyncDownObjects(objectSyncWrapper).then(function (objectSyncResult) {
                    $log.debug(">>>> sync down ended, start to clean up."), deferred.notify(objectSyncResult), service.startCleanUpObjects(objectSyncWrapper).then(function (objectSyncResult) {
                        $log.debug(">>>> clean up ended, start sync down file data."), deferred.notify(objectSyncResult), service.startSyncDownFileData().then(function () {
                            $log.debug(">>>> start sync down attachment data."), service.startSyncDownAttachmentBody().then(function () {
                                $log.debug(">>>> start rebuild reference."), service.startRebuildLocalReferenceForObjects(objectSyncWrapper).then(function (objectSyncResult) {
                                    $log.debug(">>>> rebuild reference ended, finished all sync process."), deferred.resolve(objectSyncResult)
                                }, function (error) {
                                    deferred.reject(error)
                                }, function (process) {
                                    deferred.notify(process)
                                })
                            }, function (error) {
                                deferred.reject(error)
                            }, function (process) {
                            })
                        }, function (error) {
                            deferred.reject(error)
                        }, function (process) {
                        })
                    }, function (error) {
                        deferred.reject(error)
                    }, function (process) {
                        deferred.notify(process)
                    })
                }, function (error) {
                    deferred.reject(error)
                }, function (process) {
                    deferred.notify(process)
                })
            }, function (error) {
                deferred.reject(error)
            }, function (process) {
                deferred.notify(process)
            }), deferred.promise
        }, service.rebuildObjectRecordsLocalRef = function (objects2rebuild, updateAll) {
            var objs2rebuild = [];
            if (objects2rebuild) for (var k in objects2rebuild) objects2rebuild.hasOwnProperty(k) && objs2rebuild.indexOf(k) === -1 && objs2rebuild.push(k);
            var deferred = $q.defer(), currentUser = LocalCacheService.get("currentUser");
            currentUser || deferred.reject("Failed to get current user information");
            var profileId = currentUser.ProfileId;
            return LocalDataService.queryConfigurationAndObjects(profileId).then(function (configuration) {
                function _isActiveObject(obj) {
                    return obj && obj.Name && obj.MobileVizArt__Active__c === !0
                }

                var checkSoupExistPromises = [], collectReferencePromises = [], linkObjectArr = [];
                LocalDataService.getConfiguredObjectNames().then(function (syncedObjects) {
                    angular.forEach(configuration.objects, function (obj) {
                        checkSoupExistPromises.push($q(function (resolve, reject) {
                            $injector.get("SmartStoreService").checkSoupExist(obj.Name).then(function (exist) {
                                var isCurrentObjShouldBeRebuild = _isActiveObject(obj) && (!objs2rebuild.length || objs2rebuild.length && objs2rebuild.indexOf(obj.Name) > -1);
                                if (exist && isCurrentObjShouldBeRebuild) {
                                    var specifiedSoupEntryIds = [];
                                    objects2rebuild && objects2rebuild[obj.Name] && objects2rebuild[obj.Name].length && (specifiedSoupEntryIds = objects2rebuild[obj.Name]);
                                    var linkObjectItem = {
                                            objectName: obj.Name,
                                            references: [],
                                            updateAll: updateAll,
                                            specifiedSoupEntryIds: specifiedSoupEntryIds
                                        },
                                        collectReferencePromise = LocalDataService.getFieldInformations(obj.Name).then(function (fields) {
                                            var referedEntity = {};
                                            angular.forEach(fields, function (field) {
                                                if ("reference" === field.type) for (var fieldReferTo = field.referenceTo, fieldName = field.name, i = 0; i < fieldReferTo.length; i++) {
                                                    var referedToObjectName = fieldReferTo[i];
                                                    syncedObjects.indexOf(referedToObjectName) > -1 && (referedEntity[referedToObjectName] || (referedEntity[referedToObjectName] = [fieldName]), referedEntity[referedToObjectName].indexOf(fieldName) === -1 && referedEntity[referedToObjectName].push(fieldName))
                                                }
                                            });
                                            for (var k in referedEntity) referedEntity.hasOwnProperty(k) && linkObjectItem.references.push({
                                                referencedObject: k,
                                                fields: referedEntity[k]
                                            });
                                            linkObjectItem.references.length && linkObjectArr.push(linkObjectItem)
                                        });
                                    collectReferencePromises.push(collectReferencePromise)
                                }
                                resolve()
                            }, function (err) {
                                reject(err)
                            })
                        }))
                    }), $q.all(checkSoupExistPromises).then(function () {
                        $q.all(collectReferencePromises).then(function () {
                            function chainFactory(item, theLastAction) {
                                return function () {
                                    return _linkObjectsMulti(item.objectName, item.specifiedSoupEntryIds, item.references, item.updateAll).then(function (isDone) {
                                        theLastAction && deferred.resolve(!0)
                                    }, function (err) {
                                        deferred.reject(err)
                                    }, function (notify) {
                                        deferred.notify(notify)
                                    })
                                }
                            }

                            if (linkObjectArr.length) {
                                var chain = $q.when();
                                angular.forEach(linkObjectArr, function (item, index) {
                                    chain = chain.then(chainFactory(item, index === linkObjectArr.length - 1))
                                })
                            } else deferred.resolve(!0)
                        }, function (error) {
                            deferred.reject(error)
                        })
                    }, function (err) {
                        deferred.reject(err)
                    })
                }, function (err) {
                    deferred.reject(err)
                })
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, service.startSyncDownObjects = function (objectSyncWrapper) {
            var deferred = $q.defer();
            return checkObjectTypesBeforeSynchronize(objectSyncWrapper).then(function () {
                return objectSyncWrapper.syncDownObjects && 0 !== objectSyncWrapper.syncDownObjects.objectTypes.length ? void RestService.getServerTimestamp().then(function (serverTimestamp) {
                    serverTimestamp && angular.forEach(objectSyncWrapper.syncDownObjects.objectTypes, function (item) {
                        item._serverTimestamp = serverTimestamp
                    });
                    var syncSequential = function (index) {
                        if (index >= objectSyncWrapper.syncDownObjects.objectTypes.length) deferred.resolve(objectSyncWrapper); else {
                            var objType = objectSyncWrapper.syncDownObjects.objectTypes[index];
                            service.syncDownObjectRecords(objType).then(function (done) {
                                if (void 0 !== objType && skipSyncDownObjects.indexOf(objType.name) === -1) {
                                    var progressObj = objectSyncWrapper.syncDownObjects.syncProgress[objType.name];
                                    objectSyncWrapper.progress = progressObj, objectSyncWrapper.progress.status.processed += done.records, objectSyncWrapper.progress.status.total = done.total, objectSyncWrapper.progress.status.done = !0, deferred.notify(objectSyncWrapper)
                                }
                                if (done.subsidiaryRecords && done.subsidiaryRecords.length > 0) for (var i = 0; i < done.subsidiaryRecords.length; i++) {
                                    var subProcessStatus = done.subsidiaryRecords[i];
                                    if ("File" === subProcessStatus.objectName) {
                                        var notifyRelatedObject = function (fileRelatedObject) {
                                            var subProgressObj = objectSyncWrapper.syncDownObjects.syncProgress[fileRelatedObject];
                                            objectSyncWrapper.progress = subProgressObj, subProgressObj.status = {
                                                done: !0,
                                                total: subProgressObj.status.total + subProcessStatus["recordsOf" + fileRelatedObject],
                                                processed: subProgressObj.status.processed + subProcessStatus["recordsOf" + fileRelatedObject]
                                            }, deferred.notify(objectSyncWrapper)
                                        };
                                        notifyRelatedObject("ContentDocument"), notifyRelatedObject("ContentVersion"), notifyRelatedObject("ContentDocumentLink")
                                    } else {
                                        var subProgressObj = objectSyncWrapper.syncDownObjects.syncProgress[subProcessStatus.objectName];
                                        objectSyncWrapper.progress = subProgressObj, subProgressObj.status = {
                                            done: !0,
                                            total: subProgressObj.status.total + subProcessStatus.records,
                                            processed: subProgressObj.status.processed + subProcessStatus.records
                                        }, deferred.notify(objectSyncWrapper)
                                    }
                                }
                                syncSequential(index + 1)
                            }, function (error) {
                                deferred.reject(error)
                            }, function (notify) {
                                var progressObj = objectSyncWrapper.syncDownObjects.syncProgress[objType.name];
                                objectSyncWrapper.progress = progressObj, objectSyncWrapper.progress.status.processed += notify.records, objectSyncWrapper.progress.status.total = notify.total, deferred.notify(objectSyncWrapper)
                            })
                        }
                    };
                    syncSequential(0)
                }, function (err) {
                    deferred.reject(err)
                }) : (deferred.resolve(objectSyncWrapper), deferred.promise)
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, service.startSyncUpObjects = function (objectSyncWrapper) {
            var deferred = $q.defer();
            return objectSyncWrapper.syncUpObjects && 0 !== objectSyncWrapper.syncUpObjects.objectTypes.length ? (isSyncingUp ? (angular.forEach(objectSyncWrapper.syncUpObjects.objectTypes, function (objType, index) {
                objectSyncWrapper.syncUpObjects.syncProgress[objType.name].status.done = !0
            }), deferred.resolve(objectSyncWrapper)) : (isSyncingUp = !0, RestService.getServerTimestamp().then(function (serverTimestamp) {
                serverTimestamp && angular.forEach(objectSyncWrapper.syncUpObjects.objectTypes, function (item) {
                    item._serverTimestamp = serverTimestamp
                });
                var syncSequential = function (index) {
                    if (index >= objectSyncWrapper.syncUpObjects.objectTypes.length) deferred.resolve(objectSyncWrapper), isSyncingUp = !1; else {
                        var objType = objectSyncWrapper.syncUpObjects.objectTypes[index];
                        service.syncUpObjectRecords(objType).then(function (done) {
                            var progressObj = objectSyncWrapper.syncUpObjects.syncProgress[objType.name];
                            done.operationType === SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_INSERT ? (progressObj.status.inserted = done.processed, progressObj.status.insertFailed = done.failed, progressObj.status.insertTotal = done.total) : done.operationType === SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_UPDATE ? (progressObj.status.updated = done.processed, progressObj.status.updateFailed = done.failed, progressObj.status.updateTotal = done.total) : done.operationType === SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_DELETE && (progressObj.status.deleted = done.processed, progressObj.status.deleteFailed = done.failed, progressObj.status.deleteTotal = done.total), progressObj.status.done = !0, deferred.notify(objectSyncWrapper), syncSequential(index + 1)
                        }, function (error) {
                            isSyncingUp = !1, deferred.reject(error)
                        }, function (notify) {
                            var progressObj = objectSyncWrapper.syncUpObjects.syncProgress[objType.name];
                            notify.operationType === SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_INSERT ? (progressObj.status.inserted = notify.processed, progressObj.status.insertFailed = notify.failed, progressObj.status.insertTotal = notify.total) : notify.operationType === SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_UPDATE ? (progressObj.status.updated = notify.processed, progressObj.status.updateFailed = notify.failed, progressObj.status.updateTotal = notify.total) : notify.operationType === SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_DELETE && (progressObj.status.deleted = notify.processed, progressObj.status.deleteFailed = notify.failed, progressObj.status.deleteTotal = notify.total), objType.syncUpSoupEntryIds = objType.syncUpSoupEntryIds || [], notify.successSoupEntryIds && (objType.syncUpSoupEntryIds = objType.syncUpSoupEntryIds.concat(notify.successSoupEntryIds)), deferred.notify(objectSyncWrapper)
                        })
                    }
                };
                syncSequential(0)
            }, function (error) {
                isSyncingUp = !1, deferred.reject(error)
            })), deferred.promise) : (deferred.resolve(objectSyncWrapper), deferred.promise)
        }, service.syncDownObjectRecords = function (objectType) {
            var deferred = $q.defer(), syncSubObjectRecords = function (parentStatus) {
                service.syncDownObjectSubsidiaryRecords(objectType).then(function (subDone) {
                    var processStatus = angular.copy(parentStatus);
                    processStatus.records = 0, processStatus.subsidiaryRecords = subDone, MetaService.updateLastSyncDownDate(objectType.name, objectType._serverTimestamp || (new Date).toISOString()).then(function () {
                        deferred.resolve(processStatus)
                    }, function (error) {
                        deferred.reject(error)
                    })
                }, deferred.reject)
            };
            return void 0 !== objectType && skipSyncDownObjects.indexOf(objectType.name) === -1 ? MetaService.getObjectMetaByType(objectType.name).then(function (objMeta) {
                if (objMeta && objMeta.lastSyncDownDate && (objectType.lastSyncDownDate = objMeta.lastSyncDownDate), objectType.needSyncDown === !1) {
                    var result = {total: 0, records: 0};
                    deferred.notify(result), syncSubObjectRecords(result)
                } else synchronizeFromSFDC(objectType).then(function (done) {
                    deferred.notify(done), syncSubObjectRecords(done)
                }, deferred.reject, function (progress) {
                    deferred.notify(progress)
                })
            }, deferred.reject) : deferred.resolve({total: 0, records: 0}), deferred.promise
        }, service.syncDownObjectSubsidiaryRecords = function (param) {
            var objectName = param.name, lastSyncDownDate = param.lastSyncDownDate,
                serverTimestamp = param._serverTimestamp, deferred = $q.defer(), promises = [];
            return LocalDataService.queryConfiguredObjectByName(objectName).then(function (objectType) {
                if (objectType.MobileVizArt__Enable_NotesAndAttachments__c || objectType.MobileVizArt__Enable_Activity__c || objectType.MobileVizArt__Enable_File__c) {
                    var queryStr = generateSoqlForObject(param, "Id");
                    objectType.MobileVizArt__Enable_NotesAndAttachments__c && (promises.push(syncDownSubsidiaryRecords(objectType, "Attachment", queryStr, lastSyncDownDate, serverTimestamp)), promises.push(syncDownSubsidiaryRecords(objectType, "Note", queryStr, lastSyncDownDate, serverTimestamp))), objectType.MobileVizArt__Enable_Activity__c && (promises.push(syncDownSubsidiaryRecords(objectType, "Task", queryStr, lastSyncDownDate, serverTimestamp)), promises.push(syncDownSubsidiaryRecords(objectType, "Event", queryStr, lastSyncDownDate, serverTimestamp))), objectType.MobileVizArt__Enable_File__c && promises.push(syncDownSubsidiaryFileRecords(objectType, queryStr, lastSyncDownDate, serverTimestamp)), $q.all(promises).then(function (syncProcess) {
                        deferred.resolve(syncProcess)
                    }, deferred.reject)
                } else deferred.resolve([])
            }, deferred.reject), deferred.promise
        };
        var syncDownSubsidiaryRecords = function (objectType, subsidiaryObjectName, queryStr, lastSyncDownDate, serverTimestamp) {
                var deferred = $q.defer();
                return ConfigurationService.getBusinessObjectTypeByName(subsidiaryObjectName).then(function (subsidiaryObjectType) {
                    subsidiaryObjectType ? (subsidiaryObjectType.lastSyncDownDate = lastSyncDownDate, subsidiaryObjectType._serverTimestamp = serverTimestamp, generateSoqlForSyncDown(subsidiaryObjectType).then(function (soql) {
                        soql += soql.toLowerCase().indexOf(" where ") === -1 ? " WHERE " : " AND ", soql += "Attachment" === subsidiaryObjectName || "Note" === subsidiaryObjectName ? "ParentId IN (" + queryStr + ")" : "Contact" === objectType.Name || "Lead" === objectType.Name ? "WhoId IN (" + queryStr + ")" : "WhatId IN (" + queryStr + ")", SalesforceDataService.queryAll(soql, !0).then(function (result) {
                            for (var records2Upsert = [], recordIds2Delete = [], defaultBodySyncOnDemand = void 0 === objectType.MobileVizArt__Attachment_On_Demand__c || null === objectType.MobileVizArt__Attachment_On_Demand__c || objectType.MobileVizArt__Attachment_On_Demand__c, remainProperties = "Attachment" === subsidiaryObjectName ? ["_bodySynced", "_bodySyncOnDemand"] : void 0, i = 0; i < result.length; i++) {
                                var item = result[i];
                                item.IsDeleted === !0 ? recordIds2Delete.push(item.Id) : ("Attachment" === subsidiaryObjectName && (item._bodySynced = !1, item._bodySyncOnDemand = defaultBodySyncOnDemand, item.ParentId_type = objectType.Name), records2Upsert.push(item))
                            }
                            _localSyncRemoveFromSoup(subsidiaryObjectName, recordIds2Delete).then(function (removeDone) {
                                _localSyncUpsertSoupEntriesWithExternalId(subsidiaryObjectName, records2Upsert, remainProperties).then(function () {
                                    deferred.resolve({objectName: subsidiaryObjectName, records: result.length})
                                }, deferred.reject)
                            }, deferred.reject)
                        }, deferred.reject)
                    }, deferred.reject)) : deferred.reject("SyncDownSubsidiaryRecords not found " + subsidiaryObjectName + " configuration.")
                }, deferred.reject), deferred.promise
            }, syncDownSubsidiaryFileRecords = function (linkedObjectType, queryStr, lastSyncDownDate, serverTimestamp) {
                var deferred = $q.defer(), objectName = "ContentDocumentLink";
                return ConfigurationService.getBusinessObjectTypeByName(objectName).then(function (contentDocumentLinkType) {
                    contentDocumentLinkType ? (contentDocumentLinkType.lastSyncDownDate = lastSyncDownDate, contentDocumentLinkType._serverTimestamp = serverTimestamp, generateSoqlForSyncDown(contentDocumentLinkType).then(function (soql) {
                        soql += soql.toLowerCase().indexOf(" where ") === -1 ? " WHERE " : " AND ", soql += "LinkedEntityId IN (" + queryStr + ")", SalesforceDataService.queryAll(soql, !0).then(function (result) {
                            for (var records2Upsert = [], recordIds2Delete = [], i = 0; i < result.length; i++) {
                                var item = result[i];
                                item.IsDeleted === !0 ? recordIds2Delete.push(item.Id) : (item.LinkedEntityId_type = linkedObjectType.Name, records2Upsert.push(item))
                            }
                            _localSyncRemoveFromSoup(objectName, recordIds2Delete).then(function (removeDone) {
                                _localSyncUpsertSoupEntriesWithExternalId(objectName, records2Upsert).then(function () {
                                    syncDownContentDocumentRecords(linkedObjectType, lastSyncDownDate, serverTimestamp).then(function (upsertedResult) {
                                        deferred.resolve({
                                            objectName: "File",
                                            recordsOfContentDocument: upsertedResult.recordsOfContentDocument,
                                            recordsOfContentVersion: upsertedResult.recordsOfContentVersion,
                                            recordsOfContentDocumentLink: result.length
                                        })
                                    }, function (error) {
                                        deferred.reject(error)
                                    })
                                }, deferred.reject)
                            }, deferred.reject)
                        }, deferred.reject)
                    }, deferred.reject)) : deferred.reject("syncDownSubsidiaryFileRecords not found " + objectName + " configuration.")
                }, function (error) {
                    deferred.reject(error)
                }), deferred.promise
            }, syncDownContentDocumentRecords = function (linkedObjectType, lastSyncDownDate, serverTimestamp) {
                var deferred = $q.defer(), objectName = "ContentDocument";
                return getAllContentDocumentIds(linkedObjectType.Name).then(function (contentDocumentIds) {
                    contentDocumentIds && contentDocumentIds.length > 0 ? ConfigurationService.getBusinessObjectTypeByName(objectName).then(function (contentDocumentType) {
                        contentDocumentType ? (contentDocumentType.lastSyncDownDate = lastSyncDownDate, contentDocumentType._serverTimestamp = serverTimestamp, generateSoqlForSyncDown(contentDocumentType).then(function (soql) {
                            soql += soql.toLowerCase().indexOf(" where ") === -1 ? " WHERE " : " AND ", soql += "Id IN :list_id", service.syncDownRecordsByIds(objectName, contentDocumentIds, null, null, !0, soql).then(function (result) {
                                var upsertedContentDocumentIds = _.pluck(result, "Id");
                                syncDownContentVersionRecords(linkedObjectType, upsertedContentDocumentIds, lastSyncDownDate, serverTimestamp).then(function (contentVersions) {
                                    deferred.resolve({
                                        recordsOfContentDocument: result.length,
                                        recordsOfContentVersion: contentVersions.length
                                    })
                                }, function (error) {
                                    deferred.reject("syncDownContentDocumentRecords error " + JSON.stringify(error))
                                })
                            }, deferred.reject)
                        }, deferred.reject)) : deferred.reject("syncDownContentDocumentRecords not found " + objectName + " configuration.")
                    }, deferred.reject) : deferred.resolve({recordsOfContentDocument: 0, recordsOfContentVersion: 0})
                }, function (error) {
                    deferred.reject(error)
                }), deferred.promise
            },
            syncDownContentVersionRecords = function (linkedObjectType, relatedContentDocumentIds, lastSyncDownDate, serverTimestamp) {
                var deferred = $q.defer(), objectName = "ContentVersion";
                return relatedContentDocumentIds && relatedContentDocumentIds.length > 0 ? ConfigurationService.getBusinessObjectTypeByName(objectName).then(function (contentVersionType) {
                    contentVersionType ? (contentVersionType.lastSyncDownDate = lastSyncDownDate, contentVersionType._serverTimestamp = serverTimestamp, generateSoqlForSyncDown(contentVersionType).then(function (soql) {
                        soql += soql.toLowerCase().indexOf(" where ") === -1 ? " WHERE " : " AND ", soql += "ContentDocumentId IN :list_id ";
                        var defaultVersionDataSyncOnDemand = void 0 === linkedObjectType.MobileVizArt__File_On_Demand__c || null === linkedObjectType.MobileVizArt__File_On_Demand__c || linkedObjectType.MobileVizArt__File_On_Demand__c,
                            extendInfo = {
                                _versionDataSynced: !1,
                                _versionDataSyncOnDemand: defaultVersionDataSyncOnDemand
                            };
                        service.syncDownRecordsByIds(objectName, relatedContentDocumentIds, extendInfo, "_versionDataSynced", !0, soql).then(function (result) {
                            deferred.resolve(result)
                        }, function (error) {
                            deferred.reject("syncDownContentVersionRecords error " + JSON.stringify(error))
                        })
                    }, deferred.reject)) : deferred.reject("syncDownContentVersionRecords not found " + objectName + " configuration.")
                }, deferred.reject) : deferred.resolve([]), deferred.promise
            }, getAllContentDocumentIds = function (linkedEntityType) {
                var deferred = $q.defer(), queryContentDocumentIds = function (filterCriteria) {
                    var smartSql = "select {ContentDocumentLink:ContentDocumentId} from {ContentDocumentLink} where {ContentDocumentLink:Id} is not null";
                    filterCriteria && (smartSql += " and " + filterCriteria);
                    var querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
                    navigator.smartstore.runSmartQuery(!1, querySpec, function (cursor) {
                        deferred.resolve(_.pluck(cursor.currentPageOrderedEntries, "0"))
                    }, function (err) {
                        deferred.reject(err)
                    })
                };
                return linkedEntityType ? DescribeService.getKeyPrefix(linkedEntityType).then(function (linkObjectKeyPrefix) {
                    var filterCondition = "{ContentDocumentLink:LinkedEntityId} LIKE '" + linkObjectKeyPrefix + "%'";
                    queryContentDocumentIds(filterCondition)
                }, function (error) {
                    deferred.reject(error)
                }) : queryContentDocumentIds(), deferred.promise
            }, synchronizeFromSFDC = function (param) {
                var objectType = param.name, nextRecordsUrl = param.nextRecordsUrl, done = param.done,
                    deferred = param.deferred || $q.defer(), forceClient = ForceClientService.getForceClient(),
                    soup = void 0 !== param.targetSoup && "" !== param.targetSoup ? param.targetSoup : objectType,
                    queryAll = void 0 === param.queryAll || param.queryAll, storeData = function (data) {
                        var records2Upsert = [], recordIds2Delete = [];
                        angular.forEach(data.records, function (item) {
                            item.IsDeleted === !0 ? recordIds2Delete.push(item.Id) : records2Upsert.push(item)
                        }), _localSyncRemoveFromSoup(soup, recordIds2Delete).then(function (removeDone) {
                            _localSyncUpsertSoupEntriesWithExternalId(soup, records2Upsert).then(function (upsertDone) {
                                var result = {total: data.totalSize, records: data.records.length};
                                if (data.done === !1) {
                                    var nextParam = {
                                        name: objectType,
                                        targetSoup: param.targetSoup,
                                        nextRecordsUrl: data.nextRecordsUrl,
                                        done: data.done,
                                        deferred: deferred,
                                        queryAll: queryAll
                                    };
                                    deferred.notify(result), synchronizeFromSFDC(nextParam)
                                } else deferred.resolve(result)
                            }, deferred.reject)
                        }, deferred.reject)
                    };
                return nextRecordsUrl ? nextRecordsUrl && !done && forceClient.queryMore(nextRecordsUrl, function (data) {
                    storeData(data)
                }, function (error) {
                    $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject(error)
                }) : generateSoqlForSyncDown(param).then(function (queryStr) {
                    queryAll === !0 ? forceClient.queryAll(queryStr, function (data) {
                        $log.debug(">>>> success in query all"), storeData(data)
                    }, function (error) {
                        $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject(error)
                    }) : forceClient.query(queryStr, function (data) {
                        $log.debug(">>>> success in query"), storeData(data)
                    }, function (error) {
                        $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject(error)
                    })
                }, function (error) {
                    error.method = "local-sync.service::synchronizeFromSFDC->generateSoqlForSyncDown", $log.debug(error), deferred.reject(err)
                }), deferred.promise
            };
        service.startSyncDownFileData = function (contentDocumentSids) {
            var deferred = $q.defer();
            return $injector.get("SmartStoreService").checkSoupExist("ContentVersion").then(function (exist) {
                if (exist) {
                    var utilService = $injector.get("UtilService"), isAndroid = utilService.isAndroidOS(),
                        booleanFalse = 0, booleanTrue = 1;
                    isAndroid && (booleanFalse = "'false'", booleanTrue = "'true'");
                    var smartSql;
                    smartSql = contentDocumentSids && contentDocumentSids.length > 0 ? "select {ContentVersion:_soup} from {ContentVersion} where {ContentVersion:ContentDocumentId_sid} in (" + contentDocumentSids.join(",") + ") and {ContentVersion:IsLatest} = " + booleanTrue + " order by {ContentVersion:ContentDocumentId}, {ContentVersion:VersionNumber} desc" : "select {ContentVersion:_soup} from {ContentVersion} where {ContentVersion:Id} is not null and {ContentVersion:IsLatest} = " + booleanTrue + " and ({ContentVersion:_versionDataSynced} is null or {ContentVersion:_versionDataSynced} = " + booleanFalse + ") and {ContentVersion:_versionDataSyncOnDemand} = " + booleanFalse + " order by {ContentVersion:ContentDocumentId}, {ContentVersion:VersionNumber} desc";
                    var querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
                    navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                        var entries = cursor.currentPageOrderedEntries;
                        if (entries && entries.length > 0) {
                            var contentVersionEntries = _.pluck(entries, 0);
                            syncDownFileData(contentVersionEntries).then(function (success) {
                                deferred.resolve(success)
                            }, function (error) {
                                deferred.reject(error)
                            }, function (process) {
                                deferred.notify(process)
                            })
                        } else deferred.resolve({total: 0, processed: 0, failed: 0})
                    })
                } else deferred.resolve({})
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.cleanUpAllContentDocument = function () {
            var deferred = $q.defer(), objectName = "ContentDocument",
                cleanUpResult = {objectName: objectName, newVisiableRecords: 0, dirtyRecords: 0},
                cleanLocalData = function (idsInLink, sidsInLink) {
                    LocalDataService.getActiveRecordsSidBySoup("ContentDocument").then(function (activeSids) {
                        var smartSql = "select {ContentDocument:_soupEntryId}, {ContentDocument:Id} from {ContentDocument}",
                            querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
                        navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                            for (var entries = cursor.currentPageOrderedEntries, dirtySids = [], cleanedIds = [], cleanedSids = [], i = 0; i < entries.length; i++) {
                                var sid = entries[i][0] + "", id = entries[i][1];
                                sid && sidsInLink.indexOf(sid) === -1 && activeSids.indexOf(parseInt(sid)) === -1 && idsInLink.indexOf(id) === -1 ? dirtySids.push(sid) : (id && cleanedIds.indexOf(id) === -1 && cleanedIds.push(id), cleanedSids.indexOf(sid) === -1 && cleanedSids.push(sid))
                            }
                            clearSubsidiaryRecordsFileData(objectName, dirtySids).then(function () {
                                navigator.smartstore.removeFromSoup(!1, objectName, dirtySids, function () {
                                    cleanUpResult.dirtyRecords = dirtySids.length, cleanUpAllContentVersion(cleanedIds, cleanedSids).then(function (cleanUpContentVersionResult) {
                                        deferred.resolve([cleanUpResult, cleanUpContentVersionResult])
                                    }, function (error) {
                                        deferred.reject(error)
                                    })
                                }, function (error) {
                                    deferred.reject(error)
                                })
                            }, function (error) {
                                deferred.reject(error)
                            })
                        })
                    }, function (error) {
                        deferred.reject(error)
                    })
                };
            return getAllContentDocumentIds().then(function (allIds) {
                LocalDataService.getAllRecordsSFIdBySoup(objectName).then(function (localSfIds) {
                    var newVisibleIds = _.difference(allIds, localSfIds);
                    service.syncDownRecordsByIds(objectName, newVisibleIds).then(function () {
                        cleanUpResult.newVisiableRecords = newVisibleIds.length;
                        var smartSql = "select {ContentDocumentLink:ContentDocumentId}, {ContentDocumentLink:ContentDocumentId_sid} from {ContentDocumentLink}",
                            querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
                        navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                            for (var entries = cursor.currentPageOrderedEntries, idsInLink = [], sidsInLink = [], i = 0; i < entries.length; i++) {
                                var item = entries[i];
                                item[0] && idsInLink.indexOf(item[0]) === -1 && idsInLink.push(item[0]), item[1] && sidsInLink.indexOf(item[1]) === -1 && sidsInLink.push(item[1])
                            }
                            cleanLocalData(idsInLink, sidsInLink)
                        })
                    }, function (error) {
                        deferred.reject(error)
                    })
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        var cleanUpAllContentVersion = function (contentDocumentIds, contentDocumentSids) {
                var deferred = $q.defer(), objectName = "ContentVersion",
                    cleanUpResult = {objectName: objectName, newVisiableRecords: 0, dirtyRecords: 0},
                    cleanLocalData = function () {
                        var smartSql = "select {ContentVersion:_soupEntryId}, {ContentVersion:ContentDocumentId}, {ContentVersion:ContentDocumentId_sid} from {ContentVersion}",
                            querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
                        navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                            for (var entries = cursor.currentPageOrderedEntries, dirtySids = [], i = 0; i < entries.length; i++) {
                                var sid = entries[i][0], contentDocumentId = entries[i][1],
                                    contentDocumentSid = entries[i][2];
                                contentDocumentSids.indexOf(contentDocumentSid) === -1 && contentDocumentIds.indexOf(contentDocumentId) === -1 && dirtySids.push(sid)
                            }
                            navigator.smartstore.removeFromSoup(!1, objectName, dirtySids, function () {
                                cleanUpResult.dirtyRecords = dirtySids.length, deferred.resolve(cleanUpResult)
                            }, function (error) {
                                deferred.reject(error)
                            })
                        })
                    };
                return ConfigurationService.getBusinessObjectTypeByName(objectName).then(function (contentVersionType) {
                    if (contentVersionType) {
                        var soql = generateSoqlForObject(contentVersionType, "Id");
                        soql += soql.toLowerCase().indexOf(" where ") === -1 ? " WHERE " : " AND ", soql += "ContentDocumentId IN :list_id ", service.syncDownRecordsByIds(objectName, contentDocumentIds, null, null, !0, soql, !0).then(function (result) {
                            var allIds = _.pluck(result, "Id");
                            LocalDataService.getAllRecordsSFIdBySoup(objectName).then(function (localSfIds) {
                                var newVisibleIds = _.difference(allIds, localSfIds);
                                service.syncDownRecordsByIds(objectName, newVisibleIds, null, null, !0).then(function (newVisibleRecords) {
                                    cleanUpResult.newVisiableRecords = newVisibleIds.length, resetSyncFileOnDemand(newVisibleRecords).then(function () {
                                        _removeDirtyRecords(objectName, _.difference(localSfIds, allIds)).then(function () {
                                            cleanLocalData()
                                        }, function (error) {
                                            deferred.reject("cleanUpAllContentVersion error " + JSON.stringify(error))
                                        })
                                    }, function (error) {
                                        deferred.reject("cleanUpAllContentVersion error " + JSON.stringify(error))
                                    })
                                }, function (error) {
                                    deferred.reject("cleanUpAllContentVersion error " + JSON.stringify(error))
                                })
                            }, function (error) {
                                deferred.reject(error)
                            })
                        }, function (error) {
                            deferred.reject("cleanUpAllContentVersion error " + JSON.stringify(error))
                        })
                    } else deferred.reject("cleanUpAllContentVersion not found " + objectName + " configuration.")
                }, function (error) {
                    deferred.reject(error)
                }), deferred.promise
            }, resetSyncFileOnDemand = function (contentVersionRecords) {
                var deferred = $q.defer();
                contentVersionRecords && 0 !== contentVersionRecords.length || deferred.resolve(!0);
                var contentDocumentIds = _.pluck(contentVersionRecords, "ContentDocumentId"),
                    smartSql = "Select {ContentDocumentLink:ContentDocumentId}, {ContentDocumentLink:LinkedEntityId} From {ContentDocumentLink} Where {ContentDocumentLink:ContentDocumentId} is not null and {ContentDocumentLink:ContentDocumentId} in ('" + contentDocumentIds.join("','") + "') order by {ContentDocumentLink:LinkedEntityId} asc",
                    querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
                return navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                    var entries = cursor.currentPageOrderedEntries;
                    if (entries && entries.length > 0) {
                        for (var promises = [], currentLinkedEntityKeyPrefix = null, currentBatchContentDocumentId = [], i = 0; i < entries.length; i++) {
                            var contentDocumentId = entries[i][0], linkedEntityId = entries[i][1],
                                keyPrefix = linkedEntityId.substr(0, 3);
                            currentLinkedEntityKeyPrefix || currentLinkedEntityKeyPrefix !== keyPrefix ? (currentBatchContentDocumentId.push(contentDocumentId), promises.push(resetSyncFileOnDemandByCommonLinkedType(contentVersionRecords, currentBatchContentDocumentId, keyPrefix)), currentBatchContentDocumentId = []) : currentBatchContentDocumentId.push(contentDocumentId), currentLinkedEntityKeyPrefix = keyPrefix
                        }
                        $q.all(promises).then(function (allUpdatedContentVersionRecords) {
                            for (var updatedRecords = [], i = 0; i < allUpdatedContentVersionRecords.length; i++) updatedRecords = updatedRecords.concat(allUpdatedContentVersionRecords[i]);
                            navigator.smartstore.upsertSoupEntries("ContentVersion", updatedRecords, function () {
                                deferred.resolve(!0)
                            })
                        }, function (err) {
                            deferred.reject(err)
                        })
                    } else deferred.resolve(!0)
                }), deferred.promise
            },
            resetSyncFileOnDemandByCommonLinkedType = function (contentVersionRecords, contentDocumentIds, commonLinkedTypeKeyPrefix) {
                var deferred = $q.defer();
                return contentDocumentIds = angular.copy(contentDocumentIds), DescribeService.getObjectNameByKeyPrefix(commonLinkedTypeKeyPrefix).then(function (linkedObjectName) {
                    LocalDataService.queryConfiguredObjectByName(linkedObjectName).then(function (linkedObjectType) {
                        for (var defaultVersionDataSyncOnDemand = void 0 === linkedObjectType.MobileVizArt__File_On_Demand__c || null === linkedObjectType.MobileVizArt__File_On_Demand__c || linkedObjectType.MobileVizArt__File_On_Demand__c, updatedContentVersionRecords = [], i = 0; i < contentVersionRecords.length; i++) {
                            var item = contentVersionRecords[i];
                            contentDocumentIds.indexOf(item.ContentDocumentId) !== -1 && (item._versionDataSyncOnDemand = defaultVersionDataSyncOnDemand, updatedContentVersionRecords.push(item))
                        }
                        deferred.resolve(updatedContentVersionRecords)
                    }, function (error) {
                        deferred.reject(error)
                    })
                }, function (error) {
                    deferred.reject(error)
                }), deferred.promise
            },
            syncDownFileData = function (contentVersionEntries, syncBodyProcess, lastContentDocumentId, index, deferred) {
                deferred = deferred || $q.defer(), index = void 0 === index ? 0 : index, syncBodyProcess || (syncBodyProcess = {
                    total: contentVersionEntries.length,
                    processed: 0,
                    failed: 0
                });
                var contentVersion = contentVersionEntries[index], commonErrorOperation = function (err) {
                    contentVersion._versionDataSynced = !1, contentVersion._versionDataSyncError = err, syncBodyProcess.failed += 1, deferred.notify(syncBodyProcess), syncDownFileData(contentVersionEntries, syncBodyProcess, lastContentDocumentId, index, deferred)
                }, saveFile = function (contentDocumentSid, contentData) {
                    FileService.saveFileData({_soupEntryId: contentDocumentSid}, contentData).then(function () {
                        contentVersion._versionDataSynced = !0, syncBodyProcess.processed += 1, deferred.notify(syncBodyProcess), syncDownFileData(contentVersionEntries, syncBodyProcess, lastContentDocumentId, index, deferred)
                    }, function (error) {
                        commonErrorOperation(error + "")
                    })
                };
                if (contentVersion) if (index++, lastContentDocumentId && lastContentDocumentId === contentVersion.ContentDocumentId) lastContentDocumentId = contentVersion.ContentDocumentId, commonErrorOperation("Have already synced the latest version file in file system, the versionData of this record not need to sync down."); else {
                    lastContentDocumentId = contentVersion.ContentDocumentId;
                    var forceClient = ForceClientService.getForceClient(),
                        requestUrl = "/v36.0/sobjects/ContentVersion/" + contentVersion.Id + "/versionData";
                    forceClient.getChatterFile(requestUrl, null, function (contentData) {
                        contentVersion.ContentDocumentId_sid ? saveFile(contentVersion.ContentDocumentId_sid, contentData) : LocalDataService.getRecordsSidBySFid("ContentDocument", [contentVersion.ContentDocumentId]).then(function (contentDocumentSids) {
                            contentDocumentSids && contentDocumentSids[0] ? saveFile(contentDocumentSids[0], contentData) : commonErrorOperation("syncDownFileData not found contentDocument record of ContentDocumentId:" + contentVersion.ContentDocumentId)
                        }, function (error) {
                            deferred.reject(error)
                        })
                    }, function (error) {
                        $log.warn(new Exception(null, error.status, error.message, error.stack, error)), commonErrorOperation(error + "")
                    })
                } else _localSyncUpsertSoupEntriesWithExternalId("ContentVersion", contentVersionEntries).then(function () {
                    deferred.resolve(syncBodyProcess)
                }, function (error) {
                    deferred.reject(error)
                });
                return deferred.promise
            };
        service.startSyncDownAttachmentBody = function (attachmentSids) {
            var deferred = $q.defer();
            return $injector.get("SmartStoreService").checkSoupExist("Attachment").then(function (exist) {
                if (exist) {
                    var smartSql;
                    if (attachmentSids && attachmentSids.length > 0) smartSql = "Select {Attachment:_soup} From {Attachment} Where {Attachment:_soupEntryId} in (" + attachmentSids.join(",") + ")"; else {
                        var utilService = $injector.get("UtilService"), isAndroid = utilService.isAndroidOS(),
                            booleanFalse = 0, booleanTrue = 1;
                        isAndroid && (booleanFalse = "'false'", booleanTrue = "'true'"), smartSql = "Select {Attachment:_soup} From {Attachment} Where ({Attachment:_bodySynced} is null or {Attachment:_bodySynced} = " + booleanFalse + ") and {Attachment:Id} is not null", smartSql += " and {Attachment:_bodySyncOnDemand} = " + booleanFalse
                    }
                    var querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
                    navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                        var entries = cursor.currentPageOrderedEntries;
                        if (entries && entries.length > 0) {
                            var attachmentEntries = _.pluck(entries, 0);
                            syncDownAttachmentBody(attachmentEntries).then(function (success) {
                                deferred.resolve(success)
                            }, function (error) {
                                deferred.reject(error)
                            }, function (process) {
                                deferred.notify(process)
                            })
                        } else deferred.resolve({total: 0, processed: 0, failed: 0})
                    })
                } else deferred.resolve({})
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.startCleanUpAttachmentBody = function () {
            var deferred = $q.defer();
            return $injector.get("SmartStoreService").checkSoupExist("Attachment").then(function (exist) {
                exist ? LocalDataService.getAllRecordsSidBySoup("Attachment").then(function (sidArray) {
                    FileService.getAllAttachmentFolderNames().then(function (folderNames) {
                        for (var dirtyFileNames = [], i = 0; i < folderNames.length; i++) sidArray.indexOf(parseInt(folderNames[i])) === -1 && dirtyFileNames.push(folderNames[i]);
                        FileService.removeAttachmentBySids(dirtyFileNames).then(function () {
                            var smartSql = "Select {AttachmentBody:_soupEntryId}, {AttachmentBody:AttachmentSid} From {AttachmentBody}",
                                querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
                            navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                                var entries = cursor.currentPageOrderedEntries;
                                if (entries && entries.length > 0) {
                                    for (var dirtyAttachmentBodySid = [], j = 0; j < entries.length; j++) {
                                        var item = entries[j];
                                        sidArray.indexOf(parseInt(item[1])) === -1 && dirtyAttachmentBodySid.push(item[0])
                                    }
                                    dirtyAttachmentBodySid.length > 0 ? navigator.smartstore.removeFromSoup("AttachmentBody", dirtyAttachmentBodySid, function () {
                                        deferred.resolve(!0)
                                    }, function (error) {
                                        deferred.reject(error)
                                    }) : deferred.resolve(!0)
                                } else deferred.resolve(!0)
                            })
                        }, function (error) {
                            deferred.reject(error)
                        })
                    }, function (error) {
                        deferred.reject(error)
                    })
                }, function (error) {
                    deferred.reject(error)
                }) : deferred.resolve(!0)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        var syncDownAttachmentBody = function (attachmentEntries, syncBodyProcess, index, deferred) {
            deferred = deferred || $q.defer(), index = void 0 === index ? 0 : index, syncBodyProcess || (syncBodyProcess = {
                total: attachmentEntries.length,
                processed: 0,
                failed: 0
            });
            var attachment = attachmentEntries[index], commonErrorOperation = function (err) {
                attachment._bodySynced = !1, attachment._bodySyncError = err, syncBodyProcess.failed += 1, deferred.notify(syncBodyProcess), syncDownAttachmentBody(attachmentEntries, syncBodyProcess, index, deferred)
            };
            return attachment ? (index++, attachment.ParentId_type ? LocalDataService.queryConfiguredObjectByName(attachment.ParentId_type).then(function (relatedObjectType) {
                var forceClient = ForceClientService.getForceClient(),
                    requestUrl = "/v36.0/sobjects/Attachment/" + attachment.Id + "/body";
                forceClient.getChatterFile(requestUrl, attachment.ContentType, function (contentData) {
                    FileService.saveAttachmentBody(attachment, relatedObjectType, contentData).then(function () {
                        attachment._bodySynced = !0, syncBodyProcess.processed += 1, deferred.notify(syncBodyProcess), syncDownAttachmentBody(attachmentEntries, syncBodyProcess, index, deferred)
                    }, function (error) {
                        commonErrorOperation(error + "")
                    })
                }, function (error) {
                    $log.warn(new Exception(null, error.status, error.message, error.stack, error)), commonErrorOperation(error + "")
                })
            }, function (error) {
                commonErrorOperation(error + "")
            }) : commonErrorOperation("Not setting ParentId_type.")) : _localSyncUpsertSoupEntriesWithExternalId("Attachment", attachmentEntries).then(function () {
                deferred.resolve(syncBodyProcess)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        service.startCleanUpObjects = function (objectSyncWrapper) {
            var deferred = $q.defer();
            if (!objectSyncWrapper.cleanUpObjects || 0 === objectSyncWrapper.cleanUpObjects.objectTypes.length) return deferred.resolve(objectSyncWrapper), deferred.promise;
            var syncSequential = function (index, serverTimestamp) {
                if (index >= objectSyncWrapper.cleanUpObjects.objectTypes.length) {
                    var contentDocumentObjectType = _.findWhere(objectSyncWrapper.cleanUpObjects.objectTypes, {name: "ContentDocument"}),
                        contentVersionObjectType = _.findWhere(objectSyncWrapper.cleanUpObjects.objectTypes, {name: "ContentVersion"});
                    contentDocumentObjectType && contentVersionObjectType ? service.cleanUpAllContentDocument().then(function (cleanUpResults) {
                        for (var i = 0; i < cleanUpResults.length; i++) {
                            var subProcessStatus = cleanUpResults[i],
                                subProgressObj = objectSyncWrapper.cleanUpObjects.syncProgress[subProcessStatus.objectName];
                            subProgressObj.status.newVisiableRecords += subProcessStatus.newVisiableRecords, subProgressObj.status.dirtyRecords += subProcessStatus.dirtyRecords, deferred.notify(objectSyncWrapper)
                        }
                        objectSyncWrapper.cleanUpObjects.noNeedLastCleanupDate || MetaService.setMetaValue("lastCleanUpDate", serverTimestamp || (new Date).toISOString()), deferred.resolve(objectSyncWrapper)
                    }, function (error) {
                        deferred.reject(error)
                    }) : (objectSyncWrapper.cleanUpObjects.noNeedLastCleanupDate || MetaService.setMetaValue("lastCleanUpDate", serverTimestamp || (new Date).toISOString()), deferred.resolve(objectSyncWrapper))
                } else {
                    var objType = objectSyncWrapper.cleanUpObjects.objectTypes[index];
                    objType.needCleanUp ? service.cleanUpObjectRecords(objType).then(function (result) {
                        if (void 0 !== objType && skipCleanUpObjects.indexOf(objType.name) === -1) {
                            var progressObj = objectSyncWrapper.cleanUpObjects.syncProgress[objType.name];
                            progressObj.status.newVisiableRecords += result.newVisiableRecords, progressObj.status.dirtyRecords += result.dirtyRecords, deferred.notify(objectSyncWrapper)
                        }
                        if (result.subsidiaryRecords && result.subsidiaryRecords.length > 0) for (var i = 0; i < result.subsidiaryRecords.length; i++) {
                            var subProcessStatus = result.subsidiaryRecords[i],
                                subProgressObj = objectSyncWrapper.cleanUpObjects.syncProgress[subProcessStatus.objectName];
                            subProgressObj.status.newVisiableRecords += subProcessStatus.newVisiableRecords, subProgressObj.status.dirtyRecords += subProcessStatus.dirtyRecords, deferred.notify(objectSyncWrapper)
                        }
                        syncSequential(index + 1, serverTimestamp)
                    }, function (error) {
                        deferred.reject(error)
                    }, function (process) {
                        var progressObj = objectSyncWrapper.cleanUpObjects.syncProgress[objType.name];
                        progressObj.status.newVisiableRecords += process.newVisiableRecords, progressObj.status.dirtyRecords += process.dirtyRecords, deferred.notify(objectSyncWrapper)
                    }) : syncSequential(index + 1, serverTimestamp)
                }
            };
            return RestService.getServerTimestamp().then(function (serverTimestamp) {
                objectSyncWrapper.cleanUpObjects.forceCleanup ? syncSequential(0, serverTimestamp) : checkCleanUpInterval(serverTimestamp).then(function (cleanupTimeUp) {
                    cleanupTimeUp ? syncSequential(0, serverTimestamp) : deferred.resolve(objectSyncWrapper)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        var checkCleanUpInterval = function (serverTimestamp) {
            var deferred = $q.defer(), intervalDate = 0;
            return LocalDataService.queryConfigurationAndObjects().then(function (configuraion) {
                var cleanupInterval = configuraion.MobileVizArt__Cleanup_Interval__c;
                return cleanupInterval && parseFloat(cleanupInterval) && (intervalDate = parseFloat(cleanupInterval)), MetaService.getMetaValue("lastCleanUpDate")
            }).then(function (lastCleanUpDate) {
                var nowTime = new Date(serverTimestamp);
                if (!lastCleanUpDate || lastCleanUpDate && nowTime.getTime() - new Date(lastCleanUpDate).getTime() > 60 * intervalDate * 60 * 1e3) {
                    var $ionicPopup = $injector.get("$ionicPopup"),
                        confirmPopup = ($injector.get("$filter"), $ionicPopup.confirm({
                            title: UtilService.translate("mobile_sync_lb_cleanUp", "cl.sync.lb_cleanUp"),
                            subTitle: UtilService.translate("mobile_sync_lb_cleanUp_confirm", "cl.sync.lb_cleanUp_confirm"),
                            okText: UtilService.translate("mobile_sync_btn_cleanUp", "cl.sync.btn_cleanUp"),
                            cancelText: UtilService.translate("mobile_global_btn_cancel", "cl.global.btn_cancel")
                        }));
                    confirmPopup.then(function (res) {
                        res ? deferred.resolve(!0) : deferred.resolve(!1)
                    })
                } else deferred.resolve(!1)
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, generateSoqlForObject = function (objectType, queryFields) {
            var tableName = objectType.name, fields = objectType.fields, filterCriteria = objectType.filterCriteria,
                queryStr = "SELECT ";
            return queryStr += queryFields ? queryFields : fields.toString(),
                queryStr += " FROM " + tableName + " WHERE Id != null", filterCriteria && (queryStr += " AND " + filterCriteria), queryStr
        };
        service.cleanUpObjectRecords = function (objType) {
            var deferred = $q.defer();
            return void 0 !== objType && skipCleanUpObjects.indexOf(objType.name) === -1 ? MetaService.getObjectMetaByType(objType.name).then(function (objMeta) {
                objMeta && objMeta.lastCleanUpDate && (objType.lastCleanUpDate = objMeta.lastCleanUpDate), _cleanUpRecordsFromSFDC(objType).then(function (done) {
                    deferred.notify(done), service.cleanUpObjectSubsidiaryRecords(objType).then(function (subDone) {
                        var processStatus = angular.copy(done);
                        processStatus.newVisiableRecords = 0, processStatus.dirtyRecords = 0, processStatus.subsidiaryRecords = subDone, MetaService.updateLastCleanUpDate(objType.name, objType._serverTimestamp || (new Date).toISOString()).then(function () {
                            deferred.resolve(processStatus)
                        }, function (error) {
                            deferred.reject(error)
                        })
                    }, function (error) {
                        deferred.reject(error)
                    })
                }, function (error) {
                    deferred.reject(error)
                }, function (progress) {
                    deferred.notify(progress)
                })
            }, function (error) {
                deferred.reject(error)
            }) : deferred.resolve({newVisiableRecords: 0, dirtyRecords: 0}), deferred.promise
        }, service.cleanUpObjectSubsidiaryRecords = function (param) {
            var objectName = param.name, deferred = $q.defer(), promises = [];
            return LocalDataService.queryConfiguredObjectByName(objectName).then(function (objectType) {
                if (objectType.MobileVizArt__Enable_NotesAndAttachments__c || objectType.MobileVizArt__Enable_Activity__c || objectType.MobileVizArt__Enable_File__c) {
                    var queryStr = generateSoqlForObject(param, "Id");
                    objectType.MobileVizArt__Enable_NotesAndAttachments__c && (promises.push(cleanUpSubsidiaryRecords(objectType, "Attachment", queryStr)), promises.push(cleanUpSubsidiaryRecords(objectType, "Note", queryStr))), objectType.MobileVizArt__Enable_Activity__c && (promises.push(cleanUpSubsidiaryRecords(objectType, "Task", queryStr)), promises.push(cleanUpSubsidiaryRecords(objectType, "Event", queryStr))), objectType.MobileVizArt__Enable_File__c && promises.push(cleanUpSubsidiaryFileLinkRecords(objectType, queryStr)), $q.all(promises).then(function (syncProcess) {
                        deferred.resolve(syncProcess)
                    }, function (err) {
                        deferred.reject(err)
                    })
                } else deferred.resolve([])
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        };
        var cleanUpSubsidiaryRecords = function (objectType, subsidiaryObjectName, queryStr) {
            var deferred = $q.defer();
            return DescribeService.getKeyPrefix(objectType.Name).then(function (parentObjectKeyPrefix) {
                ConfigurationService.getBusinessObjectTypeByName(subsidiaryObjectName).then(function (subObjectType) {
                    if (subObjectType) {
                        var subsidiaryObjectType = angular.copy(subObjectType);
                        subsidiaryObjectType.filterCriteria ? subsidiaryObjectType.filterCriteria += " AND " : subsidiaryObjectType.filterCriteria = "";
                        var localFilterCriteria;
                        "Attachment" === subsidiaryObjectName || "Note" === subsidiaryObjectName ? (subsidiaryObjectType.filterCriteria += "ParentId IN (" + queryStr + ")", localFilterCriteria = "{" + subsidiaryObjectName + ":ParentId} LIKE '" + parentObjectKeyPrefix + "%'") : ("Contact" === objectType.Name || "Lead" === objectType.Name ? subsidiaryObjectType.filterCriteria += "WhoId IN (" + queryStr + ")" : subsidiaryObjectType.filterCriteria += "WhatId IN (" + queryStr + ")", localFilterCriteria = "({" + subsidiaryObjectName + ":WhatId} Like '" + parentObjectKeyPrefix + "%' OR {" + subsidiaryObjectName + ":WhoId} Like '" + parentObjectKeyPrefix + "%')"), _getRecordsSfIds(subsidiaryObjectType).then(function (idsInSf) {
                            LocalDataService.getAllRecordsSFIdBySoup(subsidiaryObjectName, localFilterCriteria).then(function (idsInLocal) {
                                var notExistIds = [], newIds = [];
                                compareViaObjectProperty(idsInSf, idsInLocal, newIds, notExistIds);
                                var result = {
                                    objectName: subsidiaryObjectName,
                                    newVisiableRecords: newIds.length,
                                    dirtyRecords: notExistIds.length
                                };
                                _syncDownNewVisibleSubsidiaryRecord(objectType, subsidiaryObjectType, newIds).then(function () {
                                    _removeDirtyRecords(subsidiaryObjectName, notExistIds).then(function () {
                                        deferred.resolve(result)
                                    }, function (error) {
                                        deferred.reject(error)
                                    })
                                }, function (error) {
                                    deferred.reject(error)
                                })
                            }, function (error) {
                                deferred.reject(error)
                            })
                        }, function (error) {
                            deferred.reject(error)
                        })
                    } else deferred.reject("cleanUpSubsidiaryRecords not found " + subsidiaryObjectName + " configuration.")
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, cleanUpSubsidiaryFileLinkRecords = function (objectType, queryStr) {
            var deferred = $q.defer(), subsidiaryObjectName = "ContentDocumentLink";
            return DescribeService.getKeyPrefix(objectType.Name).then(function (parentObjectKeyPrefix) {
                ConfigurationService.getBusinessObjectTypeByName(subsidiaryObjectName).then(function (subObjectType) {
                    if (subObjectType) {
                        var subsidiaryObjectType = angular.copy(subObjectType);
                        subsidiaryObjectType.filterCriteria ? subsidiaryObjectType.filterCriteria += " AND " : subsidiaryObjectType.filterCriteria = "", subsidiaryObjectType.filterCriteria += "LinkedEntityId IN (" + queryStr + ")";
                        var localFilterCriteria = "{" + subsidiaryObjectName + ":LinkedEntityId} LIKE '" + parentObjectKeyPrefix + "%'";
                        _getRecordsSfIds(subsidiaryObjectType).then(function (idsInSf) {
                            LocalDataService.getAllRecordsSFIdBySoup(subsidiaryObjectName, localFilterCriteria).then(function (idsInLocal) {
                                var notExistIds = [], newIds = [];
                                compareViaObjectProperty(idsInSf, idsInLocal, newIds, notExistIds);
                                var result = {
                                    objectName: subsidiaryObjectName,
                                    newVisiableRecords: newIds.length,
                                    dirtyRecords: notExistIds.length
                                };
                                _syncDownNewVisibleSubsidiaryRecord(objectType, subsidiaryObjectType, newIds).then(function () {
                                    _removeDirtyRecords(subsidiaryObjectName, notExistIds).then(function () {
                                        deferred.resolve(result)
                                    }, function (error) {
                                        deferred.reject(error)
                                    })
                                }, function (error) {
                                    deferred.reject(error)
                                })
                            }, function (error) {
                                deferred.reject(error)
                            })
                        }, function (error) {
                            deferred.reject(error)
                        })
                    } else deferred.reject("cleanUpSubsidiaryFileLinkRecords not found " + subsidiaryObjectName + " configuration.")
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, clearSubsidiaryRecordsFileData = function (objectName, sidArray) {
            var deferred = $q.defer();
            return sidArray && sidArray.length > 0 ? "Attachment" === objectName ? cleanUpAttachmentBodyBySid(sidArray).then(function () {
                deferred.resolve(!0)
            }, function (err) {
                deferred.reject(err)
            }) : "ContentDocument" === objectName ? FileService.removeFileBySids(sidArray).then(function () {
                deferred.resolve(!0)
            }, function (err) {
                deferred.reject(err)
            }) : deferred.reject("Not supported object type: " + objectName) : deferred.resolve(!0), deferred.promise
        }, cleanUpAttachmentBodyBySid = function (sidArray) {
            var deferred = $q.defer();
            return sidArray && sidArray.length > 0 ? navigator.smartstore.retrieveSoupEntries("Attachment", sidArray, function (entries) {
                if (entries.length > 0) {
                    var attachment = entries[0];
                    attachment.hasOwnProperty("ParentId_type") ? LocalDataService.queryConfiguredObjectByName(attachment.ParentId_type).then(function (parentObjectType) {
                        var isFile = !parentObjectType.MobileVizArt__Attachments_Encrypted__c;
                        clearAttachmentBodyBySid(sidArray, isFile).then(function () {
                            deferred.resolve(!0)
                        }, function (err) {
                            deferred.reject(err)
                        })
                    }, function (err) {
                        deferred.reject(err)
                    }) : deferred.resolve(!0)
                } else deferred.resolve(!0)
            }, function (err) {
                deferred.reject(err)
            }) : deferred.resolve(!0), deferred.promise
        }, clearAttachmentBodyBySid = function (sidArray, isFile) {
            var deferred = $q.defer();
            return isFile ? FileService.removeAttachmentBySids(sidArray).then(function () {
                deferred.resolve(!0)
            }, function (err) {
                deferred.reject(err)
            }) : LocalDataService.getAllRecordsSidBySoup("AttachmentBody", "{AttachmentBody:AttachmentSid} in (" + sidArray.join(",") + ")").then(function (attachmentBodySidArray) {
                navigator.smartstore.removeFromSoup("AttachmentBody", attachmentBodySidArray, function () {
                    deferred.resolve(!0)
                }, function (err) {
                    deferred.reject(err)
                })
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, _cleanUpRecordsFromSFDC = function (objType) {
            var deferred = $q.defer();
            return _getRecordsSfIds(objType).then(function (idsInSf) {
                LocalDataService.getAllRecordsSFIdBySoup(objType.name).then(function (idsInLocal) {
                    var notExistIds = [], newIds = [];
                    compareViaObjectProperty(idsInSf, idsInLocal, newIds, notExistIds);
                    var result = {newVisiableRecords: newIds.length, dirtyRecords: notExistIds.length};
                    service.syncDownRecordsByIds(objType, newIds).then(function () {
                        _removeDirtyRecords(objType.name, notExistIds).then(function () {
                            deferred.resolve(result)
                        }, function (error) {
                            deferred.reject(error)
                        })
                    }, function (error) {
                        deferred.reject("_cleanUpRecordsFromSFDC error: " + JSON.stringify(error))
                    })
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, _getRecordsSfIds = function (objType, param) {
            param || (param = {
                deferred: $q.defer(),
                idsAsset: [],
                payload: {
                    soql: generateSoqlForObject(objType, "Id"),
                    objectType: objType.name,
                    pageSize: SYNC_PAGE_SIZE.CLEAN_UP_DOWNLOAD_ALL_RECORDS_ID
                }
            });
            var deferred = param.deferred, idsAsset = param.idsAsset, payload = param.payload;
            return RestService.getRecordIds(payload).then(function (response) {
                var rtIds = response.list_ids;
                rtIds && rtIds.length > 0 ? (idsAsset = idsAsset.concat(rtIds), param.idsAsset = idsAsset, rtIds.length != payload.pageSize ? deferred.resolve(idsAsset) : (payload.lastId = rtIds[rtIds.length - 1], _getRecordsSfIds(objType, param))) : deferred.resolve(idsAsset)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, _syncDownNewVisibleSubsidiaryRecord = function (objectType, subsidiaryObjectType, sfIds) {
            var extendInfo, remainProperties, deferred = $q.defer();
            if ("Attachment" === subsidiaryObjectType.name) {
                var defaultBodySyncOnDemand = void 0 === objectType.MobileVizArt__Attachment_On_Demand__c || null === objectType.MobileVizArt__Attachment_On_Demand__c || objectType.MobileVizArt__Attachment_On_Demand__c;
                remainProperties = ["_bodySynced", "_bodySyncOnDemand"], extendInfo = {
                    _bodySynced: !1,
                    _bodySyncOnDemand: defaultBodySyncOnDemand,
                    ParentId_type: objectType.Name
                }
            } else "ContentDocumentLink" === subsidiaryObjectType.name && (extendInfo = {LinkedEntityId_type: objectType.Name});
            return service.syncDownRecordsByIds(subsidiaryObjectType, sfIds, extendInfo, remainProperties).then(function () {
                deferred.resolve()
            }, function (error) {
                deferred.reject("_syncDownNewVisibleSubsidiaryRecord error: " + JSON.stringify(error))
            }), deferred.promise
        };
        service.syncDownRecordsByIds = function (objectType, sfIds, extendInfo, remainProperties, returnRecords, soql, notStored) {
            var deferred = $q.defer();
            if (!sfIds || 0 === sfIds.length) return deferred.resolve([]), deferred.promise;
            sfIds = angular.copy(sfIds);
            var pageSize = SYNC_PAGE_SIZE.DOWNLOAD_RECORDS_BY_ID,
                objectName = "string" == typeof objectType ? objectType : objectType.name,
                payload = {soql: "", inFilterCriteria: {list_id: ""}}, allResult = [], syncSequential = function () {
                    var batchData = sfIds.splice(0, pageSize);
                    payload.inFilterCriteria.list_id = batchData.toString(), RestService.getRecordsByIds(payload).then(function (response) {
                        var records2Upsert = response.records;
                        if (extendInfo) for (var i = 0; i < records2Upsert.length; i++) {
                            var item = records2Upsert[i];
                            item = _.extend(item, extendInfo)
                        }
                        notStored ? (allResult = allResult.concat(records2Upsert), 0 === sfIds.length ? deferred.resolve(allResult) : syncSequential()) : _localSyncUpsertSoupEntriesWithExternalId(objectName, records2Upsert, remainProperties).then(function (result) {
                            returnRecords && (allResult = allResult.concat(result)), 0 === sfIds.length ? returnRecords ? deferred.resolve(allResult) : deferred.resolve() : syncSequential()
                        }, function (error) {
                            deferred.reject(error)
                        })
                    }, function (error) {
                        deferred.reject("syncDownRecordsByIds error: " + JSON.stringify(error))
                    })
                };
            return soql ? (payload.soql = soql, syncSequential()) : "string" == typeof objectType ? ConfigurationService.getBusinessObjectTypeByName(objectName).then(function (objType) {
                objType ? (payload.soql = generateSoqlForObject(objType) + " AND Id IN :list_id", syncSequential()) : deferred.reject("syncDownRecordsByIds error: not found the configure of " + objectName)
            }, function (error) {
                deferred.reject("syncDownRecordsByIds error: " + JSON.stringify(error))
            }) : "object" == typeof objectType ? (payload.soql = generateSoqlForObject(objectType) + " AND Id IN :list_id", syncSequential()) : deferred.reject("syncDownRecordsByIds incorrect parameter objectType or soql"), deferred.promise
        };
        var compareViaObjectProperty = function (a, b, extraDataInA, extraDataInB) {
            for (var aMap = ((new Date).getTime(), {}), i = 0; i < a.length; i++) aMap[a[i]] = 1;
            for (var j = 0; j < b.length; j++) aMap.hasOwnProperty(b[j]) || extraDataInB.push(b[j]);
            for (var bMap = {}, k = 0; k < b.length; k++) bMap[b[k]] = 1;
            for (var l = 0; l < a.length; l++) bMap.hasOwnProperty(a[l]) || extraDataInA.push(a[l]);
            (new Date).getTime()
        }, _removeDirtyRecords = function (soupName, sfIds) {
            var deferred = $q.defer();
            return _removeInactiveRecordsBySFIds(soupName, sfIds).then(function () {
                _removeInactiveLocalRecords(soupName).then(function () {
                    deferred.resolve(!0)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, _removeInactiveRecordsBySFIds = function (soupName, sfIds) {
            var deferred = $q.defer();
            return sfIds && sfIds.length > 0 ? LocalDataService.getActiveRecordsSidBySoup(soupName).then(function (activeSids) {
                for (var aMap = {}, i = 0; i < activeSids.length; i++) aMap[activeSids[i]] = 1;
                LocalDataService.getRecordsSidBySFid(soupName, sfIds).then(function (sids) {
                    for (var inactiveSids = [], j = 0; j < sids.length; j++) aMap.hasOwnProperty(sids[j]) || inactiveSids.push(sids[j]);
                    inactiveSids.length > 0 ? "Attachment" === soupName || "ContentDocument" === soupName ? clearSubsidiaryRecordsFileData(soupName, inactiveSids).then(function () {
                        navigator.smartstore.removeFromSoup(!1, soupName, inactiveSids, function () {
                            deferred.resolve(!0)
                        }, function (error) {
                            deferred.reject(error)
                        })
                    }, function (error) {
                        deferred.reject(error)
                    }) : navigator.smartstore.removeFromSoup(!1, soupName, inactiveSids, function () {
                        deferred.resolve(!0)
                    }, function (error) {
                        deferred.reject(error)
                    }) : deferred.resolve(!0)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }) : deferred.resolve(!0), deferred.promise
        }, _removeInactiveLocalRecords = function (soupName) {
            var deferred = $q.defer();
            return LocalDataService.getActiveRecordsSidBySoup(soupName).then(function (activeSids) {
                for (var aMap = {}, i = 0; i < activeSids.length; i++) aMap[activeSids[i]] = 1;
                LocalDataService.getNoIdRecordsSidBySoup(soupName).then(function (sids) {
                    for (var inactiveSids = [], j = 0; j < sids.length; j++) aMap.hasOwnProperty(sids[j]) || inactiveSids.push(sids[j]);
                    inactiveSids.length > 0 ? "Attachment" === soupName || "ContentDocument" === soupName ? clearSubsidiaryRecordsFileData(soupName, inactiveSids).then(function () {
                        navigator.smartstore.removeFromSoup(!1, soupName, inactiveSids, function () {
                            deferred.resolve(!0)
                        }, function (error) {
                            deferred.reject(error)
                        })
                    }, function (error) {
                        deferred.reject(error)
                    }) : navigator.smartstore.removeFromSoup(!1, soupName, inactiveSids, function () {
                        deferred.resolve(!0)
                    }, function (error) {
                        deferred.reject(error)
                    }) : deferred.resolve(!0)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        service.startRebuildLocalReferenceForObjects = function (objectSyncWrapper) {
            var deferred = $q.defer();
            if (objectSyncWrapper.syncDownObjects.ignoreLocalReference) deferred.resolve(objectSyncWrapper); else {
                var objectsNeed2RebuildReference = {}, hasObjects2RebuildReference = !1;
                angular.forEach(objectSyncWrapper.syncUpObjects.objectTypes, function (objectEntity) {
                    var progressObj = objectSyncWrapper.syncUpObjects.syncProgress[objectEntity.name];
                    (progressObj.status.inserted > 0 || progressObj.status.updated > 0 || progressObj.status.deleted) && (hasObjects2RebuildReference = !0, objectsNeed2RebuildReference[objectEntity.name] = objectEntity.syncUpSoupEntryIds, "ContentVersion" === objectEntity.name && (objectsNeed2RebuildReference.ContentDocument = []))
                }), angular.forEach(objectSyncWrapper.syncDownObjects.objectTypes, function (objectEntity) {
                    var progressObj = objectSyncWrapper.syncDownObjects.syncProgress[objectEntity.name];
                    progressObj.status.total > 0 && (hasObjects2RebuildReference = !0, objectsNeed2RebuildReference[objectEntity.name] = [])
                }), angular.forEach(objectSyncWrapper.cleanUpObjects.objectTypes, function (objectEntity) {
                    var progressObj = objectSyncWrapper.cleanUpObjects.syncProgress[objectEntity.name];
                    progressObj.status.newVisiableRecords > 0 && (hasObjects2RebuildReference = !0, objectsNeed2RebuildReference[objectEntity.name] = [])
                }), hasObjects2RebuildReference === !1 ? deferred.resolve(objectSyncWrapper) : service.rebuildObjectRecordsLocalRef(objectsNeed2RebuildReference, !0).then(function () {
                    deferred.resolve(objectSyncWrapper)
                }, function (err) {
                    deferred.reject(err)
                }, function (notify) {
                    if (notify) {
                        var notifyObjName = notify.objectName;
                        if (objectSyncWrapper.syncDownObjects.syncProgress[notifyObjName]) {
                            var progressObj = objectSyncWrapper.syncDownObjects.syncProgress[notifyObjName];
                            objectSyncWrapper.reference = progressObj, objectSyncWrapper.reference.status.referenceTotal = notify.total, progressObj.status.referenceSize || (objectSyncWrapper.reference.status.referenceSize = 0), objectSyncWrapper.reference.status.referenceSize += notify.size
                        }
                        deferred.notify(objectSyncWrapper)
                    }
                })
            }
            return deferred.promise
        };
        var _localSyncUpsertSoupEntriesWithExternalId = function (soupName, records2Upsert, remainProperties) {
            var deferred = $q.defer();
            if (soupName && records2Upsert && records2Upsert.length) if (remainProperties) {
                for (var ids = [], recordsIdMap = {}, i = 0; i < records2Upsert.length; i++) {
                    var item = records2Upsert[i];
                    ids.push(item.Id), recordsIdMap[item.Id] = item
                }
                var sqlStr = "select {" + soupName + ":_soup} from {" + soupName + "} where {" + soupName + ":Id} in ('" + ids.join("','") + "')",
                    querySpec = navigator.smartstore.buildSmartQuerySpec(sqlStr, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
                navigator.smartstore.runSmartQuery(querySpec, function (cursor) {
                    var entries = cursor.currentPageOrderedEntries;
                    if (entries && entries.length > 0) {
                        if ("string" == typeof remainProperties) for (var i = 0; i < entries.length; i++) {
                            var recordItem = entries[i][0];
                            void 0 !== recordItem[remainProperties] && (recordsIdMap[recordItem.Id][remainProperties] = recordItem[remainProperties])
                        } else for (var i = 0; i < entries.length; i++) for (var recordItem = entries[i][0], j = 0; j < remainProperties.length; j++) {
                            var propertyName = remainProperties[j];
                            void 0 !== recordItem[propertyName] && (recordsIdMap[recordItem.Id][propertyName] = recordItem[propertyName])
                        }
                        if ("Attachment" === soupName) for (var i = 0; i < entries.length; i++) {
                            var recordItem = entries[i][0], newRecordItem = recordsIdMap[recordItem.Id];
                            recordItem.Name !== newRecordItem.Name && FileService.changeAttachmentFileName(recordItem._soupEntryId, recordItem.Name, newRecordItem.Name)
                        }
                        if ("ContentVersion" === soupName) for (var i = 0; i < entries.length; i++) {
                            var recordItem = entries[i][0], newRecordItem = recordsIdMap[recordItem.Id];
                            newRecordItem.IsLatest !== !0 || recordItem.Title === newRecordItem.Title && recordItem.FileExtension === newRecordItem.FileExtension || FileService.changeFileName({
                                _soupEntryId: recordItem.ContentDocumentId_sid,
                                Title: recordItem.Title,
                                FileExtension: recordItem.FileExtension
                            }, {
                                _soupEntryId: recordItem.ContentDocumentId_sid,
                                Title: newRecordItem.Title,
                                FileExtension: newRecordItem.FileExtension
                            })
                        }
                    }
                    navigator.smartstore.upsertSoupEntriesWithExternalId(!1, soupName, _.values(recordsIdMap), "Id", function (result) {
                        deferred.resolve(result)
                    }, function (error) {
                        deferred.reject(error)
                    })
                }, function (error) {
                    deferred.reject(error)
                })
            } else navigator.smartstore.upsertSoupEntriesWithExternalId(!1, soupName, records2Upsert, "Id", function (result) {
                deferred.resolve(result)
            }, function (error) {
                deferred.reject(error)
            }); else deferred.resolve([]);
            return deferred.promise
        }, _localSyncRemoveFromSoup = function (soupName, recordIds2Delete) {
            var deferred = $q.defer();
            return soupName && recordIds2Delete && recordIds2Delete.length > 0 ? LocalDataService.getAllRecordsSidBySoup(soupName, "{" + soupName + ":Id} in ('" + recordIds2Delete.join("','") + "')").then(function (sidArray) {
                sidArray.length ? "Attachment" === soupName || "ContentDocument" === soupName ? clearSubsidiaryRecordsFileData(soupName, sidArray).then(function () {
                    navigator.smartstore.removeFromSoup(!1, soupName, sidArray, function () {
                        deferred.resolve(!0)
                    }, function (error) {
                        deferred.reject(error)
                    })
                }, function (error) {
                    deferred.reject(error)
                }) : navigator.smartstore.removeFromSoup(!1, soupName, sidArray, function () {
                    deferred.resolve(!0)
                }, function (error) {
                    deferred.reject(error)
                }) : deferred.resolve(!0)
            }, function (error) {
                deferred.reject(error)
            }) : deferred.resolve(!0), deferred.promise
        }, generateSoqlForSyncDown = function (objectType) {
            return $q(function (resolve, reject) {
                var tableName = objectType.name, fields = objectType.fields, filterCriteria = objectType.filterCriteria,
                    lookupModStamp = objectType.lookupModStamp, lastSyncDownDate = objectType.lastSyncDownDate,
                    serverTimestamp = objectType._serverTimestamp,
                    queryStr = "SELECT " + fields.toString() + " FROM " + tableName, whereClause = null,
                    resolveObjectInSearchFieldPermissionPromise = null;
                lastSyncDownDate ? null == lookupModStamp || 0 === lookupModStamp.length ? whereClause = "SystemModStamp > [LAST_SYNC_DATE] AND SystemModStamp <= [SERVER_TIME_STAMP]" : resolveObjectInSearchFieldPermissionPromise = $q(function (resolveObjectInSearchFieldPermissionResolve, resolveObjectInSearchFieldPermissionReject) {
                    MetaService.getMetaValue("objectPermissions").then(function (objectPermissions) {
                        var objectHasReadPermissions = [];
                        for (var objectName in objectPermissions) objectPermissions.hasOwnProperty(objectName) && objectPermissions[objectName].PermissionsRead === !0 && objectHasReadPermissions.indexOf(objectName) === -1 && objectHasReadPermissions.push(objectName);
                        var lookupModStampArr = lookupModStamp.split(","), lookupFieldNames = [],
                            checkLookupObjectReadPermissions = [];
                        angular.forEach(lookupModStampArr, function (item) {
                            item = item.trim(), checkLookupObjectReadPermissions.push($q(function (innnerResolve, innerReject) {
                                var checkFieldReferenceToObjectPermission = function (fieldOnObjectName, cascadeFields, checkIndex) {
                                    fieldOnObjectName = fieldOnObjectName || tableName;
                                    var fieldName = cascadeFields[checkIndex];
                                    _.endsWith(fieldName, "__r") ? fieldName = fieldName.substring(0, fieldName.length - 1) + "c" : _.endsWith(fieldName, "Id") || (fieldName += "Id");
                                    var checkFieldReferenceToObjectPermissionDefer = $q.defer();
                                    return DescribeService.getDescribeSObject(fieldOnObjectName).then(function (objectDescribe) {
                                        var lookupObjectNames = _.result(_.find(objectDescribe.fields, "name", fieldName), "referenceTo");
                                        lookupObjectNames && lookupObjectNames.length > 0 ? (fieldOnObjectName = lookupObjectNames[0], objectHasReadPermissions.indexOf(lookupObjectNames[0]) === -1 ? checkFieldReferenceToObjectPermissionDefer.resolve(!1) : cascadeFields.length > checkIndex + 2 ? (checkIndex++, checkFieldReferenceToObjectPermission(fieldOnObjectName, cascadeFields, checkIndex).then(checkFieldReferenceToObjectPermissionDefer.resolve, checkFieldReferenceToObjectPermissionDefer.reject)) : checkFieldReferenceToObjectPermissionDefer.resolve(!0)) : checkFieldReferenceToObjectPermissionDefer.resolve(!1)
                                    }, checkFieldReferenceToObjectPermissionDefer.reject), checkFieldReferenceToObjectPermissionDefer.promise
                                };
                                if (item.indexOf(".") > -1) {
                                    var cascadeFields = item.split(".");
                                    checkFieldReferenceToObjectPermission(tableName, cascadeFields, 0).then(function (hasPermission) {
                                        hasPermission === !0 && lookupFieldNames.indexOf(item) === -1 && lookupFieldNames.push(item), innnerResolve(!0)
                                    }, innerReject)
                                } else lookupFieldNames.indexOf(item) === -1 && lookupFieldNames.push(item), innnerResolve(!0)
                            }))
                        }), $q.all(checkLookupObjectReadPermissions).then(function () {
                            for (var i = 0; i < lookupFieldNames.length; i++) {
                                var fieldName = lookupFieldNames[i];
                                whereClause || (whereClause = "("), whereClause += serverTimestamp ? "(" + fieldName + "> [LAST_SYNC_DATE] AND " + fieldName + " <= [SERVER_TIME_STAMP]) OR " : fieldName + "> [LAST_SYNC_DATE] OR "
                            }
                            whereClause && _.endsWith(whereClause.trim(), "OR") && (whereClause = whereClause.substring(0, whereClause.length - 3), whereClause += ")"), resolveObjectInSearchFieldPermissionResolve(!0)
                        }, resolveObjectInSearchFieldPermissionReject)
                    }, resolveObjectInSearchFieldPermissionReject)
                }) : whereClause = "SystemModStamp <= [SERVER_TIME_STAMP]";
                var handleGenerateSoqlResult = function () {
                    lastSyncDownDate && (whereClause = whereClause.replace(/\[LAST_SYNC_DATE\]/g, lastSyncDownDate)), serverTimestamp && (whereClause = whereClause.replace(/\[SERVER_TIME_STAMP\]/g, serverTimestamp)), null != filterCriteria && filterCriteria.length > 0 && (null == whereClause ? whereClause = filterCriteria : whereClause += " AND " + filterCriteria), null != whereClause && (queryStr += " WHERE " + whereClause), resolve(queryStr)
                };
                resolveObjectInSearchFieldPermissionPromise ? resolveObjectInSearchFieldPermissionPromise.then(function () {
                    handleGenerateSoqlResult()
                }, reject) : handleGenerateSoqlResult()
            })
        };
        service.syncUpObjectRecords = function (objectType) {
            var deferred = $q.defer(), records2Insert = [], records2Update = [], records2Delete = [],
                querySpec = navigator.smartstore.buildExactQuerySpec("objectName", objectType.name, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
            return navigator.smartstore.querySoup(SMARTSTORE_COMMON_SETTING.SOUP_NAME_QUEUE, querySpec, function (cursor) {
                var currentPageEntries = cursor.currentPageOrderedEntries;
                angular.forEach(currentPageEntries, function (entry) {
                    entry.action === SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_INSERT ? records2Insert.push(entry) : entry.action === SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_UPDATE ? records2Update.push(entry) : entry.action === SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_DELETE && records2Delete.push(entry)
                }), syncUpInsertRecords(objectType.name, records2Insert).then(function (result) {
                    deferred.notify(result), syncUpUpdateRecords(objectType.name, records2Update).then(function (result) {
                        deferred.notify(result), syncUpDeleteRecords(objectType.name, records2Delete).then(function (result) {
                            deferred.notify(result), MetaService.updateLastSyncUpDate(objectType.name, objectType._serverTimestamp || (new Date).toISOString()).then(function () {
                                deferred.resolve(result)
                            }, function (error) {
                                deferred.reject(error)
                            })
                        }, function (error) {
                            deferred.reject(error)
                        }, function (notify) {
                            deferred.notify(notify)
                        })
                    }, function (error) {
                        deferred.reject(error)
                    }, function (notify) {
                        deferred.notify(notify)
                    })
                }, function (error) {
                    deferred.reject(error)
                }, function (notify) {
                    deferred.notify(notify)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        var syncUpInsertRecords = function (objectName, messageRecords) {
            var deferred = $q.defer();
            return messageRecords && 0 != messageRecords.length ? (queryRelatedRecords(messageRecords).then(function (result) {
                var param4Insert = {
                    objectType: objectName,
                    operationType: SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_INSERT,
                    records: result.records,
                    queueMessages: result.queueMessages
                };
                "Attachment" === objectName || "ContentVersion" === objectName ? lookupSFDCReference(objectName, param4Insert.records, param4Insert.operationType).then(function () {
                    "Attachment" === objectName ? syncUpNewAttachmentRecords(param4Insert).then(function (result) {
                        deferred.resolve(result)
                    }, function (error) {
                        deferred.reject(error)
                    }, function (notify) {
                        deferred.notify(notify)
                    }) : "ContentVersion" === objectName ? syncUpNewContentVersionRecords(param4Insert).then(function (result) {
                        deferred.resolve(result)
                    }, function (error) {
                        deferred.reject(error)
                    }, function (notify) {
                        deferred.notify(notify)
                    }) : deferred.reject("Not supported object type.")
                }, function (error) {
                    deferred.reject(error)
                }) : synchronizeToSFDC(param4Insert).then(function (result) {
                    deferred.resolve(result)
                }, function (error) {
                    deferred.reject(error)
                }, function (notify) {
                    deferred.notify(notify)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise) : (deferred.resolve(createSyncUpDefaultResult(objectName, SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_INSERT)), deferred.promise)
        }, syncUpNewAttachmentRecords = function (param, syncUpProcess, deferred) {
            var objectName = param.objectType, attachmentRecords = param.records, messageRecords = param.queueMessages,
                currentIndex = void 0 == param.currentIndex ? 0 : param.currentIndex + 1;
            param.currentIndex = currentIndex, deferred = deferred || $q.defer(), syncUpProcess || (syncUpProcess = createSyncUpDefaultResult(objectName, SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_INSERT), syncUpProcess.total = messageRecords.length);
            var actionBeforeResolve = function () {
                var ids = _.pluck(attachmentRecords, "Id");
                navigator.smartstore.upsertSoupEntries("Attachment", attachmentRecords, function () {
                    service.syncDownRecordsByIds("Attachment", ids, {_bodySynced: !0}).then(function () {
                        deferred.resolve(syncUpProcess)
                    }, function (error) {
                        deferred.reject("syncUpNewAttachmentRecords error: " + JSON.stringify(error))
                    })
                })
            }, queueMessage = messageRecords[currentIndex], attachment = attachmentRecords[currentIndex];
            if (queueMessage && attachment) {
                var commonErrorOperation = function (err) {
                    syncUpProcess.failed += 1, _updateQueueMessage(queueMessage, err), currentIndex <= messageRecords.length - 1 ? (deferred.notify(syncUpProcess), syncUpNewAttachmentRecords(param, syncUpProcess, deferred)) : actionBeforeResolve()
                };
                attachment.ParentId_type ? LocalDataService.queryConfiguredObjectByName(attachment.ParentId_type).then(function (relatedObjectType) {
                    FileService.getAttachmentBody(attachment, relatedObjectType).then(function (bodyContent) {
                        SalesforceDataService.createAttachment(attachment.ParentId, attachment.Name, attachment.Description, bodyContent, attachment.ContentType).then(function (result) {
                            result.success ? (attachment.Id = result.id, navigator.smartstore.removeFromSoup(SMARTSTORE_COMMON_SETTING.SOUP_NAME_QUEUE, [queueMessage._soupEntryId], function () {
                                currentIndex <= messageRecords.length - 1 ? (syncUpProcess.processed += 1, deferred.notify(syncUpProcess), syncUpNewAttachmentRecords(param, syncUpProcess, deferred)) : actionBeforeResolve()
                            })) : commonErrorOperation(result.errors + "")
                        }, function (err) {
                            commonErrorOperation(err)
                        })
                    }, function (err) {
                        commonErrorOperation(err)
                    })
                }, function (err) {
                    commonErrorOperation(err)
                }) : commonErrorOperation("The related object type of the Attachment record is undefined, please define the ParentId_type field.")
            } else actionBeforeResolve();
            return deferred.promise
        }, syncUpNewContentVersionRecords = function (param, syncUpProcess, deferred) {
            var objectName = param.objectType, contentVersionRecords = param.records,
                messageRecords = param.queueMessages,
                currentIndex = void 0 == param.currentIndex ? 0 : param.currentIndex + 1;
            param.currentIndex = currentIndex, deferred = deferred || $q.defer(), syncUpProcess || (syncUpProcess = createSyncUpDefaultResult(objectName, SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_INSERT), syncUpProcess.total = messageRecords.length);
            var actionBeforeResolve = function () {
                var ids = _.pluck(contentVersionRecords, "Id");
                navigator.smartstore.upsertSoupEntries("ContentVersion", contentVersionRecords, function () {
                    updateNewContentVersionRecords(ids).then(function () {
                        deferred.resolve(syncUpProcess)
                    }, function (error) {
                        deferred.reject("syncUpNewContentVersionRecords error: " + JSON.stringify(error))
                    })
                })
            }, queueMessage = messageRecords[currentIndex], contentVersion = contentVersionRecords[currentIndex];
            if (queueMessage && contentVersion) {
                var commonErrorOperation = function (err) {
                    syncUpProcess.failed += 1, _updateQueueMessage(queueMessage, err), currentIndex <= messageRecords.length - 1 ? (deferred.notify(syncUpProcess), syncUpNewContentVersionRecords(param, syncUpProcess, deferred)) : actionBeforeResolve()
                };
                FileService.getFileData({_soupEntryId: contentVersion.ContentDocumentId_sid}).then(function (bodyContent) {
                    SalesforceDataService.createContentVersion(contentVersion.ContentDocumentId, bodyContent, contentVersion.PathOnClient, contentVersion.Title, contentVersion.Description, contentVersion.NetworkId).then(function (result) {
                        result.success ? (contentVersion.Id = result.id, navigator.smartstore.removeFromSoup(SMARTSTORE_COMMON_SETTING.SOUP_NAME_QUEUE, [queueMessage._soupEntryId], function () {
                            currentIndex <= messageRecords.length - 1 ? (syncUpProcess.processed += 1, deferred.notify(syncUpProcess), syncUpNewContentVersionRecords(param, syncUpProcess, deferred)) : actionBeforeResolve()
                        })) : commonErrorOperation(result.errors + "")
                    }, function (err) {
                        commonErrorOperation(err)
                    })
                }, function (err) {
                    commonErrorOperation(err)
                })
            } else actionBeforeResolve();
            return deferred.promise
        }, updateNewContentVersionRecords = function (sfIds) {
            var deferred = $q.defer();
            return service.syncDownRecordsByIds("ContentVersion", sfIds, {_versionDataSynced: !0}, "ContentDocumentId_sid", !0).then(function (newContentVersions) {
                var contentDocumentSids = _.pluck(newContentVersions, "ContentDocumentId_sid");
                navigator.smartstore.retrieveSoupEntries("ContentDocument", contentDocumentSids, function (entries) {
                    for (var i = 0; i < entries.length; i++) {
                        var contentDocument = entries[i];
                        if (!contentDocument.Id) {
                            var contentVersion = _.findWhere(newContentVersions, {ContentDocumentId_sid: contentDocument._soupEntryId});
                            contentDocument.Id = contentVersion.ContentDocumentId
                        }
                    }
                    navigator.smartstore.upsertSoupEntries("ContentDocument", entries, function (newContentDocuments) {
                        var contentDocumentIds = _.pluck(newContentDocuments, "Id");
                        service.syncDownRecordsByIds("ContentDocument", contentDocumentIds).then(function () {
                            deferred.resolve()
                        }, function (error) {
                            deferred.reject("_syncDownNewVisibleSubsidiaryRecord error: " + JSON.stringify(error));
                        })
                    })
                })
            }, function (error) {
                deferred.reject("_syncDownNewVisibleSubsidiaryRecord error: " + JSON.stringify(error))
            }), deferred.promise
        }, _updateQueueMessage = function (queueMessage, errorMsg) {
            queueMessage.state = "error", queueMessage.error = errorMsg, navigator.smartstore.upsertSoupEntries(SMARTSTORE_COMMON_SETTING.SOUP_NAME_QUEUE, [queueMessage], function (success) {
            }, function (error) {
            })
        }, syncUpUpdateRecords = function (objectName, messageRecords) {
            var deferred = $q.defer();
            return messageRecords && 0 != messageRecords.length ? (queryRelatedRecords(messageRecords).then(function (result) {
                var param4Update = {
                    objectType: objectName,
                    operationType: SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_UPDATE,
                    records: result.records,
                    queueMessages: result.queueMessages
                };
                synchronizeToSFDC(param4Update).then(function (result) {
                    deferred.resolve(result)
                }, function (error) {
                    deferred.reject(error)
                }, function (notify) {
                    deferred.notify(notify)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise) : (deferred.resolve(createSyncUpDefaultResult(objectName, SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_UPDATE)), deferred.promise)
        }, syncUpDeleteRecords = function (objectName, messageRecords) {
            var deferred = $q.defer(), records2Delete = [];
            if (!messageRecords || 0 == messageRecords.length) return deferred.resolve(createSyncUpDefaultResult(objectName, SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_DELETE)), deferred.promise;
            angular.forEach(messageRecords, function (messageRecord) {
                records2Delete.push({Id: messageRecord.sfdcId})
            });
            var param4Delete = {
                objectType: objectName,
                operationType: SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_DELETE,
                records: records2Delete,
                queueMessages: messageRecords
            };
            return synchronizeToSFDC(param4Delete).then(function (result) {
                deferred.resolve(result)
            }, function (error) {
                deferred.reject(error)
            }, function (notify) {
                deferred.notify(notify)
            }), deferred.promise
        }, createSyncUpDefaultResult = function (objectName, operationType) {
            return {objectType: objectName, operationType: operationType, processed: 0, failed: 0, total: 0}
        }, queryRelatedRecords = function (queueMessages) {
            var deferred = $q.defer(), records = [], recordsQueueMessages = [];
            return queryQueuedRecords(queueMessages[0].objectName, _.pluck(queueMessages, "recordSoupEntryId")).then(function (result) {
                for (var i = 0; i < result.length; i++) {
                    var entry = result[i],
                        queueMessage = _.findWhere(queueMessages, {recordSoupEntryId: entry._soupEntryId});
                    queueMessage && (records.push(entry), recordsQueueMessages.push(queueMessage))
                }
                deferred.resolve({records: records, queueMessages: recordsQueueMessages})
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, synchronizeToSFDC = function (param) {
            var deferred = param.deferred || $q.defer(),
                objectType = (ForceClientService.getForceClient(), param.objectType),
                operationType = param.operationType, records = param.records, queueMessages = param.queueMessages,
                processed = param.processed || 0, failed = param.failed || 0,
                successSoupEntryIds = param.successSoupEntryIds || [], total = param.total || param.records.length,
                size = (param.done || !1, SYNC_PAGE_SIZE.SYNC_UP_RECORDS);
            records && (records = param.records.splice(0, size));
            var queueTimestamps = [];
            return queueMessages && (queueMessages = param.queueMessages.splice(0, size), queueTimestamps = _.pluck(queueMessages, "_soupLastModifiedDate")), LocalDataService.soqlFieldsForObjectType(objectType).then(function (queryFields) {
                adjustSyncUpRecords(objectType, records, operationType).then(function (newRecords) {
                    var payload = {
                        req: {
                            objectType: objectType,
                            operationType: operationType,
                            recordsJsonStr: JSON.stringify(newRecords),
                            selectedFields: queryFields.join(","),
                            queueTimestamps: queueTimestamps
                        }
                    };
                    RestService.syncRecordsToSfdc(payload).then(function (result) {
                        var nextParam = {
                                objectType: objectType,
                                operationType: operationType,
                                records: param.records,
                                queueMessages: param.queueMessages,
                                processed: processed,
                                failed: failed,
                                successSoupEntryIds: successSoupEntryIds,
                                total: total,
                                deferred: deferred
                            },
                            summaryResult = resetLocalDataBySyncResult(objectType, operationType, queueMessages, result, records);
                        nextParam.processed += records.length, nextParam.failed += summaryResult.failed, nextParam.successSoupEntryIds = nextParam.successSoupEntryIds.concat(summaryResult.successSoupEntryIds), 0 === param.records.length ? (nextParam.done = !0, deferred.resolve(nextParam)) : (deferred.notify(nextParam), synchronizeToSFDC(nextParam))
                    }, function (error) {
                        deferred.reject(error)
                    })
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, resetLocalDataBySyncResult = function (objectType, operationType, queueMessages, syncResults, records) {
            var summaryResult = {success: 0, failed: 0, successSoupEntryIds: []}, detailResults = [];
            if (detailResults = operationType !== SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_DELETE ? syncResults.upsertResults : syncResults.deleteResults, syncResults.success) {
                var removeQueues = [], updateQueues = [], updateRecords = [], removeRecords = [];
                angular.forEach(records, function (record, index) {
                    var queueMessage = queueMessages[index], syncResult = detailResults[index];
                    if (syncResult.isSuccess) {
                        if (summaryResult.success += 1, operationType !== SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_DELETE) if (syncResult.isOnlineDeleted === !0) removeRecords.push(record._soupEntryId); else {
                            var recordInSyncResult = syncResult.record;
                            recordInSyncResult && (record = angular.extend(record, recordInSyncResult), updateRecords.push(record)), summaryResult.successSoupEntryIds.push(record._soupEntryId)
                        }
                        removeQueues.push(queueMessage._soupEntryId)
                    } else summaryResult.failed += 1, queueMessage.state = "error", queueMessage.error = _.pluck(syncResult.errors, "message").join(";"), updateQueues.push(queueMessage), $log.log("Error during synchronization to Salesforce: " + JSON.stringify(queueMessage))
                }), removeQueues.length > 0 && navigator.smartstore.removeFromSoup(SMARTSTORE_COMMON_SETTING.SOUP_NAME_QUEUE, removeQueues, function (success) {
                }, function (err) {
                }), updateQueues.length > 0 && navigator.smartstore.upsertSoupEntries(SMARTSTORE_COMMON_SETTING.SOUP_NAME_QUEUE, updateQueues, function (success) {
                }, function (error) {
                }), updateRecords.length > 0 && navigator.smartstore.upsertSoupEntries(objectType, updateRecords, function (success) {
                }, function (err) {
                }), removeRecords.length > 0 && navigator.smartstore.removeFromSoup(objectType, removeRecords, function (success) {
                }, function (err) {
                })
            } else summaryResult.failed += records.length, angular.forEach(queueMessages, function (queueMessage) {
                queueMessage.state = "error", queueMessage.error = syncResults.message
            }), navigator.smartstore.upsertSoupEntries(SMARTSTORE_COMMON_SETTING.SOUP_NAME_QUEUE, queueMessages, function (success) {
            }, function (error) {
            });
            return summaryResult
        }, adjustSyncUpRecords = function (objectType, records, operationType) {
            var deferred = $q.defer();
            return lookupSFDCReference(objectType, records, operationType).then(function (newRecords) {
                DescribeService.getSObjectWritableFields(objectType).then(function (writableFields) {
                    operationType !== SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_INSERT && writableFields.push("Id");
                    var newObjs = [];
                    angular.forEach(newRecords, function (obj) {
                        var newObj = {};
                        angular.forEach(obj, function (value, fieldName) {
                            writableFields.indexOf(fieldName) !== -1 && (newObj[fieldName] = value)
                        }), newObjs.push(newObj)
                    }), deferred.resolve(newObjs)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, lookupSFDCReference = function (objectType, records, operationType) {
            var deferred = $q.defer();
            return operationType === SMARTSTORE_COMMON_SETTING.QUEUE_MESSAGE_ACTION_DELETE ? deferred.resolve(records) : DescribeService.getDescribeSObject(objectType).then(function (describeResult) {
                var promises = [];
                angular.forEach(describeResult.fields, function (fieldItem) {
                    if ("reference" === fieldItem.type) {
                        var fieldName = fieldItem.name,
                            referenceFieldName = fieldName + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_EXTENSION_SUFFIX,
                            referenceFieldType = fieldName + SMARTSTORE_COMMON_SETTING.REFERENCED_FIELD_TYPE_SUFFIX,
                            sids = [], types = [];
                        if (angular.forEach(records, function (record) {
                            var sidValue = record[referenceFieldName], typeValue = record[referenceFieldType];
                            sidValue && sids.indexOf(sidValue) === -1 && !record[fieldName] && (sids.push(sidValue), types.push(typeValue))
                        }), 0 === sids.length) return;
                        var promise = querySFIdAccordingToSid(sids, types, fieldItem.referenceTo).then(function (sidSFId) {
                            angular.forEach(records, function (record) {
                                var sidValue = record[referenceFieldName];
                                sidValue && !record[fieldName] && (record[fieldName] = sidSFId[sidValue])
                            })
                        }, function (error) {
                            deferred.reject(error)
                        });
                        promises.push(promise)
                    }
                }), $q.all(promises).then(function () {
                    LocalDataService.upsert(objectType, records, !0).then(function () {
                        deferred.resolve(records)
                    }, function (error) {
                        deferred.reject(error)
                    })
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, querySFIdAccordingToSid = function (sids, types, referenceTo) {
            var deferred = $q.defer(), result = [];
            if (referenceTo && 0 !== referenceTo.length && sids && 0 !== sids.length) {
                for (var referenceType, typeSids = {}, i = 0; i < sids.length; i++) referenceType = types[i], null != referenceType && void 0 != referenceType || (referenceType = referenceTo[0]), null == typeSids[referenceType] && (typeSids[referenceType] = []), typeSids[referenceType].push(sids[i]);
                var doQuerySFIdAccordingToSid = function (referenceSoup, referenceSids) {
                    var deferred = $q.defer();
                    return $injector.get("SmartStoreService").checkSoupExist(referenceSoup).then(function (exists) {
                        if (exists) {
                            var smartSql = "select {" + referenceSoup + ":_soupEntryId}, {" + referenceSoup + ":Id} from {" + referenceSoup + "} ";
                            smartSql += "where {" + referenceSoup + ":_soupEntryId} in (" + referenceSids.join(",") + ")";
                            var querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
                            navigator.smartstore.runSmartQuery(!1, querySpec, function (cursor) {
                                var currentPageEntries = cursor.currentPageOrderedEntries;
                                angular.forEach(currentPageEntries, function (referenceItem) {
                                    result[referenceItem[0]] = referenceItem[1]
                                }), deferred.resolve(result)
                            }, function (err) {
                                deferred.reject(err)
                            })
                        } else deferred.resolve(result)
                    }, function (err) {
                        deferred.reject(err)
                    }), deferred.promise
                }, promises = [];
                for (var referenceTypeAttr in typeSids) promises.push(doQuerySFIdAccordingToSid(referenceTypeAttr, typeSids[referenceTypeAttr]));
                $q.all(promises).then(function () {
                    deferred.resolve(result)
                }, function (err) {
                    deferred.reject(err)
                })
            } else deferred.resolve(result);
            return deferred.promise
        };
        service.prepareMobileConfigurationForSync = function () {
            var deferred = $q.defer(), objectSyncWrapper = initializeObjectSyncWrapper();
            return ConfigurationService.mobileConfigurationToSynchronize().then(function (objectTypes) {
                objectSyncWrapper.syncDownObjects.objectTypes = objectTypes, objectSyncWrapper.syncDownObjects.syncProgress = service.initializeSyncDownProgress(objectTypes), objectSyncWrapper.syncDownObjects.ignoreLocalReference = !0, deferred.resolve(objectSyncWrapper)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        var initializeObjectSyncWrapper = function () {
            return {
                syncUpObjects: {objectTypes: [], syncProgress: {}},
                syncDownObjects: {objectTypes: [], syncProgress: {}},
                cleanUpObjects: {objectTypes: [], syncProgress: {}}
            }
        };
        service.prepareBusinessObjectTypeForSync = function () {
            var deferred = $q.defer(), objectSyncWrapper = initializeObjectSyncWrapper();
            return ConfigurationService.objectTypesToSynchronize().then(function (objectTypes) {
                for (var i = 0; i < objectTypes.length; i++) objectTypes[i].needSyncUp = !0, objectTypes[i].needSyncDown = !0;
                objectSyncWrapper.syncUpObjects.objectTypes = objectTypes, objectSyncWrapper.syncUpObjects.syncProgress = service.initializeSyncUpProgress(objectTypes), objectSyncWrapper.syncDownObjects.objectTypes = objectTypes, objectSyncWrapper.syncDownObjects.syncProgress = service.initializeSyncDownProgress(objectTypes), objectSyncWrapper.cleanUpObjects.objectTypes = objectTypes, objectSyncWrapper.cleanUpObjects.syncProgress = service.initializeCleanUpProgress(objectTypes), deferred.resolve(objectSyncWrapper)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        var checkObjectTypesBeforeSynchronize = function (objectSyncWrapper) {
            for (var deferred = $q.defer(), objectTypes = objectSyncWrapper.syncDownObjects.objectTypes, objectTypeNames = [], objectTypeSoupEntryIds = [], i = 0; i < objectTypes.length; i++) {
                var objectType = objectTypes[i];
                objectTypeNames.push(objectType.name), objectTypeSoupEntryIds.push(objectType._soupEntryId)
            }
            return fetchCheckedObjectTypes(objectTypeNames).then(function (onlineObjectsInfo) {
                if (onlineObjectsInfo) {
                    var updateFilterCriteria = function () {
                        for (var objects2upsert = [], i = 0; i < objectTypes.length; i++) {
                            var objectType = objectTypes[i], objInfo = onlineObjectsInfo[objectType.name];
                            objInfo && objInfo.count && 0 !== objInfo.count || (objectType.needSyncDown = !1), objInfo && objects2upsert.push({
                                _soupEntryId: objectType._soupEntryId,
                                MobileVizArt__Filter_Criteria__c: objInfo.filterCriteria
                            })
                        }
                        APP_SETTINGS.LOCAL_CONFIGURATION === !1 && objects2upsert.length > 0 ? LocalDataService.getSObjects("_object", objectTypeSoupEntryIds).then(function (localObjects) {
                            for (var i = 0; i < objects2upsert.length; i++) {
                                var localObj = _.findWhere(localObjects, {_soupEntryId: objects2upsert[i]._soupEntryId});
                                localObj.MobileVizArt__Filter_Criteria__c = objects2upsert[i].MobileVizArt__Filter_Criteria__c, objects2upsert[i] = localObj
                            }
                            LocalDataService.upsert("_object", objects2upsert, !0).then(function () {
                                deferred.resolve(objectTypes)
                            }, function (err) {
                                deferred.reject(err)
                            })
                        }, function (error) {
                            deferred.reject(error)
                        }) : deferred.resolve(objectTypes)
                    };
                    onlineObjectsInfo.sharingUpdatedTimeValue ? MetaService.getMetaValue("lastCleanUpDate").then(function (lastCleanUpDate) {
                        lastCleanUpDate && new Date(onlineObjectsInfo.sharingUpdatedTimeValue) > new Date(lastCleanUpDate) && (objectSyncWrapper.cleanUpObjects.forceCleanup = !0), updateFilterCriteria()
                    }, function (err) {
                        deferred.reject(err)
                    }) : updateFilterCriteria()
                } else deferred.resolve(objectTypes)
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, fetchCheckedObjectTypes = function (objectTypeNames) {
            return $q(function (resolve, reject) {
                for (var _lastSyncDownDate, getObjectLastSyncDownDatePromiseArr = [], hasNullLastSyncDownDate = !1, i = 0; i < objectTypeNames.length; i++) {
                    var objName = objectTypeNames[i];
                    getObjectLastSyncDownDatePromiseArr.push(MetaService.getObjectMetaByType(objName).then(function (meta) {
                        meta && meta.lastSyncDownDate ? (!_lastSyncDownDate || _lastSyncDownDate > meta.lastSyncDownDate) && (_lastSyncDownDate = meta.lastSyncDownDate) : meta && skipSyncDownObjects.indexOf(meta.name) === -1 && (hasNullLastSyncDownDate = !0)
                    }, function (err) {
                    }))
                }
                $q.all(getObjectLastSyncDownDatePromiseArr).then(function () {
                    if (!_lastSyncDownDate || hasNullLastSyncDownDate) return void resolve(null);
                    var currentUser = LocalCacheService.get("currentUser");
                    if (currentUser) {
                        var profileId = currentUser.ProfileId;
                        LocalDataService.queryConfigurationAndObjects(profileId).then(function (configuration) {
                            if (configuration) {
                                var parseResp = function (response) {
                                    var result = {};
                                    if (response && (result.timeStamp = response.timeStamp, result.sharingUpdatedTimeValue = response.sharingUpdatedTimeValue, response.objectTypes)) for (var i = 0; i < response.objectTypes.length; i++) {
                                        var objInfo = response.objectTypes[i];
                                        objectTypeNames.indexOf(objInfo.objectType) > -1 && (result[objInfo.objectType] = objInfo)
                                    }
                                    return result
                                }, postBody = {clsRequest: {timeStamp: _lastSyncDownDate}};
                                if (configuration.MobileVizArt__Cleanup_Online_Field__c && (postBody.clsRequest.sharingUpdatedTimeField = configuration.MobileVizArt__Cleanup_Online_Field__c), APP_SETTINGS.LOCAL_CONFIGURATION === !0) {
                                    var objectConfig = [];
                                    if (configuration.objects) for (var i = 0; i < configuration.objects.length; i++) {
                                        var objItem = configuration.objects[i];
                                        objectTypeNames.indexOf(objItem.Name) !== -1 && skipSyncDownObjects.indexOf(objItem.Name) === -1 && objectConfig.push({
                                            name: objItem.Name,
                                            filterCriteria: objItem.MobileVizArt__Filter_Criteria__c,
                                            lookupModStamp: objItem.MobileVizArt__Lookup_Mod_Stamp__c
                                        })
                                    }
                                    postBody.clsRequest.objectConfig = objectConfig, RestService.checkObjectTypesToSynchronize(postBody).then(function (result) {
                                        resolve(parseResp(result))
                                    }, function (error) {
                                        error && error.rawException && error.rawException.responseJSON && "NOT_FOUND" === error.rawException.responseJSON[0].errorCode ? ($log.debug(error), resolve(null)) : reject(error)
                                    })
                                } else postBody.clsRequest.confId = configuration.Id, RestService.checkObjectTypesToSynchronize(postBody).then(function (result) {
                                    resolve(parseResp(result))
                                }, function (error) {
                                    reject(error)
                                })
                            } else reject("No configuration found.")
                        }, reject)
                    } else reject("Failed to get basic information of the current login user.")
                }, reject)
            })
        };
        service.initializeSyncUpProgress = function (objectTypes) {
            var syncUpProgress = {};
            return angular.forEach(objectTypes, function (objectType) {
                var entry = {
                    name: objectType.name,
                    label: objectType.label,
                    status: {
                        inserted: 0,
                        insertFailed: 0,
                        insertTotal: 0,
                        updated: 0,
                        updateFailed: 0,
                        updateTotal: 0,
                        deleted: 0,
                        deleteFailed: 0,
                        deleteTotal: 0
                    }
                };
                syncUpProgress[objectType.name] = entry
            }), syncUpProgress
        }, service.initializeSyncDownProgress = function (objectTypes) {
            var syncDownProgress = {};
            return angular.forEach(objectTypes, function (objectType) {
                var entry = {name: objectType.name, label: objectType.label, status: {processed: 0, total: 0}};
                syncDownProgress[objectType.name] = entry
            }), syncDownProgress
        }, service.initializeCleanUpProgress = function (objectTypes) {
            var cleanUpProgress = {};
            return angular.forEach(objectTypes, function (objectType) {
                var entry = {
                    name: objectType.name,
                    label: objectType.label,
                    status: {
                        deltaSharedProcessed: 0,
                        deltaSharedTotal: 0,
                        checkDirtyProcessed: 0,
                        checkDirtyTotal: 0,
                        newVisiableRecords: 0,
                        dirtyRecords: 0
                    }
                };
                cleanUpProgress[objectType.name] = entry
            }), cleanUpProgress
        }, service.syncUpObjectByName = function (objectName) {
            var deferred = $q.defer();
            $log.debug(">>>> sync up a special object named " + objectName + " beginning.");
            var handleError = function (error) {
                error && "function" == typeof error.handle ? (error.retry = service.syncUpObjectByName, error.retryContext = service, error.retryParam = objectName, error.retryDeferred = deferred, error.handle()) : new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, error.message, error.stack, error, service.syncUpObjectByName, null, service, objectName, deferred).handle(), deferred.reject(error)
            }, objectSyncWrapper = initializeObjectSyncWrapper();
            return ConfigurationService.objectTypesToSynchronize().then(function (objectTypes) {
                var obj2SyncUp = [];
                angular.forEach(objectTypes, function (objectType) {
                    objectType.name == objectName && (obj2SyncUp.push(objectType), objectType.needSyncUp = !0, objectType.needSyncDown = !1, objectType.needCleanUp = !1)
                }), objectSyncWrapper.syncUpObjects.objectTypes = obj2SyncUp, objectSyncWrapper.syncUpObjects.syncProgress = service.initializeSyncUpProgress(obj2SyncUp), objectSyncWrapper.syncDownObjects.objectTypes = [], objectSyncWrapper.syncDownObjects.syncProgress = service.initializeSyncDownProgress([]), objectSyncWrapper.cleanUpObjects.objectTypes = [], objectSyncWrapper.cleanUpObjects.syncProgress = service.initializeCleanUpProgress([]), service.startSync(objectSyncWrapper).then(function (objectSyncResult) {
                    $log.debug(">>>> sync up a special object named " + objectName + " ended."), deferred.resolve(objectSyncResult)
                }, function (error) {
                    handleError(error)
                }, function (process) {
                    deferred.notify(process)
                })
            }, function (error) {
                handleError(error)
            }), deferred.promise
        }, service.syncUpObjectByAll = function () {
            var deferred = $q.defer();
            $log.debug(">>>> sync up all object beginning.");
            var handleError = function (error) {
                error && "function" == typeof error.handle ? (error.retry = service.syncUpObjectByAll, error.retryDeferred = deferred, error.handle()) : new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, error.message, error.stack, error, service.syncUpObjectByAll, null, null, null, deferred).handle(), deferred.reject(error)
            }, objectSyncWrapper = initializeObjectSyncWrapper();
            return ConfigurationService.objectTypesToSynchronize().then(function (objectTypes) {
                angular.forEach(objectTypes, function (objectType) {
                    objectType.needSyncUp = !0, objectType.needSyncDown = !1, objectType.needCleanUp = !1
                }), objectSyncWrapper.syncUpObjects.objectTypes = objectTypes, objectSyncWrapper.syncUpObjects.syncProgress = service.initializeSyncUpProgress(objectTypes), objectSyncWrapper.syncDownObjects.objectTypes = [], objectSyncWrapper.syncDownObjects.syncProgress = service.initializeSyncDownProgress([]), objectSyncWrapper.cleanUpObjects.objectTypes = [], objectSyncWrapper.cleanUpObjects.syncProgress = service.initializeCleanUpProgress([]), service.startSync(objectSyncWrapper).then(function (objectSyncResult) {
                    $log.debug(">>>> sync up all object ended."), deferred.resolve(objectSyncResult)
                }, function (error) {
                    handleError(error)
                }, function (process) {
                    deferred.notify(process)
                })
            }, function (error) {
                handleError(error)
            }), deferred.promise
        }, service.cleanUpObjectsByNames = function (objectNames) {
            var deferred = $q.defer();
            if (objectNames && 0 === objectNames.length) return deferred.resolve({}), deferred.promise;
            var handleError = function (error) {
                error && "function" == typeof error.handle ? (error.retry = service.cleanUpObjectsByNames, error.retryContext = service, error.retryParam = objectNames, error.retryDeferred = deferred, error.handle()) : new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, error.message, error.stack, error, service.cleanUpObjectsByNames, null, service, objectNames, deferred).handle(), deferred.reject(error)
            }, objectSyncWrapper = initializeObjectSyncWrapper();
            return ConfigurationService.objectTypesToSynchronize().then(function (objectTypes) {
                for (var obj2CleanUp = [], i = 0; i < objectTypes.length; i++) {
                    var objectType = objectTypes[i];
                    objectNames && objectNames.indexOf(objectType.name) === -1 && skipCleanUpObjects.indexOf(objectType.name) === -1 || (obj2CleanUp.push(objectType), objectType.needSyncUp = !1, objectType.needSyncDown = !1, objectType.needCleanUp = !0)
                }
                objectSyncWrapper.syncUpObjects.objectTypes = [], objectSyncWrapper.syncUpObjects.syncProgress = service.initializeSyncUpProgress([]), objectSyncWrapper.syncDownObjects.objectTypes = [], objectSyncWrapper.syncDownObjects.syncProgress = service.initializeSyncDownProgress([]), objectSyncWrapper.cleanUpObjects.objectTypes = obj2CleanUp, objectSyncWrapper.cleanUpObjects.forceCleanup = !0, objectSyncWrapper.cleanUpObjects.noNeedLastCleanupDate = !0, objectSyncWrapper.cleanUpObjects.syncProgress = service.initializeCleanUpProgress(obj2CleanUp), service.startSync(objectSyncWrapper).then(function (objectSyncResult) {
                    deferred.resolve(objectSyncResult)
                }, function (error) {
                    handleError(error)
                }, function (process) {
                    deferred.notify(process)
                })
            }, function (error) {
                handleError(error)
            }), deferred.promise
        }
    }])
}(angular, _), function (angular) {
    "use strict";
    angular.module("oinio.core").service("LocalesService", ["$http", "$log", "$locale", function ($http, $log, $locale) {
        var localesInfo = {}, defaultLocale = "en_US", defaultLocaleInfo = {}, currencySymbol = "$",
            currencySymbolBefore = !0, defaultCurrencyISOCode = "EUR";
        this.loadLocaleData = function (userLocale) {
            $http.get("app/common/i18n/locales.json").success(function (response) {
                for (var i = 0; i < response.locales.length; i++) {
                    var value = response.locales[i];
                    if (value.locale === defaultLocale && (defaultLocaleInfo = value.pattern), value.locale === userLocale) {
                        localesInfo = value.pattern, $log.debug("Locales Info: " + JSON.stringify(localesInfo));
                        break
                    }
                }
                if (0 === Object.keys(localesInfo).length && (localesInfo = defaultLocaleInfo, $log.debug("Default Locales Info: " + JSON.stringify(localesInfo))), localesInfo.currencyPattern) {
                    var startOfCurrency = localesInfo.currencyPattern.indexOf("["),
                        endOfCurrency = localesInfo.currencyPattern.indexOf("]");
                    currencySymbol = localesInfo.currencyPattern.slice(startOfCurrency + 1, endOfCurrency), $locale.NUMBER_FORMATS.CURRENCY_SYM = currencySymbol, currencySymbolBefore = 0 === startOfCurrency
                }
                localesInfo.thousandsSeparator && ($locale.NUMBER_FORMATS.GROUP_SEP = localesInfo.thousandsSeparator), localesInfo.decimalSeparator && ($locale.NUMBER_FORMATS.DECIMAL_SEP = localesInfo.decimalSeparator)
            }).error(function (error) {
                $log.debug("Error loading the Locales Info" + error)
            })
        }, this.setCurrencyIsoCode = function (currencyCode) {
            defaultCurrencyISOCode = currencyCode
        }, this.getCurrencyIsoCode = function () {
            return defaultCurrencyISOCode
        }, this.getDateFormat = function () {
            return localesInfo.datePattern ? localesInfo.datePattern : defaultLocaleInfo.datePattern
        }, this.getTimeFormat = function () {
            return localesInfo.timePattern ? localesInfo.timePattern : defaultLocaleInfo.timePattern
        }, this.getDateTimeFormat = function () {
            return localesInfo.dateTimePattern ? localesInfo.dateTimePattern : defaultLocaleInfo.dateTimePattern
        }, this.getCurrencyFormat = function () {
            return localesInfo.currencyPattern ? localesInfo.currencyPattern : defaultLocaleInfo.currencyPattern
        }, this.getCurrencySymbol = function () {
            return currencySymbol
        }, this.getCurrencySymbolBefore = function () {
            return currencySymbolBefore
        }, this.getDecimalSeparator = function () {
            return localesInfo.decimalSeparator ? localesInfo.decimalSeparator : defaultLocaleInfo.decimalSeparator
        }, this.getThousandsSeparator = function () {
            return localesInfo.thousandsSeparator ? localesInfo.thousandsSeparator : defaultLocaleInfo.thousandsSeparator
        }, this.getNumberFormat = function () {
            return localesInfo.numberPattern ? localesInfo.numberPattern : defaultLocaleInfo.numberPattern
        }, this.getDecimalPlaces = function () {
            if (localesInfo.numberPattern) {
                var decimalPlace = localesInfo.numberPattern.indexOf(this.getDecimalSeparator()) + 1;
                return localesInfo.numberPattern.length - decimalPlace
            }
            return 3
        }, this.getAddressFormat = function () {
            return localesInfo.addressPattern ? localesInfo.addressPattern : defaultLocaleInfo.addressPattern
        }
    }])
}(angular), function (angular) {
    "use strict";
    angular.module("oinio.core").service("MetaService", ["$q", "$filter", "$log", "$cordovaAppVersion", "SMARTSTORE_COMMON_SETTING", function ($q, $filter, $log, $cordovaAppVersion, SMARTSTORE_COMMON_SETTING) {
        var service = this, objectMetaSoup = "_objectMeta", metaSoup = "_meta";
        service.initializeMetaDataForObjectTypes = function (objectTypes) {
            var deferred = $q.defer(), entries = [],
                querySpec = navigator.smartstore.buildAllQuerySpec("name", null, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
            return navigator.smartstore.querySoup(objectMetaSoup, querySpec, function (cursor) {
                var currentPageEntries = cursor.currentPageOrderedEntries;
                angular.forEach(objectTypes, function (objType) {
                    var existEntry = $filter("filter")(currentPageEntries, {name: objType}, !0);
                    if (void 0 === existEntry || 0 === existEntry.length) {
                        var entry = {
                            name: objType,
                            lastSyncDownDate: null,
                            lastSyncUpDate: null,
                            lastCleanUpDate: null,
                            lastCleanUpDateForNewShare: null,
                            lastCheckDescribeDate: null
                        };
                        entries.push(entry)
                    }
                }), entries.length > 0 ? navigator.smartstore.upsertSoupEntries(!1, objectMetaSoup, entries, function () {
                    deferred.resolve(!0)
                }, function (error) {
                    deferred.reject(error)
                }) : deferred.resolve(!0)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.getObjectMetaByType = function (objectType) {
            var deferred = $q.defer(), querySpec = navigator.smartstore.buildExactQuerySpec("name", objectType, 1);
            return navigator.smartstore.querySoup(!1, objectMetaSoup, querySpec, function (cursor) {
                var meta, currentPageEntries = cursor.currentPageOrderedEntries;
                meta = currentPageEntries && currentPageEntries.length > 0 ? currentPageEntries[0] : {
                    name: objectType,
                    lastSyncDownDate: null,
                    lastSyncUpDate: null,
                    lastCleanUpDate: null,
                    lastCleanUpDateForNewShare: null,
                    lastCheckDescribeDate: null
                }, deferred.resolve(meta)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.updateLastSyncDownDate = function (objectType, lastSyncDownDate) {
            var deferred = $q.defer();
            return service.getObjectMetaByType(objectType).then(function (meta) {
                meta || (meta = {name: objectType}), meta.lastSyncDownDate = lastSyncDownDate, updateMetaValue(objectMetaSoup, meta, "name").then(function (upsertedMeta) {
                    deferred.resolve(upsertedMeta)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.updateLastSyncUpDate = function (objectType, lastSyncUpDate) {
            var deferred = $q.defer();
            return service.getObjectMetaByType(objectType).then(function (meta) {
                meta || (meta = {name: objectType}), meta.lastSyncUpDate = lastSyncUpDate, updateMetaValue(objectMetaSoup, meta, "name").then(function (upsertedMeta) {
                    deferred.resolve(upsertedMeta)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.updateLastCleanUpDateForNewShare = function (objectType, lastCleanUpDateForNewShare) {
            var deferred = $q.defer();
            return service.getObjectMetaByType(objectType).then(function (meta) {
                meta || (meta = {name: objectType}), meta.lastCleanUpDateForNewShare = lastCleanUpDateForNewShare, updateMetaValue(objectMetaSoup, meta, "name").then(function (upsertedMeta) {
                    deferred.resolve(upsertedMeta)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.updateLastCleanUpDate = function (objectType, lastCleanUpDate) {
            var deferred = $q.defer();
            return service.getObjectMetaByType(objectType).then(function (meta) {
                meta || (meta = {name: objectType}), meta.lastCleanUpDate = lastCleanUpDate, updateMetaValue(objectMetaSoup, meta, "name").then(function (upsertedMeta) {
                    deferred.resolve(upsertedMeta)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.updateLastCheckDescribeDate = function (objectType, lastCheckDescribeDate) {
            var deferred = $q.defer();
            return service.getObjectMetaByType(objectType).then(function (meta) {
                meta || (meta = {name: objectType}), meta.lastCheckDescribeDate = lastCheckDescribeDate, updateMetaValue(objectMetaSoup, meta, "name").then(function (upsertedMeta) {
                    deferred.resolve(upsertedMeta)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        var updateMetaValue = function (soup, meta, key) {
            var deferred = $q.defer();
            return navigator.smartstore.upsertSoupEntriesWithExternalId(!1, soup, [meta], key, function (result) {
                deferred.resolve(result)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        service.setMetaValue = function (key, value) {
            var deferred = $q.defer(), meta = {key: key, value: value};
            return $log.debug(">>>> set meta value for key: " + key + " meta:" + JSON.stringify(meta)), updateMetaValue(metaSoup, meta, "key").then(function (result) {
                deferred.resolve(result)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.getMetaValue = function (key) {
            var deferred = $q.defer(), querySpec = navigator.smartstore.buildExactQuerySpec("key", key, 1);
            return navigator.smartstore.querySoup(!1, metaSoup, querySpec, function (cursor) {
                var currentPageEntries = cursor.currentPageOrderedEntries, metaValue = null;
                currentPageEntries && currentPageEntries.length > 0 && (metaValue = currentPageEntries[0].value), deferred.resolve(metaValue)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.getMetaValueEnhance = function (key) {
            var deferred = $q.defer();
            return navigator.smartstore.soupExists(!1, metaSoup, function (exists) {
                exists ? service.getMetaValue(key).then(function (metaValue) {
                    deferred.resolve(metaValue)
                }, function (error) {
                    deferred.reject(error)
                }) : deferred.resolve()
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.appInitialized = function () {
            var deferred = $q.defer();
            return service.getMetaValue("initialized").then(function (initialized) {
                deferred.resolve(null !== initialized)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.setAppInitialized = function () {
            service.setMetaValue("initialized", !0), service.getMetaValue("lastCleanUpDate").then(function (lastCleanUpDate) {
                lastCleanUpDate || service.setMetaValue("lastCleanUpDate", new Date)
            }, function (error) {
                $log.debug(error)
            })
        }, service.soupInitialized = function () {
            var deferred = $q.defer();
            return navigator.smartstore.soupExists(!1, metaSoup, function (exists) {
                exists ? service.getMetaValue("setupsoup").then(function (setupsoup) {
                    deferred.resolve(null !== setupsoup)
                }, function (error) {
                    deferred.reject(error)
                }) : deferred.resolve(!1)
            }, function (error) {
                error.method = "meta.service::soupInitialized->soupExists", $log.debug(error), deferred.reject(error)
            }), deferred.promise
        }, service.setSoupInitialized = function () {
            service.setMetaValue("setupsoup", !0)
        }, service.setAppVersion = function () {
            $cordovaAppVersion.getVersionNumber().then(function (appVersion) {
                service.setMetaValue("appVersion", appVersion)
            }, function (error) {
                $log.debug(error)
            })
        }
    }])
}(angular), function (angular) {
    "use strict";
    angular.module("oinio.core").service("PicklistService", ["$q", function ($q) {
        function getPicklistFields(layoutResult) {
            var picklistFields = [];
            return angular.forEach(layoutResult.detailLayoutSections, function (editLayoutSection) {
                editLayoutSection && angular.forEach(editLayoutSection.layoutRows, function (layoutRow) {
                    layoutRow && angular.forEach(layoutRow.layoutItems, function (layoutItem) {
                        layoutItem && angular.forEach(layoutItem.layoutComponents, function (layoutComponent) {
                            if (layoutComponent && layoutComponent.details) {
                                var fieldDetails = layoutComponent.details;
                                "picklist" !== fieldDetails.type && "multipicklist" !== fieldDetails.type || picklistFields.push(fieldDetails)
                            }
                        })
                    })
                })
            }), picklistFields
        }

        var service = this, picklistsSoup = "_picklists";
        service.loadAllPicklists = function (describeLayoutResults) {
            var deferred = $q.defer(), promises = [];
            return angular.forEach(describeLayoutResults, function (describeLayoutResult) {
                promises.push(service.loadPicklists(describeLayoutResult))
            }), $q.all(promises).then(function () {
                deferred.resolve(!0)
            }, function () {
                deferred.reject(!1)
            }), deferred.promise
        }, service.loadPicklists = function (describeLayoutResult) {
            var deferred = $q.defer();
            return angular.forEach(describeLayoutResult.describeLayouts, function (describeLayout) {
                var picklistFields = getPicklistFields(describeLayout.layoutResult), picklistEntries = [],
                    getRecordTypeDeveloperNamePromises = [];
                angular.forEach(picklistFields, function (fieldDetails) {
                    getRecordTypeDeveloperNamePromises.push($q(function (resolve, reject) {
                        var querySpec = navigator.smartstore.buildExactQuerySpec("Id", describeLayout.recordTypeId, 1);
                        navigator.smartstore.querySoup("RecordType", querySpec, function (cursor) {
                            var result = cursor && cursor.currentPageOrderedEntries && cursor.currentPageOrderedEntries.length ? cursor.currentPageOrderedEntries[0] : null,
                                uniqueExternalKey = service.getUniqueExternalKey(describeLayoutResult.objectType, describeLayout.recordTypeId, fieldDetails.name),
                                uniqueExternalDeveloperNameKey = null;
                            result && (uniqueExternalDeveloperNameKey = service.getUniqueExternalKey(describeLayoutResult.objectType, result.DeveloperName, fieldDetails.name));
                            var picklistEntry = {
                                objectName: describeLayoutResult.objectType,
                                fieldName: fieldDetails.name,
                                recordTypeId: describeLayout.recordTypeId,
                                dependentPicklist: fieldDetails.dependentPicklist,
                                controllerName: fieldDetails.controllerName,
                                uniqueExternalKey: uniqueExternalKey,
                                picklistValues: []
                            };
                            uniqueExternalDeveloperNameKey && (picklistEntry.uniqueExternalDeveloperNameKey = uniqueExternalDeveloperNameKey), angular.forEach(fieldDetails.picklistValues, function (picklistValue) {
                                var picklistValueEntry = {
                                    masterValue: picklistValue.value,
                                    active: picklistValue.active,
                                    defaultValue: picklistValue.defaultValue,
                                    label: picklistValue.label,
                                    validFor: picklistValue.validFor
                                };
                                picklistEntry.picklistValues.push(picklistValueEntry)
                            }), picklistEntries.push(picklistEntry), resolve(!0)
                        }, reject)
                    }))
                }), $q.all(getRecordTypeDeveloperNamePromises).then(function () {
                    navigator.smartstore.upsertSoupEntriesWithExternalId(!1, picklistsSoup, picklistEntries, "uniqueExternalKey", function () {
                        deferred.resolve(!0)
                    }, function (error) {
                        deferred.reject(error)
                    })
                }, function (err) {
                    deferred.reject(err)
                })
            }), deferred.promise
        }, service.getPicklistEntry = function (objectName, fieldName, recordType, recordTypeIsName) {
            var querySpec, deferred = $q.defer(),
                queryUniqueKey = service.getUniqueExternalKey(objectName, recordType, fieldName);
            return querySpec = recordTypeIsName ? navigator.smartstore.buildExactQuerySpec("uniqueExternalDeveloperNameKey", queryUniqueKey, 1) : navigator.smartstore.buildExactQuerySpec("uniqueExternalKey", queryUniqueKey, 1), navigator.smartstore.querySoup(!1, picklistsSoup, querySpec, function (cursor) {
                var result = cursor && cursor.currentPageOrderedEntries && cursor.currentPageOrderedEntries.length ? cursor.currentPageOrderedEntries[0] : null;
                result ? deferred.resolve(result) : deferred.resolve({})
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.getUniqueExternalKey = function (objectName, recordTypeId, fieldName) {
            var separator = "|";
            return objectName + separator + recordTypeId + separator + fieldName
        }
    }])
}(angular), function (angular) {
    "use strict";
    angular.module("oinio.core").service("RecordTypeService", ["$q", "$filter", "$log", "SMARTSTORE_COMMON_SETTING", "SalesforceDataService", function ($q, $filter, $log, SMARTSTORE_COMMON_SETTING, SalesforceDataService) {
        function storeRecordTypeData(recordTypeData) {
            var deferred = $q.defer(), existRecordTypeIds = [];
            angular.forEach(recordTypeData, function (rtItem) {
                existRecordTypeIds.push(rtItem.Id)
            }), existRecordTypeIds.push(MasterRecordTypeId);
            var smartSql = "select * from {" + recordTypeSoup + "} where {" + recordTypeSoup + ":Id} not in (" + contactArrayToString(existRecordTypeIds) + ")",
                querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
            return navigator.smartstore.runSmartQuery(!1, querySpec, function (cursor) {
                var currentPageEntries = cursor.currentPageOrderedEntries;
                navigator.smartstore.removeFromSoup(!1, recordTypeSoup, currentPageEntries, function () {
                    navigator.smartstore.upsertSoupEntriesWithExternalId(!1, recordTypeSoup, recordTypeData, "Id", function () {
                        deferred.resolve(!0)
                    }, function (error) {
                        deferred.reject(error)
                    })
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }

        function contactArrayToString(arr) {
            var str = "";
            return angular.forEach(arr, function (item) {
                "" !== str && (str += ","), str += "'" + item + "'"
            }), "" === str && (str = "''"), str
        }

        var service = this, recordTypeSoup = "RecordType", MasterRecordTypeId = "012000000000000AAA";
        service.syncDownAllRecordType = function (recordTypeIds) {
            var deferred = $q.defer(),
                soql = "SELECT Id, toLabel(Name), DeveloperName, SobjectType FROM RecordType WHERE IsActive = true AND Id IN (" + contactArrayToString(recordTypeIds) + ")";
            return SalesforceDataService.queryAll(soql).then(function (result) {
                storeRecordTypeData(result).then(function () {
                    deferred.resolve(!0)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.storeDummyRecordType = function (sobjectTypes) {
            var deferred = $q.defer(), recordTypeData = [],
                smartSql = "select * from {" + recordTypeSoup + "} where {" + recordTypeSoup + ":Id} = '" + MasterRecordTypeId + "'",
                querySpec = navigator.smartstore.buildSmartQuerySpec(smartSql, SMARTSTORE_COMMON_SETTING.PAGE_SIZE_FOR_ALL);
            return navigator.smartstore.runSmartQuery(!1, querySpec, function (cursor) {
                var currentPageEntries = cursor.currentPageOrderedEntries;
                angular.forEach(sobjectTypes, function (sobjectType) {
                    var existEntry = $filter("filter")(currentPageEntries, {SobjectType: sobjectType}, !0);
                    if (void 0 === existEntry || 0 === existEntry.length) {
                        var recordType = {
                            DeveloperName: "Master",
                            Name: "Master",
                            SobjectType: sobjectType,
                            Id: MasterRecordTypeId
                        };
                        recordTypeData.push(recordType)
                    }
                }), recordTypeData.length > 0 ? navigator.smartstore.upsertSoupEntries(!1, recordTypeSoup, recordTypeData, function () {
                    deferred.resolve(!0)
                }, function (error) {
                    deferred.reject(error)
                }) : deferred.resolve(!0)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }
    }])
}(angular), function () {
    "use strict";

    function RelatedListService($q, $injector) {
        function getAllRelatedListsByObjectType(objectType) {
            if (!objectType || angular.isUndefined(objectType)) throw new Error('Missing argument exception. "objectType" needs to be specified.');
            var deferred = $q.defer(), layoutableConfiguredObjectTypes = [],
                describeService = $injector.get("DescribeService"),
                configurationService = $injector.get("ConfigurationService");
            return configurationService.getConfiguredObjectTypes(!0).then(function (objectTypes) {
                return layoutableConfiguredObjectTypes = objectTypes, describeService.getDescribeLayout(objectType)
            }).then(function (describeLayout) {
                return _getLayoutableRelatedLists(describeLayout.layoutResult.relatedLists, layoutableConfiguredObjectTypes)
            }).then(function (filteredRelatedLists) {
                deferred.resolve(filteredRelatedLists)
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        }

        function _getLayoutableRelatedLists(relatedLists, layoutableObjectTypes) {
            for (var result = [], deferred = $q.defer(), i = 0; i < relatedLists.length; i++) layoutableObjectTypes.indexOf(relatedLists[i].sobject) != -1 && result.push(relatedLists[i]);
            return deferred.resolve(result), deferred.promise
        }

        function getPageableRelatedRecordsForRelatedList(relatedList, parentObjectSid, objectType, pageSize, currentPage) {
            if (!parentObjectSid || angular.isUndefined(parentObjectSid)) throw new Error('Missing argument exception. "parentObjectSid" needs to be specified.');
            if (!relatedList || angular.isUndefined(relatedList)) throw new Error('Missing argument exception. "relatedList" needs to be specified.');
            var deferred = $q.defer(), result = {
                    entries: void 0,
                    pageSize: pageSize || 10,
                    currentPage: currentPage || 1,
                    totalEntries: 0,
                    totalPages: 0,
                    rawCursor: void 0
                },
                smartSql = "select {" + relatedList.sobject + ":_soup} from {" + relatedList.sobject + "} where {" + relatedList.sobject + ":" + objectType + "Id_sid} = " + parentObjectSid,
                smartQuery = navigator.smartstore.buildSmartQuerySpec(smartSql);
            return _getCursorForSmartQuery(smartQuery).then(function (cursor) {
                return result.rawCursor = cursor, result.totalPages = cursor.totalPages, result.totalEntries = cursor.totalEntries, _getAllowedColumnsFromRelatedList(relatedList)
            }).then(function (allowedColumns) {
                return _getThinnedEntryObjectsFromCursorEntries(result.rawCursor.currentPageOrderedEntries, allowedColumns)
            }).then(function (thinnedEntries) {
                result.entries = thinnedEntries, deferred.resolve(result)
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        }

        function _getThinnedEntryObjectsFromCursorEntries(rawEntries, allowedColumns) {
            for (var deferred = $q.defer(), result = [], i = 0; i < rawEntries.length; i++) {
                for (var entry = rawEntries[i][0], thinnedEntry = {_soupEntryId: entry._soupEntryId}, j = 0; j < allowedColumns.length; j++) entry[allowedColumns[j].name] && !angular.isUndefined(entry[allowedColumns[j].name]) && (thinnedEntry[allowedColumns[j].name] = entry[allowedColumns[j].name]);
                thinnedEntry !== {} && result.push(thinnedEntry)
            }
            return deferred.resolve(result), deferred.promise
        }

        function _getCursorForSmartQuery(smartQuery) {
            if (!smartQuery || angular.isUndefined(smartQuery)) throw new Error('Missing argument exception. "smartQuery" needs to be specified.');
            var deferred = $q.defer();
            return navigator.smartstore.runSmartQuery(smartQuery, function (cursor) {
                return cursor.currentPageOrderedEntries && 0 == cursor.currentPageOrderedEntries.length ? void deferred.reject(new Error("No records found.")) : void deferred.resolve(cursor)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }

        function _isNotAllowedColumn(column, localAvailableField) {
            return (_isNotAllowedColumnName(column) || _isLookupColumn(column) || column.name !== localAvailableField.name) && "Name" !== localAvailableField.name && "Subject" !== localAvailableField.name
        }

        function _isAllowedLocalField(relatedList, localAvailableField) {
            for (var result = !1, i = 0; i < relatedList.columns.length; i++) result || _isNotAllowedColumn(relatedList.columns[i], localAvailableField) || (result = !0);
            return result
        }

        function _getAllowedColumnsFromRelatedList(relatedList) {
            if (!relatedList || angular.isUndefined(relatedList)) throw new Error('Missing argument exception. "relatedList" needs to be specified.');
            if (!relatedList.columns || angular.isUndefined(relatedList.columns)) throw new Error('Missing argument exception. "relatedList.columns" needs to be specified.');
            var deferred = $q.defer(), result = [], localDataService = $injector.get("LocalDataService");
            return localDataService.getFieldInformations(relatedList.sobject).then(function (localAvailableFields) {
                for (var i = 0; i < localAvailableFields.length; i++) _isAllowedLocalField(relatedList, localAvailableFields[i]) && result.push(localAvailableFields[i]);
                deferred.resolve(result)
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        }

        function _isNotAllowedColumnName(column) {
            var notAllowedColumnNamePatterns = ["toLabel", "ToReport"];
            return notAllowedColumnNamePatterns.indexOf(column.name) !== -1
        }

        function _isLookupColumn(column) {
            return null !== column.lookupId
        }

        return {
            getAllRelatedListsByObjectType: getAllRelatedListsByObjectType,
            getPageableRelatedRecordsForRelatedList: getPageableRelatedRecordsForRelatedList
        }
    }

    angular.module("oinio.core").service("RelatedListService", RelatedListService), RelatedListService.$inject = ["$q", "$injector"]
}(), function (angular) {
    "use strict";
    angular.module("oinio.core").service("RestService", ["$q", "$log", "ForceClientService", "LocalCacheService", "LocalDataService", "MetaService", "APP_SETTINGS", "$injector", function ($q, $log, ForceClientService, LocalCacheService, LocalDataService, MetaService, APP_SETTINGS, $injector) {
        var service = this, Exception = $injector.get("Exception"),
            EXCEPTION_SEVERITY = $injector.get("EXCEPTION_SEVERITY"),
            getCheckObjectTypesToSynchronizeUrl = ($injector.get("PROCESS_CODE"), $injector.get("STATUS_CODE"), function () {
                return APP_SETTINGS.LOCAL_CONFIGURATION === !0 ? "/MobileVizArt/checkObjectTypesToSynchronize" : "/MobileVizArt/MobileVizArt/checkObjectTypesToSynchronize"
            }), getGetServerTimestampUrl = function () {
                return APP_SETTINGS.LOCAL_CONFIGURATION === !0 ? "/MobileVizArt/utils" : "/MobileVizArt/MobileVizArt/utils"
            }, getGetFilterCriteriaUrl = function () {
                return "/MobileVizArt/MobileVizArt/getFilterCriteria"
            }, getGetObjectPermissionsUrl = function () {
                return APP_SETTINGS.LOCAL_CONFIGURATION === !0 ? "/MobileVizArt/getObjectPermissions" : "/MobileVizArt/MobileVizArt/getObjectPermissions"
            }, getSyncRecordsToSfdcUrl = function () {
                return APP_SETTINGS.LOCAL_CONFIGURATION === !0 ? "/MobileVizArt/syncRecordsToSfdc" : "/MobileVizArt/MobileVizArt/syncRecordsToSfdc"
            }, getSyncDownSharedRecordsUrl = function () {
                return APP_SETTINGS.LOCAL_CONFIGURATION === !0 ? "/MobileVizArt/syncDownSharedRecords" : "/MobileVizArt/MobileVizArt/syncDownSharedRecords"
            }, getCheckTotalRecordsUrl = function () {
                return APP_SETTINGS.LOCAL_CONFIGURATION === !0 ? "/MobileVizArt/checkTotalRecords" : "/MobileVizArt/MobileVizArt/checkTotalRecords"
            }, getCheckRecordsExistenceUrl = function () {
                return APP_SETTINGS.LOCAL_CONFIGURATION === !0 ? "/MobileVizArt/checkRecordsExistence" : "/MobileVizArt/MobileVizArt/checkRecordsExistence"
            }, getGetRecordIdsUrl = function () {
                return APP_SETTINGS.LOCAL_CONFIGURATION === !0 ? "/MobileVizArt/getRecordIds" : "/MobileVizArt/MobileVizArt/getRecordIds"
            }, getGetRecordsByIdsUrl = function () {
                return APP_SETTINGS.LOCAL_CONFIGURATION === !0 ? "/MobileVizArt/getRecordsByIdsEnhanced" : "/MobileVizArt/MobileVizArt/getRecordsByIdsEnhanced"
            }, getGetUserInfoUrl = function () {
                return APP_SETTINGS.LOCAL_CONFIGURATION === !0 ? "/MobileVizArt/getUserInfo" : "/MobileVizArt/MobileVizArt/getUserInfo"
            }, getCustomLabelsUrl = function () {
                return APP_SETTINGS.LOCAL_CONFIGURATION === !0 ? "/MobileVizArt/loadCustomLabels" : "/MobileVizArt/MobileVizArt/loadCustomLabels"
            };
        service.checkObjectTypesToSynchronize = function (payload) {
            var deferred = $q.defer();
            return ForceClientService.getForceClient().apexrest(getCheckObjectTypesToSynchronizeUrl(), "POST", JSON.stringify(payload), null, function (response) {
                $log.debug(">>>> RestService checkObjectTypesToSynchronize() success"), deferred.resolve(response)
            }, function (error) {
                var msg = error.responseJSON && error.responseJSON[0].message ? error.responseJSON[0].message : null;
                deferred.reject(new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, msg, error.stack, error))
            }), deferred.promise
        }, service.getServerTimestamp = function () {
            var deferred = $q.defer();
            return ForceClientService.getForceClient().apexrest(getGetServerTimestampUrl(), "GET", {}, null, function (response) {
                $log.debug("Get server time >>>>>>>>> " + JSON.stringify(response)), response && (response = response.replace("+0000", "Z")), deferred.resolve(response)
            }, function (error) {
                var msg = error.responseJSON && error.responseJSON[0].message ? error.responseJSON[0].message : null;
                deferred.reject(new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, msg, error.stack, error))
            }), deferred.promise
        }, service.getFilterCriteria = function () {
            var deferred = $q.defer();
            return APP_SETTINGS.LOCAL_CONFIGURATION === !0 ? LocalDataService.queryConfigurationAndObjects().then(function (configuration) {
                var result = {filterCriterias: []};
                configuration && configuration.objects && angular.forEach(configuration.objects, function (configObj) {
                    result.filterCriterias.push({
                        objName: configObj.Name,
                        filterCriteria: configObj.MobileVizArt__Filter_Criteria__c
                    })
                }), deferred.resolve(result)
            }, function (error) {
                error.method = "rest.service::getFilterCriteria->queryConfigurationAndObjects", $log.debug(error), deferred.reject(error)
            }) : ForceClientService.getForceClient().apexrest(getGetFilterCriteriaUrl(), "POST", "{}", null, function (response) {
                $log.debug(">>>> RestService getFilterCriteria() success"), deferred.resolve(response)
            }, function (error) {
                var msg = error.responseJSON && error.responseJSON[0].message ? error.responseJSON[0].message : null;
                deferred.reject(new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, msg, error.stack, error))
            }), deferred.promise
        }, service.getObjectPermissions = function (payload) {
            var deferred = $q.defer();
            return ForceClientService.getForceClient().apexrest(getGetObjectPermissionsUrl(), "POST", JSON.stringify(payload), null, function (response) {
                $log.debug(">>>> RestService getObjectPermissions() success"), deferred.resolve(response)
            }, function (error) {
                var msg = error.responseJSON && error.responseJSON[0].message ? error.responseJSON[0].message : null;
                deferred.reject(new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, msg, error.stack, error))
            }), deferred.promise
        }, service.syncRecordsToSfdc = function (payload) {
            var deferred = $q.defer();
            return ForceClientService.getForceClient().apexrest(getSyncRecordsToSfdcUrl(), "POST", JSON.stringify(payload), null, function (response) {
                $log.debug(">>>> RestService syncRecordsToSfdc() success"), deferred.resolve(response)
            }, function (error) {
                var msg = error.responseJSON && error.responseJSON[0].message ? error.responseJSON[0].message : null;
                deferred.reject(new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, msg, error.stack, error))
            }), deferred.promise
        }, service.syncDownSharedRecords = function (payload) {
            var deferred = $q.defer();
            return ForceClientService.getForceClient().apexrest(getSyncDownSharedRecordsUrl(), "POST", JSON.stringify(payload), null, function (response) {
                $log.debug(">>>> RestService syncDownSharedRecords() success"), deferred.resolve(response)
            }, function (error) {
                var msg = error.responseJSON && error.responseJSON[0].message ? error.responseJSON[0].message : null;
                deferred.reject(new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, msg, error.stack, error))
            }), deferred.promise
        }, service.checkTotalRecords = function (payload) {
            var deferred = $q.defer();
            return ForceClientService.getForceClient().apexrest(getCheckTotalRecordsUrl(), "POST", JSON.stringify(payload), null, function (response) {
                $log.debug(">>>> RestService checkTotalRecords() success"), deferred.resolve(response)
            }, function (error) {
                var msg = error.responseJSON && error.responseJSON[0].message ? error.responseJSON[0].message : null;
                deferred.reject(new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, msg, error.stack, error))
            }), deferred.promise
        }, service.checkRecordsExistence = function (payload) {
            var deferred = $q.defer();
            return ForceClientService.getForceClient().apexrest(getCheckRecordsExistenceUrl(), "POST", JSON.stringify(payload), null, function (response) {
                $log.debug(">>>> RestService checkRecordsExistence() success"), deferred.resolve(response)
            }, function (error) {
                var msg = error.responseJSON && error.responseJSON[0].message ? error.responseJSON[0].message : null;
                deferred.reject(new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, msg, error.stack, error))
            }), deferred.promise
        }, service.getRecordIds = function (payload) {
            var deferred = $q.defer();
            return ForceClientService.getForceClient().apexrest(getGetRecordIdsUrl(), "POST", JSON.stringify(payload), null, function (response) {
                $log.debug(">>>> RestService getRecordIds() success"), deferred.resolve(response)
            }, function (error) {
                var msg = error.responseJSON && error.responseJSON[0].message ? error.responseJSON[0].message : null;
                deferred.reject(new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, msg, error.stack, error))
            }), deferred.promise
        }, service.getRecordsByIds = function (payload) {
            var deferred = $q.defer();
            return ForceClientService.getForceClient().apexrest(getGetRecordsByIdsUrl(), "POST", JSON.stringify(payload), null, function (response) {
                $log.debug(">>>> RestService getRecordsByIds() success"), deferred.resolve(response)
            }, function (error) {
                var msg = error.responseJSON && error.responseJSON[0].message ? error.responseJSON[0].message : null;
                deferred.reject(new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, msg, error.stack, error))
            }), deferred.promise
        }, service.getUserInfo = function () {
            var deferred = $q.defer();
            return ForceClientService.getForceClient().apexrest(getGetUserInfoUrl(), "GET", null, null, function (response) {
                deferred.resolve(response)
            }, function (error) {
                var msg = error.responseJSON && error.responseJSON[0].message ? error.responseJSON[0].message : null;
                deferred.reject(new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, msg, error.stack, error))
            }), deferred.promise
        }, service.getCustomLabels = function (payload) {
            var deferred = $q.defer();
            return ForceClientService.getForceClient().apexrest(getCustomLabelsUrl(), "POST", JSON.stringify(payload), null, function (response) {
                $log.debug(">>>> RestService getCustomLabels() success"), deferred.resolve(response)
            }, function (error) {
                var msg = error.responseJSON && error.responseJSON[0].message ? error.responseJSON[0].message : null;
                deferred.reject(new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, msg, error.stack, error))
            }), deferred.promise
        }
    }])
}(angular), function (angular) {
    "use strict";
    angular.module("oinio.core").service("SalesforceDataService", ["$q", "$log", "ForceClientService", "UtilService", "MetaService", "LocalDataService", "RestService", "Exception", "EXCEPTION_SEVERITY", "LocalCacheService", function ($q, $log, ForceClientService, UtilService, MetaService, LocalDataService, RestService, Exception, EXCEPTION_SEVERITY, LocalCacheService) {
        var service = this;
        service.loadUserInfo = function () {
            var deferred = $q.defer(), handleError = function (error) {
                error && "function" == typeof error.handle ? (error.retry = service.loadUserInfo, error.retryDeferred = deferred, error.handle()) : new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, error.message, error.stack, error, service.loadUserInfo, null, null, null, deferred).handle(), deferred.reject(error)
            };
            return UtilService.isDeviceOnline().then(function (online) {
                online === !0 ? RestService.getUserInfo().then(function (userInfo) {
                    deferred.resolve(userInfo)
                }, function (error) {
                    error.method = "salesforce-data.service::loadUserInfo->forceClient1", $log.debug(error), MetaService.getMetaValueEnhance("userInfo").then(function (userInfo) {
                        userInfo ? deferred.resolve(userInfo) : handleError({message: "Failed to load user info from salesforce and local, please ensure that you are connected to the internet. If the problem persists, please contact your administrator."})
                    }, function (error) {
                        handleError(error)
                    })
                }) : MetaService.getMetaValueEnhance("userInfo").then(function (userInfo) {
                    userInfo ? deferred.resolve(userInfo) : handleError({message: "Failed to load user info from local, please connect to the internet and try again. If the problem persists, please contact your administrator."})
                }, function (error) {
                    handleError(error)
                })
            }, function (error) {
                handleError(error)
            }), deferred.promise
        }, service.query = function (soql) {
            var deferred = $q.defer(), forceClient = ForceClientService.getForceClient();
            return forceClient.query(soql, function (result) {
                var data = {
                    done: result.done,
                    nextRecordsUrl: result.nextRecordsUrl,
                    totalSize: result.totalSize,
                    records: result.records
                };
                deferred.resolve(data)
            }, function (error) {
                $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject("Failed to Load Data.")
            }), deferred.promise
        }, service.queryMore = function (nextRecordsUrl) {
            var deferred = $q.defer(), forceClient = ForceClientService.getForceClient();
            return forceClient.queryMore(nextRecordsUrl, function (result) {
                var data = {
                    done: result.done,
                    nextRecordsUrl: result.nextRecordsUrl,
                    totalSize: result.totalSize,
                    records: result.records
                };
                deferred.resolve(data)
            }, function (error) {
                $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject("Failed to Load Data.")
            }), deferred.promise
        }, service.queryAll = function (soql, withDeleted) {
            var deferred = $q.defer(), forceClient = ForceClientService.getForceClient(), data = [],
                _queryData = function (param) {
                    return deferred = param.deferred || $q.defer(), param.nextRecordsUrl ? forceClient.queryMore(param.nextRecordsUrl, function (result) {
                        data = data.concat(result.records), result.done === !1 ? _queryData({
                            nextRecordsUrl: result.nextRecordsUrl,
                            soql: param.soql,
                            deferred: deferred
                        }) : deferred.resolve(data)
                    }, function (error) {
                        $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject("Failed to Load Data.")
                    }) : withDeleted ? forceClient.queryAll(param.soql, function (result) {
                        data = data.concat(result.records), result.done === !1 ? _queryData({
                            nextRecordsUrl: result.nextRecordsUrl,
                            soql: param.soql,
                            deferred: deferred
                        }) : deferred.resolve(data)
                    }, function (error) {
                        $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject("Failed to Load Data.")
                    }) : forceClient.query(param.soql, function (result) {
                        data = data.concat(result.records), result.done === !1 ? _queryData({
                            nextRecordsUrl: result.nextRecordsUrl,
                            soql: param.soql,
                            deferred: deferred
                        }) : deferred.resolve(data)
                    }, function (error) {
                        $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject("Failed to Load Data.")
                    }), deferred.promise
                };
            return _queryData({soql: soql}).then(function (data) {
                deferred.resolve(data)
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }, service.createNote = function (parentId, title, body, additionalFields) {
            var deferred = $q.defer(), noteFields = {ParentId: parentId, Title: title, Body: body},
                forceClient = ForceClientService.getForceClient();
            return forceClient.create("Note", noteFields, function (success) {
                deferred.resolve(success)
            }, function (error) {
                $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject(error)
            }), deferred.promise
        }, service.getNotesForParent = function (parentId, condition, order) {
            var deferred = $q.defer(), objectType = "Note";
            return LocalDataService.soqlFieldsForObjectType(objectType).then(function (fields) {
                var soql = "SELECT " + fields.toString() + " FROM " + objectType + " WHERE ParentId='" + parentId + "'";
                void 0 !== condition && "" !== condition && (soql = soql + " WHERE " + condition), void 0 !== order && "" !== order && (soql = soql + " ORDER BY " + order);
                var forceClient = ForceClientService.getForceClient();
                forceClient.query(soql, function (result) {
                    var notes = [];
                    angular.forEach(result.records, function (entry) {
                        var note = {};
                        angular.forEach(fields, function (field) {
                            entry.hasOwnProperty(field) && (note[field] = entry[field])
                        }), notes.push(note)
                    }), deferred.resolve(notes)
                }, function (error) {
                    $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject("Failed to Load Data.")
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.createAttachment = function (parentId, name, description, body, contentType) {
            var deferred = $q.defer(), attachmentFields = {
                ParentId: parentId,
                Name: name,
                Description: description,
                Body: body,
                ContentType: contentType
            }, forceClient = ForceClientService.getForceClient();
            return forceClient.create("Attachment", attachmentFields, function (success) {
                deferred.resolve(success)
            }, function (error) {
                $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject(error)
            }), deferred.promise
        }, service.createContentVersion = function (contentDocumentId, versionData, pathOnClient, title, description, networkId) {
            var deferred = $q.defer(), isAndroid = UtilService.isAndroidOS();
            isAndroid && "null" === contentDocumentId && (contentDocumentId = null);
            var contentVersionFields = {
                ContentDocumentId: contentDocumentId,
                VersionData: versionData,
                PathOnClient: pathOnClient,
                Title: title,
                Description: description
            };
            networkId && (contentVersionFields.NetworkId = networkId);
            var forceClient = ForceClientService.getForceClient();
            return forceClient.create("ContentVersion", contentVersionFields, function (success) {
                deferred.resolve(success)
            }, function (error) {
                $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject(error)
            }), deferred.promise
        }, service.fetchFileIdByContentVersionId = function (contentVersionId) {
            var deferred = $q.defer();
            if (contentVersionId) {
                var soql = "select ContentDocumentId from ContentVersion where Id = '" + contentVersionId + "' limit 1";
                service.query(soql).then(function (result) {
                    result.records && 1 === result.records.length ? deferred.resolve(result.records[0].ContentDocumentId) : deferred.reject("Fetch file id error: not found ContentVersion whose id is " + contentVersionId)
                }, function (error) {
                    deferred.reject("Fetch file id error: " + JSON.stringify(error))
                })
            } else deferred.reject("Fetch file id error: contentVersionId is null.");
            return deferred.promise
        }, service.addFileShareMember = function (fileId, entityId, shareType) {
            var deferred = $q.defer(), forceClient = ForceClientService.getForceClient();
            return forceClient.addFileShare(fileId, entityId, shareType, function (success) {
                deferred.resolve(success)
            }, function (error) {
                $log.warn(new Exception(null, error.status, error.message, error.stack, error));
                var msg = error.responseJSON && error.responseJSON[0].message ? error.responseJSON[0].message : null;
                deferred.reject(new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, msg, error.stack, error))
            }), deferred.promise
        }, service.addFileShareMemberByGroupName = function (fileId, shareType, collaborationGroupName) {
            var deferred = $q.defer(),
                soql = "select Id from CollaborationGroup where Name = '" + collaborationGroupName + "' limit 1";
            return service.query(soql).then(function (result) {
                return result.records && 1 === result.records.length ? result.records[0].Id : null
            }).then(function (groupId) {
                return groupId ? service.addFileShareMember(fileId, groupId, shareType) : -1
            }).then(function (res) {
                res === -1 ? deferred.reject({message: "No collaboration group: " + collaborationGroupName + ", please contact to system admin to be a member of it and then retry."}) : deferred.resolve()
            })["catch"](function (error) {
                error.message && (error.message = "No access to collaboration group: " + collaborationGroupName + ", please contact to system admin to be a member of it and then retry."), deferred.reject(error)
            }), deferred.promise
        }, service.addFileShareMemberByRouting = function (fileId, shareType) {
            var deferred = $q.defer();
            return _getMatchRouting().then(function (targetCriteria) {
                return _queryMultiTargetObjects(targetCriteria)
            }).then(function (targetIds) {
                for (var promises = [], i = 0; i < targetIds.length; i++) promises.push(service.addFileShareMember(fileId, targetIds[i], shareType));
                return $q.all(promises)
            }).then(function (res) {
                deferred.resolve()
            })["catch"](function (error) {
                "string" == typeof error && (error = {message: "Add file share member by routing error: " + error}), deferred.reject(new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, error.message, error.stack, error))
            }), deferred.promise
        };
        var _getMatchRouting = function () {
            var deferred = $q.defer();
            return LocalDataService.queryConfigurationAndObjects().then(function (configuraion) {
                var targetCriteria = {}, routingSetting = configuraion.Log_File_Upload_Routing__c;
                if (routingSetting) {
                    var userInfo = LocalCacheService.get("userInfo"), currentVal = "";
                    switch (routingSetting.criteriaObject) {
                        case"User":
                            currentVal = userInfo.currentUser[routingSetting.criteriaObjectField];
                            break;
                        case"Profile":
                            currentVal = userInfo.profile.Name;
                            break;
                        case"Permission":
                            currentVal = _.pluck(userInfo.assignedPermissionSets, "Name")
                    }
                    var pushTargetRecords = function (setting, me) {
                        if (setting.hasOwnProperty(me) && setting[me]) for (var i = 0; i < setting[me].length; i++) {
                            var perRecords = setting[me][i], targetObj = perRecords.logObject;
                            targetCriteria.hasOwnProperty(targetObj) ? targetCriteria[targetObj] += " or " : targetCriteria[targetObj] = "", targetCriteria[targetObj] += perRecords.logObjectField + " = '" + perRecords.logObjectFieldValue + "'"
                        }
                    };
                    if (currentVal) for (var i = 0; i < routingSetting.routing.length; i++) {
                        var item = routingSetting.routing[i];
                        if ("string" == typeof currentVal) pushTargetRecords(item, currentVal); else for (var j = 0; j < currentVal.length; j++) pushTargetRecords(item, currentVal[j])
                    }
                    0 === Object.keys(targetCriteria).length && routingSetting.defaultRouting && pushTargetRecords({"default": [routingSetting.defaultRouting]}, "default")
                }
                deferred.resolve(targetCriteria)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, _queryMultiTargetObjects = function (targetCriteria) {
            var deferred = $q.defer(), promises = [];
            for (var key in targetCriteria) {
                var soql = "select Id from " + key + " where " + targetCriteria[key];
                promises.push(service.query(soql))
            }
            return promises.length > 0 ? $q.all(promises).then(function (resultWrap) {
                for (var ids = [], i = 0; i < resultWrap.length; i++) ids = ids.concat(_.pluck(resultWrap[i].records, "Id"));
                ids.length > 0 ? deferred.resolve(ids) : deferred.reject({message: "You can't access any records for criteria:" + JSON.stringify(targetCriteria) + "."})
            }, function (error) {
                deferred.reject(error)
            }) : deferred.reject({message: "Not found routing setting matched for you."}), deferred.promise
        };
        service.createDocument = function (documentName, documentBody, description, keywords, folderId, type) {
            var deferred = $q.defer(), documentFields = {
                Name: documentName,
                Body: documentBody,
                Description: description,
                Keywords: keywords,
                FolderId: folderId,
                Type: type
            }, forceClient = ForceClientService.getForceClient();
            return forceClient.create("Document", documentFields, function (success) {
                deferred.resolve(success);
            }, function (error) {
                $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject(error)
            }), deferred.promise
        }, service.createDocumentByFolderName = function (documentName, documentBody, description, keywords, folderDevelopName, type) {
            var deferred = $q.defer(), soql = "select Id from Folder where DeveloperName = '" + folderDevelopName + "'";
            return service.query(soql).then(function (result) {
                return result.records && 1 === result.records.length ? result.records[0].Id : null
            }).then(function (folderId) {
                return folderId ? service.createDocument(documentName, documentBody, description, keywords, folderId, type) : -1
            }).then(function (res) {
                res === -1 ? deferred.reject("Not found the folder whose developName is " + folderDevelopName + ".") : deferred.resolve()
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.getAttachmentsForParent = function (parentId, condition, order) {
            var deferred = $q.defer(), objectType = "Attachment";
            return LocalDataService.soqlFieldsForObjectType(objectType).then(function (fields) {
                var soql = "SELECT " + fields.toString() + " FROM " + objectType + " WHERE ParentId='" + parentId + "'";
                "" !== condition && (soql = soql + " AND " + condition), "" !== order && (soql = soql + " ORDER BY " + order);
                var forceClient = ForceClientService.getForceClient();
                forceClient.query(soql, function (result) {
                    var attachments = [];
                    angular.forEach(result.records, function (entry) {
                        var attachment = {};
                        angular.forEach(fields, function (field) {
                            entry.hasOwnProperty(field) && (attachment[field] = entry[field])
                        }), attachments.push(attachment)
                    }), deferred.resolve(attachments)
                }, function (error) {
                    $log.warn(new Exception(null, error.status, error.message, error.stack, error)), deferred.reject("Failed to Load Data.")
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }
    }])
}(angular, _), function (angular) {
    "use strict";
    angular.module("oinio.core").service("SalesforceLoginService", ["ForceClientService", "SalesforceDataService", "$http", "$q", "LocalCacheService", "MetaService", "LocalDataService", "FileService", "UtilService", "APP_SETTINGS", "ConnectionMonitor", "$log", "Exception", "EXCEPTION_SEVERITY", function (ForceClientService, SalesforceDataService, $http, $q, LocalCacheService, MetaService, LocalDataService, FileService, UtilService, APP_SETTINGS, ConnectionMonitor, $log, Exception, EXCEPTION_SEVERITY) {
        function _checkMobileConfigChanged(userCurrentProfileId) {
            var deferred = $q.defer(), handleError = function (error) {
                error && "function" == typeof error.handle ? (error.retry = _checkMobileConfigChanged, error.retryParam = userCurrentProfileId, error.retryDeferred = deferred, error.handle()) : new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, error.message, error.stack, error, _checkMobileConfigChanged, null, null, userCurrentProfileId, deferred).handle(), deferred.reject(error)
            }, result = {doLogout: !1, isMetaSoupExist: !1};
            return _isSoupExist("_meta").then(function (exist) {
                if (exist === !0) {
                    if (result.isMetaSoupExist = !0, APP_SETTINGS.LOCAL_CONFIGURATION === !0) return void deferred.resolve(result);
                    MetaService.getMetaValue("userInfo").then(function (userInfo) {
                        if (userInfo) {
                            var localProfileId = userInfo.currentUser.ProfileId;
                            LocalDataService.queryConfigurationAndObjects(localProfileId).then(function (configuraion) {
                                if (configuraion && configuraion.Id) {
                                    var localMobileConfigId = configuraion.Id;
                                    SalesforceDataService.query("select Id, MobileVizArt__Profiles__c from MobileVizArt__Mobile_Configuration__c").then(function (data) {
                                        var onlineCurrentUserMobileConfigIds = [];
                                        angular.forEach(data.records || [], function (item) {
                                            item.MobileVizArt__Profiles__c && item.MobileVizArt__Profiles__c.indexOf(userCurrentProfileId) > -1 && onlineCurrentUserMobileConfigIds.indexOf(item.Id) === -1 && onlineCurrentUserMobileConfigIds.push(item.Id)
                                        }), onlineCurrentUserMobileConfigIds.indexOf(localMobileConfigId) === -1 ? (result.doLogout = !0, deferred.resolve(result)) : (result.doLogout = !1, deferred.resolve(result))
                                    }, function (err) {
                                        handleError(err)
                                    })
                                } else result.doLogout = !0, deferred.resolve(result)
                            }, function (err) {
                                handleError(err)
                            })
                        } else result.doLogout = !1, deferred.resolve(result)
                    }, function (err) {
                        handleError(err)
                    })
                } else deferred.resolve(result)
            }, function (err) {
                handleError(err)
            }), deferred.promise
        }

        function _isSoupExist(soupName) {
            return $q(function (resolve, reject) {
                navigator.smartstore.soupExists(soupName, function (exist) {
                    resolve(exist)
                }, function (err) {
                    reject(err)
                })
            })
        }

        var service = this;
        service.logout = function () {
            var doLogout = function () {
                cordova.require("com.salesforce.plugin.sfaccountmanager").logout()
            };
            FileService.clearUserFolder().then(function () {
                if (UtilService.isAndroidOS()) {
                    var smartsql = "select {_user:_soup} from {_user}",
                        smartquery = navigator.smartstore.buildSmartQuerySpec(smartsql, 100);
                    navigator.smartstore.runSmartQuery(!0, smartquery, function (cursor) {
                        if (cursor && cursor.totalEntries <= 1) navigator.smartstore.removeSoup(!0, "_user", function (cursor) {
                            doLogout()
                        }, function (err) {
                            throw err
                        }); else if (cursor && cursor.totalEntries > 1) {
                            var currentUser = LocalCacheService.get("currentUser"),
                                exactQuery = navigator.smartstore.buildExactQuerySpec("username", currentUser.Username);
                            navigator.smartstore.querySoup(!0, "_user", exactQuery, function (cursor) {
                                var currentUserEntryId = cursor && cursor.currentPageOrderedEntries.length > 0 ? cursor.currentPageOrderedEntries[0]._soupEntryId : null;
                                currentUserEntryId ? navigator.smartstore.removeFromSoup(!0, "_user", [currentUserEntryId], function (succeed) {
                                    doLogout()
                                }, function (err) {
                                    throw err
                                }) : doLogout()
                            }, function (err) {
                                throw err
                            })
                        }
                    }, function (err) {
                        throw err
                    })
                } else doLogout()
            }, function (error) {
                throw error
            })
        }, service.oauthLogin = function (callback, failCallBack) {
            var oauthPlugin = cordova.require("com.salesforce.plugin.oauth"),
                processBusiness = function (credentials, clientId, callback) {
                    var forceClient = new forcetk.Client(clientId, credentials.loginUrl, null);
                    forceClient.setSessionToken(credentials.accessToken, "v36.0", credentials.instanceUrl), forceClient.setRefreshToken(credentials.refreshToken), forceClient.setUserAgentString(credentials.userAgent), ForceClientService.setForceClient(forceClient), SalesforceDataService.loadUserInfo().then(function (userInfoObject) {
                        if (LocalCacheService.set("userInfo", userInfoObject), LocalCacheService.set("currentUser", userInfoObject.currentUser), ConnectionMonitor.isOnline()) {
                            var userCurrentProfileId = userInfoObject.currentUser.ProfileId;
                            _checkMobileConfigChanged(userCurrentProfileId).then(function (checkResult) {
                                var doLogout = checkResult.doLogout || !1,
                                    isMetaSoupExist = checkResult.isMetaSoupExist || !1;
                                doLogout ? ($log.debug("Mobile configuration of the current login user has been changed, logout."), service.logout()) : isMetaSoupExist ? MetaService.getMetaValue("userInfo").then(function (localUserInfo) {
                                    MetaService.setMetaValue("userInfo", userInfoObject), localUserInfo && userInfoObject && localUserInfo.currentUser.LanguageLocaleKey !== userInfoObject.currentUser.LanguageLocaleKey && (userInfoObject.currentUser.isLanguageChanged = !0), callback && callback()
                                }, function (err) {
                                    $log.error("err: " + JSON.stringify(err))
                                }) : callback && callback()
                            }, function (err) {
                                $log.error("err: " + JSON.stringify(err))
                            })
                        } else callback && callback()
                    }, function (err) {
                        $log.error("err: " + JSON.stringify(err))
                    })
                };
            oauthPlugin.getAuthCredentials(function (credentials) {
                var clientId = credentials.clientId;
                if (clientId) processBusiness(credentials, clientId, callback); else {
                    var sdkinfoPlugin = cordova.require("com.salesforce.plugin.sdkinfo");
                    sdkinfoPlugin.getInfo(function (sdkinfo) {
                        sdkinfo && sdkinfo.bootConfig && (clientId = sdkinfo.bootConfig.remoteAccessConsumerKey), processBusiness(credentials, clientId, callback)
                    }, failCallBack)
                }
            }, failCallBack)
        }, service.getCurrentUserFromPlugin = function (success, fail) {
            cordova.require("com.salesforce.plugin.sfaccountmanager").getCurrentUser(success, fail)
        }, service.getUsers = function (success, fail) {
            cordova.require("com.salesforce.plugin.sfaccountmanager").getUsers(success, fail)
        }, service.switchToUser = function () {
            cordova.require("com.salesforce.plugin.sfaccountmanager").switchToUser(null)
        }, service.logoutAndDrop = function () {
            navigator.notification.confirm("Do you really want to logout? All local data will be lost.", function (buttonIndex) {
                switch (buttonIndex) {
                    case 1:
                        service.logout()
                }
            }, "Logout", ["Yes", "No"])
        }, service.webLogin = function () {
            var deferred = $q.defer(), forceClient = ForceClientService.getForceClient(),
                url = forceClient.instanceUrl + "/secur/frontdoor.jsp?sid=" + forceClient.sessionId;
            return $http.get(url).then(function () {
                deferred.resolve()
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }
    }])
}(angular), function (angular) {
    "use strict";
    angular.module("oinio.core").constant("SMARTSTORE_SOUP_STATUS", {
        SOUP_CREATED: "SOUP_CREATED",
        SOUP_EXIST: "SOUP_EXIST"
    }).constant("SMARTSTORE_COMMON_SETTING", {
        SOUP_NAME_QUEUE: "_queue",
        PAGE_SIZE_FOR_ALL: 1e8,
        QUEUE_MESSAGE_ACTION_INSERT: "INSERT",
        QUEUE_MESSAGE_ACTION_UPDATE: "UPDATE",
        QUEUE_MESSAGE_ACTION_DELETE: "DELETE",
        QUEUE_MESSAGE_ERROR_STATE: "error",
        REFERENCED_FIELD_EXTENSION_SUFFIX: "_sid",
        REFERENCED_FIELD_TYPE_SUFFIX: "_type"
    }).service("SmartStoreService", ["$injector", "$q", "SMARTSTORE_SOUP_STATUS", "ConfigurationService", "APP_SETTINGS", "MetaService", "LocalSyncService", "LocalCacheService", "UtilService", function ($injector, $q, SMARTSTORE_SOUP_STATUS, ConfigurationService, APP_SETTINGS, MetaService, LocalSyncService, LocalCacheService, UtilService) {
        function setupGlobalSoups() {
            var deferred = $q.defer(), promises = [];
            return ConfigurationService.globalSoupSettings().then(function (globalSoupSettings) {
                angular.forEach(globalSoupSettings, function (soup) {
                    promises.push(registerSoup(!0, soup.name, soup.indexSpec, soup.externalStorage))
                }), $q.all(promises).then(function (result) {
                    deferred.resolve(result)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }

        function setupFrameworkSoups() {
            var deferred = $q.defer(), promises = [];
            return ConfigurationService.frameworkSoupSettings().then(function (frameworkSoupSettings) {
                angular.forEach(frameworkSoupSettings, function (soup) {
                    promises.push(registerSoup(!1, soup.name, soup.indexSpec, soup.externalStorage))
                }), $q.all(promises).then(function (result) {
                    deferred.resolve(result)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }

        function setupSObjectSoups(soupSettings) {
            var deferred = $q.defer(), promises = [];
            return angular.forEach(soupSettings, function (soup) {
                promises.push(registerSoup(!1, soup.name, soup.indexSpec, soup.externalStorage)), "Attachment" === soup.name && promises.push(registerSoup(!1, "AttachmentBody", [{
                    path: "AttachmentSid",
                    type: "string"
                }]))
            }), $q.all(promises).then(function (result) {
                deferred.resolve(result)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }

        function getSoupNameKey(isGlobal, soupName) {
            return (isGlobal ? "g|" : "") + soupName
        }

        function pushSoupNameCache(isGlobal, soupName) {
            var soupNameKey = getSoupNameKey(isGlobal, soupName);
            allSoupName.indexOf(soupNameKey) === -1 && allSoupName.push(soupNameKey)
        }

        var service = this, Exception = $injector.get("Exception"),
            EXCEPTION_SEVERITY = $injector.get("EXCEPTION_SEVERITY");
        $injector.get("PROCESS_CODE"), $injector.get("STATUS_CODE");
        service.setupSoups = function () {
            var deferred = $q.defer(), handleError = function (error) {
                error && "function" == typeof error.handle ? (error.retry = _retrySetupSoups, error.retryDeferred = deferred, error.handle()) : new Exception(EXCEPTION_SEVERITY.RECOVERABLE, error.status, error.message, error.stack, error, _retrySetupSoups, null, null, null, deferred).handle(), deferred.reject(error)
            };
            return setupGlobalSoups().then(function () {
                return setupFrameworkSoups()
            }).then(function () {
                var userInfo = LocalCacheService.get("userInfo");
                return MetaService.setMetaValue("userInfo", userInfo), LocalSyncService.syncMobileConfiguration()
            }).then(function (result) {
                if (APP_SETTINGS.ENABLE_ONLINE_TRANSLATION) return $injector.get("TranslationService").loadCustomLabels()
            }).then(function (result) {
                return setupBusinessSoups()
            }).then(function () {
                MetaService.setMetaValue("allSoupName", allSoupName), deferred.resolve(!0)
            })["catch"](function (error) {
                handleError(error)
            }), deferred.promise
        };
        var _retrySetupSoups = function () {
            var deferred = $q.defer();
            return service.dropSoupByConfig(!1, !1, !0).then(function () {
                return service.setupSoups()
            }).then(function (success) {
                deferred.resolve(success)
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, setupBusinessSoups = function () {
            var deferred = $q.defer();
            return ConfigurationService.objectTypeSoupSettings().then(function (soupSettings) {
                soupSettings.length > 0 ? setupSObjectSoups(soupSettings).then(function () {
                    MetaService.setSoupInitialized();
                    var objectTypeNames = [];
                    angular.forEach(soupSettings, function (soup) {
                        objectTypeNames.push(soup.objectTypeName)
                    }), MetaService.initializeMetaDataForObjectTypes(objectTypeNames).then(function () {
                        deferred.resolve(!0)
                    }, function (error) {
                        deferred.reject(error)
                    })
                }, function (error) {
                    deferred.reject(error)
                }) : deferred.resolve(!0)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, registerSoup = function (isGlobal, soupName, indexSpec, isExternalStorage) {
            var deferred = $q.defer();
            return navigator.smartstore.soupExists(isGlobal, soupName, function (exists) {
                exists ? (pushSoupNameCache(isGlobal, soupName), deferred.resolve(SMARTSTORE_SOUP_STATUS.SOUP_EXIST)) : isExternalStorage && "function" == typeof navigator.smartstore.registerSoupWithSpec && UtilService.isAndroidOS() ? navigator.smartstore.registerSoupWithSpec(isGlobal, {
                    name: soupName,
                    features: ["externalStorage"]
                }, indexSpec, function (param) {
                    pushSoupNameCache(isGlobal, soupName), deferred.resolve(SMARTSTORE_SOUP_STATUS.SOUP_CREATED)
                }, function (error) {
                    deferred.reject(error)
                }) : navigator.smartstore.registerSoup(isGlobal, soupName, indexSpec, function (param) {
                    pushSoupNameCache(isGlobal, soupName), deferred.resolve(SMARTSTORE_SOUP_STATUS.SOUP_CREATED)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        service.dropSoupByConfig = function (skipObjectSoups, skipFrameworkSoups, skipGlobalSoups) {
            var deferred = $q.defer();
            return service.dropBusinessSoups(skipObjectSoups).then(function () {
                return service.dropFrameworkSoups(skipFrameworkSoups)
            }).then(function () {
                return deferred.resolve()
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.dropFrameworkSoups = function (skipFrameworkSoups) {
            var deferred = $q.defer();
            if (skipFrameworkSoups) return void deferred.resolve();
            var removePromises = [];
            return ConfigurationService.frameworkSoupSettings().then(function (soupSettings) {
                for (var i = 0; i < soupSettings.length; i++) {
                    var soup = soupSettings[i];
                    removePromises.push(removeSoup(!1, soup.name))
                }
                $q.all(removePromises).then(function () {
                    deferred.resolve()
                })["catch"](function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.dropBusinessSoups = function (skipObjectSoups) {
            var deferred = $q.defer();
            if (skipObjectSoups) return void deferred.resolve();
            var removePromises = [];
            return navigator.smartstore.soupExists(!1, "_configuration", function (exists) {
                exists ? $injector.get("LocalDataService").getConfiguredObjects().then(function (objects) {
                    for (var i = 0; i < objects.length; i++) {
                        var objectName = objects[i].Name;
                        removePromises.push(removeSoup(!1, objectName))
                    }
                    removePromises.push(removeSoup(!1, "AttachmentBody")), $q.all(removePromises).then(function (res) {
                        deferred.resolve()
                    })["catch"](function (error) {
                        deferred.reject(error)
                    })
                }, function (error) {
                    deferred.reject(error)
                }) : deferred.resolve()
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        var removeSoup = function (isGlobal, soupName) {
            var deferred = $q.defer();
            return navigator.smartstore.removeSoup(isGlobal, soupName, function (result) {
                _.pull(allSoupName, getSoupNameKey(isGlobal, soupName)), deferred.resolve(result)
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        service.resetSoupSpecByConfig = function (skipObjectSoups, skipFrameworkSoups, skipGlobalSoups) {
            var deferred = $q.defer();
            if (UtilService.isAndroidOS()) {
                var alterSoupPromises = [], findConfigPromises = [], addAlterSoup = function (isGlobal, soupSettings) {
                    angular.forEach(soupSettings, function (soup) {
                        alterSoupPromises.push(resetSoupExternalStorage(isGlobal, soup.name, soup.indexSpec, soup.externalStorage))
                    })
                };
                checkAppVersionChanged().then(function (isChanged) {
                    if (!skipGlobalSoups && isChanged) {
                        var promise = ConfigurationService.globalSoupSettings().then(function (globalSoupSettings) {
                            addAlterSoup(!0, globalSoupSettings)
                        });
                        findConfigPromises.push(promise)
                    }
                    if (!skipFrameworkSoups && isChanged) {
                        var promise2 = ConfigurationService.frameworkSoupSettings().then(function (frameworkSoupSettings) {
                            addAlterSoup(!1, frameworkSoupSettings)
                        });
                        findConfigPromises.push(promise2)
                    }
                    if (!skipObjectSoups) {
                        var promise3 = ConfigurationService.objectTypeSoupSettings().then(function (objectSoupSettings) {
                            addAlterSoup(!1, objectSoupSettings)
                        }, function (error) {
                        });
                        findConfigPromises.push(promise3)
                    }
                    return $q.all(findConfigPromises)
                }).then(function () {
                    return $q.all(alterSoupPromises)
                }).then(function () {
                    deferred.resolve()
                })["catch"](function (error) {
                    deferred.reject(error)
                })
            } else deferred.resolve();
            return deferred.promise
        };
        var resetSoupExternalStorage = function (isGlobal, soupName, indexSpec, isExternalStorage) {
            var deferred = $q.defer();
            return "function" == typeof navigator.smartstore.getSoupSpec && UtilService.isAndroidOS() ? navigator.smartstore.getSoupSpec(isGlobal, soupName, function (result) {
                var noChange = !0;
                isExternalStorage && result.features.indexOf("externalStorage") === -1 && (result.features.push("externalStorage"), noChange = !1), isExternalStorage || result.features.indexOf("externalStorage") === -1 || (result.features.splice(result.features.indexOf("externalStorage"), 1), noChange = !1), noChange || "function" != typeof navigator.smartstore.alterSoupWithSpec ? deferred.resolve(!0) : navigator.smartstore.alterSoupWithSpec(isGlobal, soupName, {
                    name: soupName,
                    features: result.features
                }, indexSpec, !1, function (result) {
                    deferred.resolve(result)
                }, function (error) {
                    deferred.reject(error)
                })
            }, function (error) {
                deferred.reject(error)
            }) : deferred.resolve(!0), deferred.promise
        }, checkAppVersionChanged = function () {
            var deferred = $q.defer(), $cordovaAppVersion = $injector.get("$cordovaAppVersion"), oldAppVersion = "";
            return MetaService.getMetaValueEnhance("appVersion").then(function (appVer) {
                return oldAppVersion = appVer, $cordovaAppVersion.getVersionNumber()
            }).then(function (appVersion) {
                oldAppVersion !== appVersion ? deferred.resolve(!0) : deferred.resolve(!1)
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, allSoupName = [];
        service.checkSoupExist = function (soupName, isGlobal) {
            var deferred = $q.defer();
            return allSoupName && allSoupName.length > 0 ? deferred.resolve(allSoupName.indexOf(getSoupNameKey(isGlobal, soupName)) !== -1) : MetaService.getMetaValue("allSoupName").then(function (allSoupNameFromDB) {
                return allSoupName = allSoupNameFromDB, allSoupName && allSoupName.length > 0 ? allSoupName : resetAllSoupName()
            }).then(function (allSoupName) {
                deferred.resolve(allSoupName.indexOf(getSoupNameKey(isGlobal, soupName)) !== -1)
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        var resetAllSoupName = function () {
            var deferred = $q.defer(), soupNames = [];
            return getAllSoupName(!1).then(function (localSoupNames) {
                return soupNames = localSoupNames, getAllSoupName(!0)
            }).then(function (globalSoupNames) {
                for (var i = 0; i < globalSoupNames.length; i++) globalSoupNames[i] = "g|" + globalSoupNames[i];
                allSoupName = soupNames.concat(globalSoupNames), MetaService.setMetaValue("allSoupName", allSoupName), deferred.resolve(allSoupName)
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, getAllSoupName = function (isGlobal) {
            var deferred = $q.defer(),
                querySpec = navigator.smartstore.buildSmartQuerySpec("select soupname from soup_attrs", 1e3);
            return navigator.smartstore.runSmartQuery(isGlobal, querySpec, function (cursor) {
                deferred.resolve(_.pluck(cursor.currentPageOrderedEntries, "0"))
            }, function (error) {
                deferred.reject(error)
            }), deferred.promise
        }
    }])
}(angular, _), function (angular) {
    "use strict";
    angular.module("oinio.core").service("TranslationService", ["$q", "$log", "$http", "$translate", "LocalCacheService", "RestService", "FileService", "APP_SETTINGS", function ($q, $log, $http, $translate, LocalCacheService, RestService, FileService, APP_SETTINGS) {
        function getCustomLabels(customLabelNames) {
            var deferred = $q.defer();
            return customLabelNames && customLabelNames.length > 0 ? RestService.getCustomLabels({customLabelNames: customLabelNames.join(",")}).then(function (result) {
                var customLabelsMap = {}, startFlag = "==customLabelRender-start==",
                    endFlag = "==customLabelRender-end==", splitFlag = "@#@";
                for (var batchLabelNames in result) if (result.hasOwnProperty(batchLabelNames)) {
                    var htmlContent = result[batchLabelNames];
                    if (htmlContent.indexOf(startFlag) === -1 || htmlContent.indexOf(endFlag) === -1) {
                        var logMsg = "Can't parse the custom labels from the visualforce page content which is not exist the start flag or the end flag. The html content is \n" + htmlContent;
                        return $log.warn(logMsg), void deferred.resolve(-1)
                    }
                    htmlContent = htmlContent.substring(htmlContent.indexOf(startFlag) + startFlag.length, htmlContent.indexOf(endFlag)), htmlContent.endsWith(splitFlag) && (htmlContent = htmlContent.substring(0, htmlContent.lastIndexOf(splitFlag))), htmlContent = htmlDecode(htmlContent);
                    var labels = htmlContent.split(splitFlag), labelNames = batchLabelNames.split(",");
                    if (labels.length !== labelNames.length) return $log.debug('Parse failed: it is maybe existing a conflict with the split flag "' + splitFlag + '".'), void deferred.resolve(-1);
                    for (var i = 0; i < labelNames.length; i++) customLabelsMap[labelNames[i]] = labels[i]
                }
                deferred.resolve(customLabelsMap)
            }, function (error) {
                deferred.reject(error)
            }) : ($log.debug("No any config custom labels."), deferred.resolve(-1)), deferred.promise
        }

        function htmlDecode(text) {
            var temp = document.createElement("div");
            temp.innerHTML = text;
            var output = temp.innerText || temp.textContent;
            return temp = null, output
        }

        var service = this;
        service.loadCustomLabels = function () {
            var localCustomLabels, deferred = $q.defer();
            return $http.get(APP_SETTINGS.ONLINE_TRANSLATION_CONFIGURATION_FILE).then(function (fileContent) {
                localCustomLabels = fileContent.data;
                var customLabelNames = [];
                for (var labelName in localCustomLabels) localCustomLabels.hasOwnProperty(labelName) && customLabelNames.push(labelName);
                return getCustomLabels(customLabelNames)
            }).then(function (result) {
                return result === -1 ? FileService.rewriteI18NData("locale-", localCustomLabels) : FileService.rewriteI18NData("locale-", result)
            }).then(function () {
                var user = LocalCacheService.get("currentUser");
                $translate.use(user.LanguageLocaleKey), deferred.resolve(!0)
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        }
    }])
}(angular), function (angular) {
    "use strict";
    angular.module("oinio.core").service("UtilService", ["$q", "$http", "$log", "$injector", "ForceClientService", function ($q, $http, $log, $injector, ForceClientService) {
        var service = this;
        service.isDeviceOnline = function () {
            var deferred = $q.defer();
            return service.isAndroidOS() ? $http.get(ForceClientService.getForceClient().instanceUrl, {timeout: 1e4}).then(function (response) {
                deferred.resolve(!0)
            }, function (response) {
                deferred.resolve(!1)
            }) : deferred.resolve(cordova.require("com.salesforce.util.bootstrap").deviceIsOnline()), deferred.promise
        }, service.isAndroidOS = function () {
            return "Android" === device.platform
        };
        var userAgent = navigator.userAgent, isWebkit = userAgent.indexOf("AppleWebKit") > 0,
            isIPad = userAgent.indexOf("iPad") > 0,
            isIOS = userAgent.indexOf("iPhone") > 0 || userAgent.indexOf("iPod") > 0,
            isAndroid = userAgent.indexOf("Android") > 0,
            isNewBlackBerry = userAgent.indexOf("AppleWebKit") > 0 && userAgent.indexOf("BlackBerry") > 0,
            isWebOS = userAgent.indexOf("webOS") > 0, isWindowsMobile = userAgent.indexOf("IEMobile") > 0,
            isSmallScreen = screen.width < 767 || isAndroid && screen.width < 1e3,
            isUnknownMobile = isWebkit && isSmallScreen,
            isMobile = isIOS || isAndroid || isNewBlackBerry || isWebOS || isWindowsMobile || isUnknownMobile,
            isTablet = isIPad || isMobile && !isSmallScreen;
        service.isMobile = function () {
            return isMobile
        }, service.isTablet = function () {
            return isTablet
        }, service.isMobileDevice = function () {
            return !!window.cordova
        }, service.Result = function (success, message, data) {
            this.success = success, this.message = message, this.data = data
        }, service.convertStringToBoolean = function (bl) {
            return "true" === bl || bl === !0 || "false" !== bl && bl !== !1 && void 0
        }, service.getDependentValues = function (picklistValues, controllerPicklistValues, selectedParentValue) {
            var dependentValues = [], isDependentValue = function (index, validFor) {
                var base64 = new sforce.Base64Binary(""), decoded = base64.decode(validFor),
                    bits = decoded.charCodeAt(index >> 3);
                return 0 != (bits & 128 >> index % 8)
            };
            return selectedParentValue && angular.forEach(controllerPicklistValues, function (controllerItem, index) {
                controllerItem.masterValue.toLowerCase() === selectedParentValue.toLowerCase() && angular.forEach(picklistValues, function (item) {
                    isDependentValue(index, item.validFor) && dependentValues.push(item)
                })
            }), dependentValues
        };
        var sforce = {};
        sforce.Base64Binary = function (text) {
            this.input = text
        }, sforce.Base64Binary.prototype.keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", sforce.Base64Binary.prototype.toString = function () {
            var chr1, chr2, enc1, enc2, enc3, output = [], chr3 = "", enc4 = "", i = 0;
            do chr1 = this.input.charCodeAt(i++), chr2 = this.input.charCodeAt(i++), chr3 = this.input.charCodeAt(i++), enc1 = chr1 >> 2, enc2 = (3 & chr1) << 4 | chr2 >> 4, enc3 = (15 & chr2) << 2 | chr3 >> 6, enc4 = 63 & chr3, isNaN(chr2) ? enc3 = enc4 = 64 : isNaN(chr3) && (enc4 = 64), output.push(this.keyStr.charAt(enc1) + this.keyStr.charAt(enc2) + this.keyStr.charAt(enc3) + this.keyStr.charAt(enc4)), chr1 = chr2 = chr3 = "", enc1 = enc2 = enc3 = enc4 = ""; while (i < this.input.length);
            return output.join("")
        }, sforce.Base64Binary.prototype.decode = function (input) {
            var chr1, chr2, enc1, enc2, enc3, output = [], chr3 = "", enc4 = "", i = 0,
                base64test = /[^A-Za-z0-9\+\/\=]/g;
            base64test.exec(input) && $log.debug("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, '+', '/', and '='\nExpect errors in decoding."), input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
            do enc1 = this.keyStr.indexOf(input.charAt(i++)), enc2 = this.keyStr.indexOf(input.charAt(i++)), enc3 = this.keyStr.indexOf(input.charAt(i++)), enc4 = this.keyStr.indexOf(input.charAt(i++)), chr1 = enc1 << 2 | enc2 >> 4, chr2 = (15 & enc2) << 4 | enc3 >> 2, chr3 = (3 & enc3) << 6 | enc4, output.push(String.fromCharCode(chr1)), 64 != enc3 && output.push(String.fromCharCode(chr2)), 64 != enc4 && output.push(String.fromCharCode(chr3)), chr1 = chr2 = chr3 = "", enc1 = enc2 = enc3 = enc4 = ""; while (i < input.length);
            return output.join("")
        }, service.checkAppVersionChanged = function () {
            var deferred = $q.defer(), $cordovaAppVersion = $injector.get("$cordovaAppVersion"),
                metaService = $injector.get("MetaService"), oldAppVersion = "";
            return metaService.getMetaValueEnhance("appVersion").then(function (appVer) {
                return oldAppVersion = appVer, $cordovaAppVersion.getVersionNumber()
            }).then(function (appVersion) {
                oldAppVersion !== appVersion ? deferred.resolve(!0) : deferred.resolve(!1)
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.translate = function (customLabelName, localLabelName) {
            var APP_SETTINGS = $injector.get("APP_SETTINGS"), $filter = $injector.get("$filter");
            return APP_SETTINGS.ENABLE_ONLINE_TRANSLATION && $filter("translate")(customLabelName) !== customLabelName ? $filter("translate")(customLabelName) : $filter("translate")(localLabelName)
        }
    }])
}(angular), function (angular) {
    "use strict";
    angular.module("oinio.core.components").component("actionFooterBar", {
        transclude: "true",
        templateUrl: "app/core/components/action-footer-bar.component/action-footer-bar.component.html",
        bindings: {objectType: "<", sobject: "<"},
        controller: ["$scope", "$http", "$ionicPopup", "$log", "$state", "PageLayoutService", "ModalService", "IonicLoadingService", "LocalDataService", "LocalSyncService", "ConnectionMonitor", "UtilService", function ($scope, $http, $ionicPopup, $log, $state, PageLayoutService, ModalService, IonicLoadingService, LocalDataService, LocalSyncService, ConnectionMonitor, UtilService) {
            function synchronize(objectType) {
                ConnectionMonitor.isOnline() && (IonicLoadingService.show(UtilService.translate("mobile_sync_lb_synchronizing", "cl.sync.lb_synchronizing")), LocalSyncService.syncUpObjectByName(objectType).then(function () {
                    IonicLoadingService.hide(), loadErrorMessages()
                }, function (error) {
                    IonicLoadingService.hide();
                    var alertPopup = $ionicPopup.alert({
                        title: "Synchronization failed.",
                        template: 'Please contact your administrator, if the problem persists.<br /><br /><span style="color:#CCCCCC">' + error + "</span>"
                    });
                    alertPopup.then(function (result) {
                        $log.error("errormessages.component::synchronize failure ==> " + error), $state.go(APP_SETTINGS.START_VIEW)
                    })
                }))
            }

            var ctrl = this, objectType = ctrl.objectType;
            this.$onInit = function () {
                $http.get("app/common/configuration/action-footer-bar.json").success(function (data) {
                    if (data.objectType.hasOwnProperty(objectType)) {
                        var oActions = data.objectType[objectType];
                        for (var sAction in oActions) switch (sAction) {
                            case"isEdit":
                                ctrl.isEdit = oActions[sAction];
                                break;
                            case"isCall":
                                ctrl.isCall = oActions[sAction];
                                break;
                            case"isLogACall":
                                ctrl.isLogACall = oActions[sAction];
                                break;
                            case"isNewVisit":
                                ctrl.isNewVisit = oActions[sAction];
                                break;
                            case"isNewEvent":
                                ctrl.isNewEvent = oActions[sAction];
                                break;
                            case"isNewTask":
                                ctrl.isNewTask = oActions[sAction];
                                break;
                            case"isNewContact":
                                ctrl.isNewContact = oActions[sAction];
                                break;
                            case"isSharePost":
                                ctrl.isSharePost = oActions[sAction];
                                break;
                            case"isShowMore":
                                ctrl.isShowMore = oActions[sAction]
                        }
                    }
                })
            }, this.editDetails = function () {
                PageLayoutService.generatePageLayoutForSObject(ctrl.sobject, !0).then(function (pageLayoutResult) {
                    ModalService.show("app/core/modal/templates/edit.record.modal.view.html", "SaveModalController as vm", {
                        layout: pageLayoutResult.layout,
                        sobject: ctrl.sobject
                    }, {
                        animation: "slide-in-up",
                        focusFirstInput: !1,
                        backdropClickToClose: !1,
                        hardwareBackButtonClose: !1
                    }).then(function (save) {
                        save === !0 && (IonicLoadingService.show(UtilService.translate("mobile_sync_lb_saving", "cl.sync.lb_saving")), LocalDataService.updateSObjects(ctrl.sobject.attributes.type, [ctrl.sobject]).then(function (saveSuccess) {
                            IonicLoadingService.hide(), synchronize(ctrl.sobject.attributes.type)
                        }, function (error) {
                            $log.error(">>>> Error in actionFooterBar component while saving an record in editDetails(): " + error)
                        }))
                    }, function (error) {
                        $log.error(">>>> Error in actionFooterBar component ctrl - editDetails(): " + error)
                    })
                }, function (err) {
                    $log.log(">>>> editDetails() err in actionFooterBar component")
                })
            }
        }]
    })
}(angular), function (angular, moment) {
    "use strict";
    angular.module("oinio.core.components").component("dateInput", {
        templateUrl: "app/core/components/date-input.component/date-input.component.html",
        require: {form: "^form"},
        bindings: {value: "=", fieldname: "<", fieldlabel: "<", fieldtype: "<", required: "<"},
        controller: ["$filter", "$timeout", "LocalCacheService", "localizeService", function ($filter, $timeout, LocalCacheService, localizeService) {
            var currentUser = LocalCacheService.get("currentUser");
            this.selectedTime = null, this.sfdcDate = null, this.setDate = function () {
                var lt = this.selectedTime;
                if (lt && currentUser) {
                    if ("date" === this.fieldtype) {
                        var currentTime = new Date;
                        lt.setHours(currentTime.getHours()), lt.setMinutes(currentTime.getMinutes()), lt.setSeconds(currentTime.getSeconds())
                    }
                    var sfTime = moment().tz(currentUser.TimeZoneSidKey).year(lt.getFullYear()).month(lt.getMonth()).date(lt.getDate()).hour(lt.getHours()).minute(lt.getMinutes()).second(lt.getSeconds()).millisecond(lt.getMilliseconds());
                    "datetime" === this.fieldtype ? (this.value = sfTime.utcOffset(0).format("YYYY-MM-DDTHH:mm:ss.SSSZZ"), this.sfdcDate = sfTime.toISOString()) : (this.value = sfTime.utcOffset(0).format("YYYY-MM-DD"), this.sfdcDate = this.value), this.formatedDate = localizeService.getFormattedString(this.sfdcDate, this.fieldtype)
                } else lt || (this.sfdcDate = null)
            }, this.$onInit = function () {
                if (this.value && currentUser) {
                    var timezone = currentUser.TimeZoneSidKey, sfTime = moment.tz(this.value, timezone);
                    this.selectedTime = new Date(sfTime.year(), sfTime.month(), sfTime.date(), sfTime.hour(), sfTime.minute(), sfTime.second(), sfTime.millisecond()), this.sfdcDate = this.value
                }
                this.formatedDate = localizeService.getFormattedString(this.selectedTime, this.fieldtype)
            }
        }],
        transclude: "true",
        controllerAs: "$ctrl"
    })
}(angular, moment), function (angular) {
    "use strict";
    angular.module("oinio.core.logger").service("Logger", ["$filter", "$injector", function ($filter, $injector) {
        function logObject(exception, params) {
            var log = "[" + params.type + "] - " + exception.name + " - " + exception.message + "\n" + exception.sourceURL + " line: " + exception.line + " column: " + exception.column;
            if ("function" == typeof exception.handle || exception.severity) {
                var msg = exception.message, rawEx = exception.rawException;
                !msg && rawEx && (msg = rawEx.responseJSON && rawEx.responseJSON[0].message ? rawEx.responseJSON[0].message : service.getErrorMessage(rawEx)), rawEx && "string" == typeof rawEx && (msg += " (" + rawEx + ")"),
                exception.message && rawEx && rawEx.responseJSON && rawEx.responseJSON[0].message && (msg += " [##### original message: " + rawEx.responseJSON[0].message + " #####]"), log = "[" + params.type + "] - [severity: " + exception.severity + ", code: " + exception.code + ", action time: " + $filter("date")(exception.localTime, "HH:mm:ss.sss") + "] - " + msg + "\n";
                for (var ret, sourceURL, stackStr = "" + exception.stack, pattern = new RegExp("(.*js):([1-9]\\d*):([1-9]\\d*)", "g"); null != (ret = pattern.exec(stackStr));) if (ret[0].indexOf("CommonError") === -1 && null !== (sourceURL = ret[0].match("\\w+:.*.js"))) {
                    log += sourceURL + " line: " + ret[2] + " column: " + ret[3];
                    break
                }
            }
            exception.cause && (log = log + "\ncause: \n" + exception.cause), params.includeStack === !0 && (log = log + "\nStacktrace: \n" + exception.stack), service.logToConsole === !0, params.logToFile === !0 && writeLog(log), "error" !== params.type || params.showAlert !== !0 || exception.severity || service.showError(exception), service.logToSoup && logToSoup()
        }

        function logString(exception, params) {
            var log = "[" + params.type + "] - " + exception;
            service.logToConsole === !0, params.logToFile === !0 && writeLog(log), "error" === params.type && params.showAlert === !0 && service.showError({
                title: null,
                message: exception
            })
        }

        function logToSoup() {
        }

        function writeLog(log) {
            var FileService = $injector.get("FileService");
            log = "\n" + $filter("date")(new Date, "yyyy-MM-dd HH:mm:ss Z") + " - " + log, FileService.writeLogDataByBuffer(log)
        }

        var service = {
            enabled: !1,
            logToConsole: !0,
            logToSoup: !0,
            logToFile: {
                headerInfo: "", debug: !1, info: !1, warn: !1, error: !0, log: !1, setting: function () {
                    service.logToFile.debug = arguments[0], service.logToFile.info = arguments[1], service.logToFile.warn = arguments[2], service.logToFile.error = arguments[3], service.logToFile.log = arguments[4]
                }
            },
            debug: function () {
                var params = {
                    type: "debug",
                    exceptions: arguments,
                    includeStack: !1,
                    showAlert: !1,
                    logToFile: service.logToFile.debug
                };
                log(params)
            },
            error: function () {
                var params = {
                    type: "error",
                    exceptions: arguments,
                    includeStack: !0,
                    showAlert: !0,
                    logToFile: service.logToFile.error
                };
                log(params)
            },
            warn: function () {
                var params = {
                    type: "warn",
                    exceptions: arguments,
                    includeStack: !1,
                    showAlert: !1,
                    logToFile: service.logToFile.warn
                };
                log(params)
            },
            info: function () {
                var params = {
                    type: "info",
                    exceptions: arguments,
                    includeStack: !1,
                    showAlert: !1,
                    logToFile: service.logToFile.info
                };
                log(params)
            },
            log: function () {
                var params = {
                    type: "log",
                    exceptions: arguments,
                    includeStack: !1,
                    showAlert: !1,
                    logToFile: service.logToFile.log
                };
                log(params)
            }
        };
        service.initializeLogSetting = function () {
            var deferred = $injector.get("$q").defer(), LOG_SETTING = $injector.get("LOG_SETTING"),
                logLevel = LOG_SETTING.LOG_LEVEL;
            switch (logLevel) {
                case"debug":
                    service.logToFile.setting(!0, !0, !0, !0, !0);
                    break;
                case"info":
                    service.logToFile.setting(!1, !0, !0, !0, !0);
                    break;
                case"warn":
                    service.logToFile.setting(!1, !1, !0, !0, !0);
                    break;
                case"error":
                    service.logToFile.setting(!1, !1, !1, !0, !0);
                    break;
                case"log":
                    service.logToFile.setting(!1, !1, !1, !1, !0);
                    break;
                default:
                    service.logToFile.setting(!1, !1, !1, !1, !1)
            }
            return setLoggingRelatedInfo().then(function () {
                return $injector.get("MetaService").getMetaValueEnhance("logging")
            }).then(function (logging) {
                void 0 !== logging && null !== logging || (logging = LOG_SETTING.LOGGING), service.enabled = logging, deferred.resolve()
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        var setLoggingRelatedInfo = function () {
            var deferred = $injector.get("$q").defer();
            service.logToFile.headerInfo = "";
            var $cordovaAppVersion = $injector.get("$cordovaAppVersion");
            return $cordovaAppVersion.getAppName().then(function (appName) {
                service.logToFile.headerInfo += "App name: " + appName + "\n";
                var currentUser = $injector.get("LocalCacheService").get("currentUser");
                return currentUser && (service.logToFile.headerInfo += "Username: " + currentUser.Username + "\n"), service.logToFile.headerInfo += "Manufacturer: " + device.manufacturer + "\n", service.logToFile.headerInfo += "Model name: " + device.model + "\n", service.logToFile.headerInfo += "Operating system: " + device.platform + "\n", service.logToFile.headerInfo += "Operating system version: " + device.version + "\n", $cordovaAppVersion.getPackageName()
            }).then(function (appPackage) {
                return service.logToFile.headerInfo += "App package: " + appPackage + "\n", $cordovaAppVersion.getVersionNumber()
            }).then(function (appVersion) {
                service.logToFile.headerInfo += "App version: " + appVersion + "\n", deferred.resolve()
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        };
        service.changeLoggingSetting = function (enabledLog) {
            var deferred = $injector.get("$q").defer();
            return service.enabled = enabledLog, $injector.get("MetaService").setMetaValue("logging", enabledLog).then(function () {
                return $injector.get("FileService").initializeLogFolder()
            }).then(function () {
                deferred.resolve()
            })["catch"](function (error) {
                deferred.reject(error)
            }), deferred.promise
        }, service.showError = function (exception) {
            var $state = $injector.get("$state"), IonicLoadingService = $injector.get("IonicLoadingService"),
                $window = ($injector.get("$ionicPopup"), $injector.get("$window")),
                APP_SETTINGS = $injector.get("APP_SETTINGS");
            IonicLoadingService.hide(), $window.plugins.toast.showWithOptions({
                message: service.getErrorMessage(exception),
                duration: 2500,
                position: "bottom",
                styling: {
                    opacity: 1,
                    backgroundColor: "#54698d",
                    textColor: "#FFFFFF",
                    textSize: 13,
                    cornerRadius: 4,
                    horizontalPadding: 24,
                    verticalPadding: 12
                }
            }), $state.go(APP_SETTINGS.START_VIEW)
        }, service.getErrorMessage = function (exception) {
            var message = "";
            switch (exception.status) {
                case 400:
                    message = "Received data does not match the expected format. Please contact your administrator.";
                    break;
                case 401:
                    message = "You are not authorized to access data. Please contact your administrator.";
                    break;
                case 403:
                    message = "Access to data forbidden. Please contact your administrator.";
                    break;
                case 404:
                    message = "Could not access data. Please check your internet connection.";
                    break;
                case 405:
                    message = "Using a non allowed method to access data. Please contact your administrator.";
                    break;
                case 407:
                    message = "Proxy authentication required. Please contact your administrator.";
                    break;
                case 408:
                    message = "Timeout received. Please check your internet connection.";
                    break;
                case 415:
                    message = "Returned media type is not supported by this app. Please contact your administrator.";
                    break;
                case 500:
                    message = "Remote endpoint reported an internal error. Please contact your administrator.";
                    break;
                case 503:
                    message = "Remote endpoint is not available. Please contact your administrator.";
                    break;
                default:
                    message = "Unexpected error. Please contact your administrator. Details: " + exception.name + ": " + exception.message
            }
            return message
        };
        var log = function (params) {
            service.enabled === !0 && angular.forEach(params.exceptions, function (exception) {
                "object" == typeof exception ? logObject(exception, params) : logString(exception, params)
            })
        };
        return service
    }])
}(angular), function () {
    "use strict";
    angular.module("oinio.core.modal").controller("SaveModalController", ["$scope", "parameters", function ($scope, parameters) {
        var vm = this;
        vm.sobject = parameters.sobject, vm.layout = parameters.layout, vm.readOnlyFields = parameters.readOnlyFields, vm.save = function (pageLayoutForm) {
            for (var prop in pageLayoutForm) if (0 !== prop.indexOf("$")) {
                var current = pageLayoutForm[prop];
                if (!current.$pristine && current.$valid && prop in vm.sobject) vm.sobject[prop] = current.$modelValue; else if (!current.$pristine && current.$valid && prop.indexOf(".") !== -1) {
                    var splitted = prop.split(".");
                    vm.sobject[splitted[0]][1] = current.$modelValue
                }
            }
            $scope.closeModal(!0)
        }, vm.cancel = function () {
            $scope.closeModal(!1)
        }
    }])
}(), function () {
    "use strict";
    angular.module("oinio.core.modal").service("ModalService", ["$ionicModal", "$rootScope", "$q", "$injector", "$controller", function ($ionicModal, $rootScope, $q, $injector, $controller) {
        function _cleanup(scope) {
            scope.$destroy(), scope.modal && scope.modal.remove()
        }

        function _evalController(ctrlName) {
            var result = {isControllerAs: !1, controllerName: "", propName: ""},
                fragments = (ctrlName || "").trim().split(/\s+/);
            return result.isControllerAs = 3 === fragments.length && "as" === (fragments[1] || "").toLowerCase(), result.isControllerAs ? (result.controllerName = fragments[0], result.propName = fragments[2]) : result.controllerName = ctrlName, result
        }

        this.show = function (templeteUrl, controller, parameters, options) {
            var ctrlInstance, deferred = $q.defer(), modalScope = $rootScope.$new(), thisScopeId = modalScope.$id,
                defaultOptions = {
                    animation: "slide-in-up",
                    focusFirstInput: !1,
                    backdropClickToClose: !1,
                    hardwareBackButtonClose: !1,
                    modalCallback: null
                };
            return options = angular.extend({}, defaultOptions, options), $ionicModal.fromTemplateUrl(templeteUrl, {
                scope: modalScope,
                animation: options.animation,
                focusFirstInput: options.focusFirstInput,
                backdropClickToClose: options.backdropClickToClose,
                hardwareBackButtonClose: options.hardwareBackButtonClose
            }).then(function (modal) {
                modalScope.modal = modal, modalScope.openModal = function () {
                    modalScope.modal.show()
                }, modalScope.closeModal = function (result) {
                    deferred.resolve(result), modalScope.modal.hide()
                }, modalScope.$on("modal.hidden", function (thisModal) {
                    if (thisModal.currentScope) {
                        var modalScopeId = thisModal.currentScope.$id;
                        thisScopeId === modalScopeId && (deferred.resolve(null), _cleanup(thisModal.currentScope))
                    }
                });
                var locals = {$scope: modalScope, parameters: parameters}, ctrlEval = _evalController(controller);
                ctrlInstance = $controller(controller, locals), ctrlEval.isControllerAs && (ctrlInstance.openModal = modalScope.openModal, ctrlInstance.closeModal = modalScope.closeModal), modalScope.modal.show().then(function () {
                    modalScope.$broadcast("modal.afterShow", modalScope.modal)
                }), angular.isFunction(options.modalCallback) && options.modalCallback(modal)
            }, function (err) {
                deferred.reject(err)
            }), deferred.promise
        }
    }])
}(), function () {
    "use strict";

    function SimpleModalService($ionicModal, $rootScope) {
        var init = function (tpl, $scope, sAnimate) {
            var promise;
            return $scope = $scope || $rootScope.$new(), promise = $ionicModal.fromTemplateUrl(tpl, {
                scope: $scope,
                animation: sAnimate
            }).then(function (modal) {
                return $scope.modal = modal, modal
            }), $scope.openModal = function () {
                $scope.modal.show()
            }, $scope.closeModal = function () {
                $scope.modal.remove()
            }, $scope.$on("$destroy", function () {
                $scope.modal.remove()
            }), promise
        };
        return {init: init}
    }

    SimpleModalService.$inject = ["$ionicModal", "$rootScope"], angular.module("oinio.core.modal").service("SimpleModalService", SimpleModalService)
}(), function (angular) {
    "use strict";
    angular.module("oinio.core.detail").controller("ObjectDetailTabController", ["$scope", "$injector", "$stateParams", "PageLayoutService", function ($scope, $injector, $stateParams, PageLayoutService) {
        var vm = this;
        vm.mode = "view", vm.objectType = $stateParams.objectType, vm.sid = $stateParams.sid;
        var sid = $stateParams.sid, isEdit = !1;
        vm.layout = {}, vm.sobject = {}, vm.getPageLayout = function () {
            PageLayoutService.generatePageLayout(vm.objectType, sid, isEdit).then(function (resolve) {
                vm.layout = resolve.layout, vm.sobject = resolve.sobject
            }, function (error) {
            })
        }, vm.getRelatedLists = function () {
            var relatedListService = $injector.get("RelatedListService");
            PageLayoutService.generatePageLayout(vm.objectType, sid, isEdit).then(function (resolve) {
                vm.sobject = resolve.sobject, vm.labelName = vm.sobject.Name
            }, function (error) {
            }), relatedListService.getAllRelatedListsByObjectType(vm.objectType).then(function (relatedLists) {
                vm.relatedLists = relatedLists
            })["catch"](function (error) {
            })
        }, vm.getStringifiedResultList = function (resultList) {
            return JSON.stringify(resultList)
        }, vm.relatedLists = []
    }])
}(angular), function (angular) {
    "use strict";
    angular.module("oinio.core.detail").controller("ObjectRelatedListController", ["$scope", "$injector", "$stateParams", "PageLayoutService", function ($scope, $injector, $stateParams, PageLayoutService) {
        var vm = this;
        vm.mode = "view", vm.relatedList = JSON.parse($stateParams.relatedList), vm.objectType = $stateParams.objectType, vm.pageSize = $stateParams.pageSize, vm.page = $stateParams.page, vm.sid = $stateParams.sid, vm.labelName = $stateParams.labelName;
        vm.layout = {}, vm.sobject = {}, vm.getRecordsForRelatedList = function () {
            var relatedListService = $injector.get("RelatedListService");
            relatedListService.getPageableRelatedRecordsForRelatedList(vm.relatedList, vm.sid, vm.objectType, vm.pageSize, vm.page).then(function (records) {
                vm.records = records
            })["catch"](function (error) {
            })
        }, vm.getName = function (record) {
            if (record) return "Case" === vm.relatedList.sobject ? record.Subject : record.Name
        }, vm.records = []
    }])
}(angular), function (angular) {
    "use strict";
    angular.module("oinio.core.detail").controller("ObjectTabsController", ["$q", "$scope", "$stateParams", "$ionicScrollDelegate", "PageLayoutService", function ($q, $scope, $stateParams, $ionicScrollDelegate, PageLayoutService) {
        var vm = this;
        vm.mode = "view", vm.objectType = $stateParams.objectType, vm.sid = $stateParams.sid, vm.sobject = null, vm.layout = null, vm.initTabCtrl = !1, vm.scroll = !0, $scope.reportSlideChanged = function (index) {
            switch (index) {
                case 0:
                    vm.isDetailTab = !0;
                    break;
                case 1:
                    vm.isRelatedListTab = !0
            }
        }, $scope.$on("$ionicView.beforeEnter", function () {
            PageLayoutService.generatePageLayout(vm.objectType, vm.sid, !1).then(function (resolve) {
                vm.layout = resolve.layout, vm.sobject = resolve.sobject, vm.initTabCtrl = !0
            }, function (error) {
            })
        })
    }])
}(angular), function () {
    "use strict";
    angular.module("oinio.core.detail").service("ObjectDetailService", ["$q", "$log", "$injector", function ($q, $log, $injector) {
        var pageLayoutResult = null;
        this.getPageLayoutResult = function () {
            return pageLayoutResult
        }, this.getLayout = function () {
            return pageLayoutResult.layout
        }, this.getSObject = function () {
            return pageLayoutResult.sobject
        }, this.loadSObjectForLayout = function (objectType, sid) {
            var deferred = $q.defer(), pageLayoutService = $injector.get("PageLayoutService");
            return pageLayoutService.generatePageLayout(objectType, sid, !1).then(function (layoutResult) {
                pageLayoutResult = {
                    sobject: layoutResult.sobject,
                    layout: layoutResult.layout
                }, deferred.resolve(pageLayoutResult)
            }, function (error) {
                $log.error(">>>> Error in ObjectDetailService loadSObjectForLayout(): " + error), deferred.reject("error during generating pagelayout")
            }), deferred.promise
        }
    }])
}(), function (angular) {
    "use strict";
    angular.module("oinio.core.object-home").controller("ObjectHomeController", ["$scope", "$filter", "$stateParams", "$ionicNavBarDelegate", "LocalDataService", "PageLayoutService", "ModalService", "IonicLoadingService", "LocalSyncService", "ConnectionMonitor", "UtilService", function ($scope, $filter, $stateParams, $ionicNavBarDelegate, LocalDataService, PageLayoutService, ModalService, IonicLoadingService, LocalSyncService, ConnectionMonitor, UtilService) {
        var vm = this, pageSize = 20;
        vm.objectType = $stateParams.objectType, vm.objectLabel = $filter("translate")(vm.objectType + ".labelPlural"), vm.searchTerm = $stateParams.searchTerm, $scope.$on("$ionicView.afterEnter", function (viewInfo, state) {
            setTimeout(function () {
                $ionicNavBarDelegate.align("left")
            }, 10)
        }), $scope.$on("$ionicView.beforeEnter", function (viewInfo, state) {
            LocalDataService.getObjectStylesByName([vm.objectType]).then(function (objectTypes) {
                vm.iconClassName = objectTypes[vm.objectType]["class"], vm.iconClassPath = objectTypes[vm.objectType].icon
            }), vm.searchTerm && vm.searchTerm.trim().length >= 3 ? vm.search(vm.searchTerm) : LocalDataService.globalSearch(vm.objectType, null, 5, "LastViewedDate", "DESC").then(function (resolve) {
                searchResults = resolve, vm.showingRecords = searchResults.slice(0, pageSize)
            })
        });
        var searchResults = [];
        vm.showingRecords = [], vm.search = function (searchTerm) {
            vm.message = null, searchTerm && searchTerm.trim().length < 3 ? vm.message = UtilService.translate("mobile_global_msg_searchTermLengthRequired", "cl.global.msg_searchTermLengthRequired") : LocalDataService.globalSearch(vm.objectType, searchTerm).then(function (resolve) {
                searchResults = resolve, vm.showingRecords = searchResults.slice(0, pageSize), resolve && resolve.length || (vm.message = UtilService.translate("mobile_global_msg_searchWithNoResults", "cl.global.msg_searchWithNoResults").trim() + " '" + searchTerm + "'")
            })
        }, vm.loadMore = function () {
            vm.showingRecords = vm.showingRecords.concat(searchResults.slice(vm.showingRecords.length, vm.showingRecords.length + pageSize)), $scope.$broadcast("scroll.infiniteScrollComplete")
        }, vm.moreDataCanBeLoaded = function () {
            return vm.showingRecords.length < searchResults.length
        }, $scope.$on("$stateChangeSuccess", function () {
            vm.loadMore()
        }), vm.createSObject = function () {
            LocalDataService.createSObject(vm.objectType, null).then(function (sobj) {
                vm.newSObject = sobj, PageLayoutService.generatePageLayoutForSObject(vm.newSObject, !0).then(function (pagelayoutResult) {
                    ModalService.show("app/core/modal/templates/edit.record.modal.view.html", "SaveModalController as vm", {
                        layout: pagelayoutResult.layout,
                        sobject: vm.newSObject
                    }, {
                        animation: "slide-in-up",
                        focusFirstInput: !1,
                        backdropClickToClose: !1,
                        hardwareBackButtonClose: !1
                    }).then(function (save) {
                        save === !0 && (IonicLoadingService.show(UtilService.translate("mobile_sync_lb_saving", "cl.sync.lb_saving")), LocalDataService.saveSObjects(vm.newSObject.attributes.type, [vm.newSObject]).then(function (saveSuccess) {
                            saveSuccess[0].success && (vm.newSObject._soupEntryId = saveSuccess[0]._soupEntryId, IonicLoadingService.hide(), vm.synchronize(vm.newSObject.attributes.type))
                        }, function (error) {
                            $log.error(">>>> Error in AccountDetailController while saving an record in editDetails(): " + error)
                        }))
                    }, function (error) {
                        $log.error(">>>> Error in AccountDetailController - editDetails(): " + error)
                    })
                }, function (error) {
                    $log.error(">>>> Error in AccountDetailController - editDetails(): " + error)
                })
            }, function (error) {
                $log.error(error)
            })
        }, vm.synchronize = function (objectType) {
            ConnectionMonitor.isOnline() ? (IonicLoadingService.show(UtilService.translate("mobile_sync_lb_synchronizing", "cl.sync.lb_synchronizing")), LocalSyncService.syncUpObjectByName(objectType).then(function () {
                LocalDataService.getSObject(vm.newSObject.attributes.type, vm.newSObject._soupEntryId).then(function (reloadedSObject) {
                    vm.newSObject = reloadedSObject, IonicLoadingService.hide()
                })
            })) : LocalDataService.getSObject(vm.newSObject.attributes.type, vm.newSObject._soupEntryId).then(function (reloadedSObject) {
                vm.newSObject = reloadedSObject
            })
        }, vm.getName = function (item) {
            if (item) return "Case" === vm.objectType ? item.Subject : item.Name
        }
    }])
}(angular), function (angular) {
    "use strict";
    angular.module("oinio.core.object-home").directive("searchBox", function () {
        return {
            restrict: "E",
            replace: !0,
            scope: {doSearch: "&submit", searchTerm: "=?ngModel"},
            link: function (scope, element, attrs) {
            },
            template: '<form class="searchBox" ng-submit="doSearch({searchTerm: searchTerm});"><div class="slds-form-element__control slds-input-has-icon slds-input-has-icon--right"><svg aria-hidden="true" class="slds-input__icon slds-icon-text-default"><use ng-show="!searchTerm" xlink:href="lib/salesforce-lightning-design-system/assets/icons/utility-sprite/svg/symbols.svg#search"></use><use ng-show="searchTerm" xlink:href="lib/salesforce-lightning-design-system/assets/icons/utility-sprite/svg/symbols.svg#close" ng-click="searchTerm = null;"></use></svg><input style="height: 28px;display: inline-block;min-height: initial; margin-bottom: 4px;" class="slds-input" type="text" aria-haspopup="true" aria-autocomplete="list" role="combobox" aria-activedescendant="" ng-model="searchTerm"/></div></form>'
        }
    })
}(angular), function () {
    "use strict";

    function StaticIncludeWithoutNewScope() {
        return {
            restrict: "AE", templateUrl: function (ele, attrs) {
                return attrs.templatePath
            }
        }
    }

    angular.module("oinio.core.pageLayoutRenderer").directive("staticIncludeWithoutNewScope", StaticIncludeWithoutNewScope)
}(), angular.module("oinio.core.pageLayoutRenderer").component("layoutComponents", {
    templateUrl: "app/core/pagelayout/layoutcomponents/layoutcomponents.component.html",
    bindings: {
        layoutcomponents: "<",
        editableForUpdate: "<",
        required: "<",
        rendermode: "<",
        sobject: "<",
        readOnlyFields: "<"
    },
    controller: ["localizeService", function (localizeService) {
        this.$onInit = function (changesObj) {
        }, this.getFormattedString = function (value, type) {
            return localizeService.getFormattedString(value, type)
        }, this.getObjectURL = function (relationshipName) {
            return localizeService.getObjectURL(this.sobject, relationshipName)
        }, this.getReferenceLabel = function (relationshipName, objectType) {
            return localizeService.getReferenceLabel(this.sobject, relationshipName, objectType)
        }, this.getPicklistLabel = function (picklist, values) {
            return localizeService.getPicklistLabel(this.sobject, picklist, values)
        }, this.getMultiPicklistLabel = function (picklist, values) {
            return localizeService.getMultiPicklistLabel(this.sobject, picklist, values)
        }
    }],
    transclude: "true",
    controllerAs: "$ctrl"
}), angular.module("oinio.core.pageLayoutRenderer").component("layoutHeader", {
    templateUrl: "app/core/pagelayout/layoutheader/layoutheader.component.html",
    bindings: {sobject: "<", showHeader: "<", headerHighlightFields: "<"},
    controller: ["$filter", function ($filter) {
        this.getName = function () {
            if (this.sobject) {
                var nameField;
                switch (this.sobject.attributes.type) {
                    case"Case":
                    case"Task":
                    case"Event":
                    case"Attachment":
                    case"Case":
                        nameField = "Subject";
                        break;
                    default:
                        nameField = "Name"
                }
                return this.sobject[nameField]
            }
        }, this.getFormattedHeader = function () {
            if (this.sobject) return $filter("addressFormatter")(this.sobject.BillingAddress)
        }
    }],
    transclude: "true",
    controllerAs: "$ctrl"
}), angular.module("oinio.core.pageLayoutRenderer").component("layoutSections", {
    templateUrl: "app/core/pagelayout/layoutsections/layoutsections.component.html",
    bindings: {
        rendermode: "<",
        sobject: "<",
        layoutsections: "<",
        expandSection: "&",
        collapseSections: "<",
        readOnlyFields: "<"
    },
    transclude: "true",
    controllerAs: "$ctrl",
    controller: ["$ionicScrollDelegate", "customScrollDelegateService", function ($ionicScrollDelegate, customScrollDelegateService) {
        this.created = [0], this.expanded = [0], this.$onInit = function (initObject) {
            this.setFirstToggled = function (section, isFirst) {
                isFirst && this.toggleSection(section)
            }
        }, this.$onChanges = function (changesObject) {
        }, this.expandSection = function (index) {
            this.created.indexOf(index) === -1 && this.created.push(index), this.expanded.indexOf(index) === -1 ? this.expanded.push(index) : this.expanded.splice(this.expanded.indexOf(index), 1), "view" === this.rendermode ? $ionicScrollDelegate.$getByHandle("pageLayoutViewMode").resize() : "edit" === this.rendermode && customScrollDelegateService.$getByHandle("pageLayoutEditMode").resize()
        }, this.toggleSection = function (section) {
            section.toggled = !section.toggled
        }
    }]
}), angular.module("oinio.core.pageLayoutRenderer").component("addressComponent", {
    templateUrl: "app/core/pagelayout/layoutitems/address.component/address.component.html",
    require: {form: "^form"},
    bindings: {
        sobject: "<",
        components: "<",
        required: "<",
        placeholder: "<",
        tabOrder: "<",
        editableForUpdate: "<",
        detail: "<"
    },
    controller: function () {
        this.$onInit = function () {
        }, this.changeHandler = function (fieldName) {
            var addressFieldName = this.getAddressFieldFromFieldName(fieldName);
            this.form[this.detail.name + "." + addressFieldName].$setViewValue(this.form[fieldName].$modelValue)
        }, this.getAddressFieldFromFieldName = function (fieldName) {
            var fn = fieldName.toLowerCase();
            return fn.indexOf("street") > -1 ? "street" : fn.indexOf("city") > -1 ? "city" : fn.indexOf("country") > -1 ? "country" : fn.indexOf("postalcode") > -1 ? "postalCode" : fn.indexOf("state") > -1 ? "state" : fn.indexOf("latitude") > -1 ? "latitude" : fn.indexOf("longitude") > -1 ? "longitude" : void 0
        }
    },
    transclude: "true",
    controllerAs: "$ctrl"
}), angular.module("oinio.core.pageLayoutRenderer").component("booleanComponent", {
    templateUrl: "app/core/pagelayout/layoutitems/boolean.component/boolean.component.html",
    require: {form: "^form"},
    bindings: {
        value: "<",
        detail: "<",
        required: "<",
        tabOrder: "<",
        editableForUpdate: "<",
        readOnlyFields: "<",
        onChange: "&"
    },
    controller: function () {
        this.itemEditableForUpdate = !1, this.itemIsEditableForUpdate = function () {
            return (!this.readOnlyFields || this.readOnlyFields.indexOf(this.detail.name) === -1) && this.editableForUpdate
        }, this.$onInit = function () {
            this.itemEditableForUpdate = this.itemIsEditableForUpdate()
        }, this.change = function () {
            this.onChange && this.onChange({fieldName: this.detail.name})
        }
    },
    transclude: "true",
    controllerAs: "$ctrl"
}), angular.module("oinio.core.pageLayoutRenderer").component("contactNameComponent", {
    templateUrl: "app/core/pagelayout/layoutitems/contact.name.component/contact.name.component.html",
    require: {form: "^form"},
    bindings: {
        sobject: "<",
        detail: "<",
        components: "<",
        required: "<",
        placeholder: "<",
        tabOrder: "<",
        editableForUpdate: "<"
    },
    controller: function () {
        this.$onInit = function () {
        }, this.changeHandler = function (fieldName) {
            var nameString = "";
            "FirstName" in this.form && this.form.FirstName.$modelValue && "" !== this.form.FirstName.$modelValue && (nameString += this.form.FirstName.$modelValue + " "), this.form.Name.$setViewValue(nameString + this.form.LastName.$modelValue)
        }
    },
    transclude: "true",
    controllerAs: "$ctrl"
}), function (angular, moment) {
    "use strict";
    angular.module("oinio.core.pageLayoutRenderer").component("dateComponent", {
        templateUrl: "app/core/pagelayout/layoutitems/date.component/date.component.html",
        require: {form: "^form"},
        bindings: {value: "<", detail: "<", required: "<", tabOrder: "<", editableForUpdate: "<"},
        controller: ["$filter", "$timeout", "LocalCacheService", "localizeService", function ($filter, $timeout, LocalCacheService, localizeService) {
            var currentUser = LocalCacheService.get("currentUser");
            this.tabOrder;
            this.selectedTime = null, this.sfdcDate = null, this.itemEditableForUpdate = !1, this.setDate = function () {
                var lt = this.selectedTime;
                if (lt && currentUser) {
                    if ("date" === this.detail.type) {
                        var currentTime = new Date;
                        lt.setHours(currentTime.getHours()), lt.setMinutes(currentTime.getMinutes()), lt.setSeconds(currentTime.getSeconds())
                    }
                    var sfTime = moment().tz(currentUser.TimeZoneSidKey).year(lt.getFullYear()).month(lt.getMonth()).date(lt.getDate()).hour(lt.getHours()).minute(lt.getMinutes()).second(lt.getSeconds()).millisecond(lt.getMilliseconds());
                    "datetime" === this.detail.type ? (this.value = sfTime.utcOffset(0).format("YYYY-MM-DDTHH:mm:ss.SSSZZ"), this.sfdcDate = sfTime.toISOString()) : (this.value = sfTime.utcOffset(0).format("YYYY-MM-DD"), this.sfdcDate = this.value), this.form[this.detail.name].$setViewValue(this.sfdcDate), this.formatedDate = localizeService.getFormattedString(this.sfdcDate, this.detail.type)
                } else lt || (this.sfdcDate = null, this.formatedDate = null);
                this.form[this.detail.name].$setTouched()
            }, this.itemIsEditableForUpdate = function () {
                return (!this.readOnlyFields || this.readOnlyFields.indexOf(this.detail.name) === -1) && this.editableForUpdate
            }, this.$onInit = function () {
                if (this.itemEditableForUpdate = this.itemIsEditableForUpdate(), this.value && currentUser) {
                    var timezone = currentUser.TimeZoneSidKey, sfTime = moment.tz(this.value, timezone);
                    this.selectedTime = new Date(sfTime.year(), sfTime.month(), sfTime.date(), sfTime.hour(), sfTime.minute(), sfTime.second(), sfTime.millisecond()), this.sfdcDate = this.value
                }
                this.formatedDate = localizeService.getFormattedString(this.selectedTime, this.detail.type)
            }
        }],
        transclude: "true",
        controllerAs: "$ctrl"
    })
}(angular, moment), angular.module("oinio.core.pageLayoutRenderer").component("multiPicklistComponent", {
    templateUrl: "app/core/pagelayout/layoutitems/multipicklist.component/multipicklist.component.html",
    require: {form: "^form"},
    bindings: {value: "<", detail: "<", required: "<", tabOrder: "<", editableForUpdate: "<", readOnlyFields: "<"},
    controller: ["$filter", "UtilService", function ($filter, UtilService) {
        this.selectInputName = "$picklist-" + this.detail.name, this.selectedPicklistValues = this.value, this.itemEditableForUpdate = !1, this.deselectItem = {
            label: "---",
            value: "---"
        }, this.itemIsEditableForUpdate = function () {
            return (!this.readOnlyFields || this.readOnlyFields.indexOf(this.detail.name) === -1) && this.editableForUpdate
        }, this.$onInit = function () {
            this.selectedOptions = [], this.selectOptions = [];
            var picklistValues = this.detail.picklistValues;
            this.itemEditableForUpdate = this.itemIsEditableForUpdate(), UtilService.isAndroidOS() || this.selectOptions.push(this.deselectItem);
            for (var i = 0; i < picklistValues.length; i++) {
                var item = picklistValues[i], selectItem = {label: item.label, value: item.value};
                this.value && this.value.indexOf(item.value) !== -1 && this.selectedOptions.push(selectItem), item.active && this.selectOptions.push(selectItem)
            }
            this.multiPickListLabel = _getSelectedLabel(this.selectedOptions)
        }, this.setSelected = function () {
            for (var j = this.selectedOptions.length - 1; j >= 0; j--) this.selectedOptions[j].value === this.deselectItem.value && this.selectedOptions.splice(j, 1);
            this.selectedPicklistValues = "";
            var plValuesString = "";
            if (angular.isArray(this.selectedOptions)) {
                for (var i = 0; i < this.selectedOptions.length; i++) {
                    var item = this.selectedOptions[i];
                    "" !== plValuesString && "---" !== plValuesString && (plValuesString += ";"), plValuesString += item.value
                }
                this.selectedPicklistValues = plValuesString, this.form[this.detail.name].$setViewValue(plValuesString), this.multiPickListLabel = _getSelectedLabel(this.selectedOptions)
            }
        };
        var _getSelectedLabel = function (selected) {
            var output, numOfElements = selected.length;
            return output = 1 == numOfElements ? selected[0].label : numOfElements + " " + UtilService.translate("mobile_global_lb_items", "cl.global.lb_items")
        }
    }],
    transclude: "true",
    controllerAs: "$ctrl"
}), angular.module("oinio.core.pageLayoutRenderer").component("numberComponent", {
    templateUrl: "app/core/pagelayout/layoutitems/number.component/number.component.html",
    require: {form: "^form"},
    bindings: {
        value: "<",
        detail: "<",
        required: "<",
        tabOrder: "<",
        editableForUpdate: "<",
        readOnlyFields: "<",
        onChange: "&"
    },
    controller: function () {
        this.itemEditableForUpdate = !1, this.itemIsEditableForUpdate = function () {
            return (!this.readOnlyFields || this.readOnlyFields.indexOf(this.detail.name) === -1) && this.editableForUpdate
        }, this.$onInit = function () {
            this.itemEditableForUpdate = this.itemIsEditableForUpdate()
        }, this.change = function () {
            this.onChange && this.onChange({fieldName: this.detail.name})
        }
    },
    transclude: "true",
    controllerAs: "$ctrl"
}), angular.module("oinio.core.pageLayoutRenderer").component("picklistComponent", {
    templateUrl: "app/core/pagelayout/layoutitems/picklist.component/picklist.component.html",
    require: {form: "^form"},
    bindings: {
        value: "<",
        detail: "<",
        required: "<",
        tabOrder: "<",
        editableForUpdate: "<",
        readOnlyFields: "<",
        onChange: "&"
    },
    controller: function () {
        this.itemEditableForUpdate = !1, this.itemIsEditableForUpdate = function () {
            return (!this.readOnlyFields || this.readOnlyFields.indexOf(this.detail.name) === -1) && this.editableForUpdate
        }, this.$onInit = function () {
            this.itemEditableForUpdate = this.itemIsEditableForUpdate(), this.selectInputName = "$picklist-" + this.detail.name, this.selectedOption = {}, this.selectOptions = [];
            for (var picklistValues = this.detail.picklistValues, i = 0; i < picklistValues.length; i++) {
                var item = picklistValues[i], selectItem = {label: item.label, value: item.value};
                this.value === item.value && (this.selectedOption = selectItem), item.active && this.selectOptions.push(selectItem)
            }
        }, this.change = function () {
            this.form[this.detail.name].$setViewValue(this.form[this.selectInputName].$viewValue), this.onChange && this.onChange({fieldName: this.detail.name})
        }
    },
    transclude: "true",
    controllerAs: "$ctrl"
}), angular.module("oinio.core.pageLayoutRenderer").component("referenceComponent", {
    templateUrl: "app/core/pagelayout/layoutitems/reference.component/reference.component.html",
    require: {form: "^form"},
    bindings: {
        value: "<",
        detail: "<",
        required: "<",
        sobject: "<",
        tabOrder: "<",
        editableForUpdate: "<",
        readOnlyFields: "<",
        onChange: "&"
    },
    controller: ["$scope", "$filter", "$sce", "localizeService", "LocalDataService", "SimpleModalService", "DescribeService", "UtilService", function ($scope, $filter, $sce, localizeService, LocalDataService, SimpleModalService, DescribeService, UtilService) {
        var _this = this;
        _this.itemEditableForUpdate = !1, _this.itemIsEditableForUpdate = function () {
            return (!_this.readOnlyFields || _this.readOnlyFields.indexOf(_this.detail.name) === -1) && _this.editableForUpdate
        }, _this.$onInit = function () {
            _this.itemEditableForUpdate = _this.itemIsEditableForUpdate()
        }, _this.getReferenceLabel = function (relationshipName, objectType) {
            return localizeService.getReferenceLabel(_this.sobject, relationshipName, objectType)
        }, _this.resetValue = function () {
            _this.value = void 0, _this.sobject[_this.detail.name + "_sid"] = void 0, _this.sobject[_this.detail.name + "_rt"] = void 0, _this.referencedObjectName = void 0
        }, _this.referencedObjectName = _this.getReferenceLabel(_this.detail.relationshipName, _this.detail.type), _this.detail.referenceTo && 1 === _this.detail.referenceTo.length ? _this.placeholder = "Select " + $filter("translate")(_this.detail.referenceTo + ".label") : _this.placeholder = "Select", _this.editReferenceValue = function () {
            LocalDataService.resolveRefer2ExistingObjectNames(_this.detail.referenceTo).then(function (objNames) {
                _this.referenceTo = objNames, _this.referenceTo && _this.referenceTo.length > 0 && (initModalScope(), SimpleModalService.init("content-type-reference-modal.html", $scope, "slide-in-up").then(function (modal) {
                    document.getElementById("ref-" + _this.detail.name).blur(), modal.show()
                }))
            }, function (error) {
            })
        }, this.change = function () {
            this.onChange && this.onChange({
                fieldName: this.detail.name
            })
        };
        var limitSize = 50, pageSize = 10, initModalScope = function () {
            _this.objectType = _this.referenceTo[0], _this.searchTerm = void 0, _this.searchResults = [], _this.showingRecords = [], _this.selectOptions = [], _this.message = null, angular.forEach(_this.referenceTo, function (objName) {
                _this.selectOptions.push({name: $filter("translate")(objName + ".label"), value: objName})
            }), _this.search = function (searchTerm) {
                _this.message = null, !searchTerm || searchTerm && searchTerm.trim().length < 3 ? _this.message = UtilService.translate("mobile_global_msg_searchTermLengthRequired", "cl.global.msg_searchTermLengthRequired") : LocalDataService.getFilterConfigByObjectType(_this.sobject.attributes.type).then(function (filterConfigByObjectType) {
                    if (filterConfigByObjectType.length) {
                        for (var filterConfig = " AND ", i = 0; i < filterConfigByObjectType.length; i++) filterConfigByObjectType[i].field == _this.detail.name && (filterConfig += filterConfigByObjectType[i].condition);
                        var searchPattern = new RegExp("###(.*)###");
                        if (searchPattern.test(filterConfig)) {
                            var fieldName = searchPattern.exec(filterConfig);
                            _this.sobject.hasOwnProperty(fieldName[1]) && (filterConfig = filterConfig.replace(fieldName[0], _this.sobject[fieldName[1]]))
                        }
                        LocalDataService.globalSearch(_this.objectType, searchTerm, limitSize, null, "ASC", filterConfig).then(function (resolve) {
                            _this.searchResults = resolve, _this.showingRecords = _this.searchResults.slice(0, pageSize), cordova.plugins.Keyboard.close(), resolve && resolve.length || (_this.message = UtilService.translate("mobile_global_msg_searchWithNoResults", "cl.global.msg_searchWithNoResults").trim() + " '" + searchTerm + "'")
                        })
                    } else LocalDataService.globalSearch(_this.objectType, searchTerm, limitSize).then(function (resolve) {
                        _this.searchResults = resolve, _this.showingRecords = _this.searchResults.slice(0, pageSize), cordova.plugins.Keyboard.close(), resolve && resolve.length || (_this.message = UtilService.translate("mobile_global_msg_searchWithNoResults", "cl.global.msg_searchWithNoResults").trim() + " '" + searchTerm + "'")
                    })
                })
            }, _this.loadMore = function () {
                _this.showingRecords = _this.showingRecords.concat(_this.searchResults.slice(_this.showingRecords.length, _this.showingRecords.length + pageSize)), $scope.$broadcast("scroll.infiniteScrollComplete")
            }, _this.moreDataCanBeLoaded = function () {
                return _this.showingRecords.length < _this.searchResults.length
            }, _this.changeObjectType = function (firstLoading) {
                _this.objectLabel = $filter("translate")(_this.objectType + ".label"), DescribeService.getTabIconPathInAsset(_this.objectType).then(function (iconPath) {
                    _this.objectTabIconPath = iconPath
                }, function (error) {
                    _this.objectTabIconPath = void 0
                }), !firstLoading && _this.searchTerm && _this.searchTerm.trim().length >= 3 && _this.search(_this.searchTerm)
            }, _this.changeObjectType(!0), _this.selectReference = function (selectedItem) {
                _this.value = selectedItem.Id, _this.sobject[_this.detail.name] = selectedItem.Id, _this.sobject[_this.detail.name + "_sid"] = selectedItem._soupEntryId, _this.sobject[_this.detail.name + "_type"] = _this.objectType, _this.sobject[_this.detail.relationshipName] = {
                    Id: selectedItem.Id,
                    Name: selectedItem.Name,
                    _soupEntryId: selectedItem._soupEntryId,
                    type: _this.objectType
                }, _this.referencedObjectName = selectedItem.Name, $scope.closeModal()
            }
        }
    }],
    transclude: "true",
    controllerAs: "$ctrl"
}), angular.module("oinio.core.pageLayoutRenderer").component("richtextComponent", {
    templateUrl: "app/core/pagelayout/layoutitems/richtext.component/richtext.component.html",
    require: {form: "^form"},
    bindings: {value: "<", detail: "<", required: "<", tabOrder: "<", editableForUpdate: "<"},
    controller: function () {
        this.itemEditableForUpdate = !1, this.itemIsEditableForUpdate = function () {
            return (!this.readOnlyFields || this.readOnlyFields.indexOf(this.detail.name) === -1) && this.editableForUpdate
        }, this.$onInit = function () {
            this.itemEditableForUpdate = this.itemIsEditableForUpdate()
        }
    },
    transclude: "true",
    controllerAs: "$ctrl"
}), angular.module("oinio.core.pageLayoutRenderer").component("stringComponent", {
    templateUrl: "app/core/pagelayout/layoutitems/string.component/string.component.html",
    require: {form: "^form"},
    bindings: {
        value: "<",
        detail: "<",
        required: "<",
        tabOrder: "<",
        editableForUpdate: "<",
        readOnlyFields: "<",
        onChange: "&"
    },
    controller: function () {
        this.itemEditableForUpdate = !1, this.itemIsEditableForUpdate = function () {
            return (!this.readOnlyFields || this.readOnlyFields.indexOf(this.detail.name) === -1) && this.editableForUpdate
        }, this.$onInit = function () {
            switch (this.itemEditableForUpdate = this.itemIsEditableForUpdate(), this.detail.type) {
                case"email":
                    this.type = "email";
                    break;
                case"phone":
                    this.type = "tel";
                    break;
                default:
                    this.type = "text"
            }
        }, this.change = function () {
            this.onChange && this.onChange({fieldName: this.detail.name})
        }
    },
    transclude: "true",
    controllerAs: "$ctrl"
}), angular.module("oinio.core.pageLayoutRenderer").component("textareaComponent", {
    templateUrl: "app/core/pagelayout/layoutitems/textarea.component/textarea.component.html",
    require: {form: "^form"},
    bindings: {
        value: "<",
        detail: "<",
        required: "<",
        tabOrder: "<",
        editableForUpdate: "<",
        hideLabel: "<",
        readOnlyFields: "<",
        onChange: "&"
    },
    controller: function () {
        this.itemEditableForUpdate = !1, this.itemIsEditableForUpdate = function () {
            return (!this.readOnlyFields || this.readOnlyFields.indexOf(this.detail.name) === -1) && this.editableForUpdate
        }, this.$onInit = function () {
            this.itemEditableForUpdate = this.itemIsEditableForUpdate()
        }, this.change = function () {
            this.onChange && this.onChange({fieldName: this.detail.name})
        }
    },
    transclude: "true",
    controllerAs: "$ctrl"
});
